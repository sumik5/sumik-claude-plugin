---
allowed-tools: Bash, Skill
description: 会話履歴とステージ済み変更からConventional Commits準拠のコミットメッセージを生成・表示
---

# Commit Message Command

このコマンドは、現在の会話コンテキスト（なぜこの変更をしたか、どんな議論があったか）とVCSの差分情報を組み合わせ、Conventional Commits準拠のコミットメッセージを生成します。

## 使用方法

```bash
/commit-msg
```

### 引数

引数はありません。実行するだけでコミットメッセージを生成します。

### 前提条件

- jjリポジトリ（`.jj` ディレクトリが存在する）または gitリポジトリ（`.git` ディレクトリが存在する）内で実行する必要があります
- コミット対象の変更が存在する必要があります

### エラー条件

以下の場合はエラーメッセージを表示して終了します：

- VCSリポジトリでない場合
  - エラーメッセージ: `エラー: jjリポジトリでも gitリポジトリでもありません`
- コミット対象の変更がない場合
  - エラーメッセージ: `エラー: コミット対象の変更が見つかりません`

## 実行内容

1. **VCS検出**: `.jj` ディレクトリの有無でjjかgitかを判定
2. **差分取得**: jjの場合は `jj diff`、gitの場合は `git diff --cached` で変更を取得
3. **スキルロード**: `writing-conventional-commits` スキルをロード
4. **メッセージ生成**: 会話履歴（Claudeのコンテキスト）と差分情報を分析してメッセージを生成
5. **メッセージ表示**: 生成したコミットメッセージをコードブロックで表示
6. **ユーザー確認**: コミット実行・編集・キャンセルの選択を促す

## 手順

### ステップ1: VCS検出と差分取得

以下のbashコマンドを実行してVCSの種別を判定し、差分を取得してください：

```bash
# jjリポジトリかどうかを確認
if [ -d ".jj" ]; then
  echo "VCS_TYPE=jj"
  jj diff
elif [ -d ".git" ]; then
  echo "VCS_TYPE=git"
  git diff --cached
else
  echo "エラー: jjリポジトリでも gitリポジトリでもありません"
  exit 1
fi
```

**注意**:
- jjリポジトリの場合、`jj diff` は現在のワーキングコピー（`@`）の変更を出力します。jjはステージングエリアを持たず、すべての変更が自動的にカレントchangeに含まれます
- gitリポジトリの場合、`git diff --cached` はステージング済みの変更のみを出力します
- 差分が空の場合はエラーで終了してください

### ステップ2: スキルロード

Skillツールで `writing-conventional-commits` スキルをロードしてください。このスキルにはConventional Commits 1.0.0仕様の詳細（type一覧・scope・BREAKING CHANGE・フッター形式）が含まれています。

### ステップ3: コミットメッセージの生成

会話履歴（現在のコンテキスト）とステップ1で取得した差分情報を分析し、以下のルールでメッセージを生成してください：

#### 情報源の優先順位

1. **会話履歴**: 変更の目的・背景・議論内容（なぜこの変更をしたか）
2. **差分情報**: 実際に変更されたファイル・コードの内容（何を変更したか）

#### type の選択基準

| type | 使用ケース |
|------|-----------|
| `feat` | 新機能追加（新しいファイル、新しいコマンド、新しいスキルの追加など） |
| `fix` | バグ修正（誤った動作の修正） |
| `docs` | ドキュメントのみの変更（README.md、SKILL.md、コメントなど） |
| `style` | コードの意味に影響しない変更（空白、フォーマット、セミコロンなど） |
| `refactor` | バグ修正でも機能追加でもないコード変更 |
| `perf` | パフォーマンス改善 |
| `test` | テストの追加・修正 |
| `build` | ビルドシステム・外部依存関係の変更 |
| `ci` | CI設定ファイル・スクリプトの変更 |
| `chore` | その他（ツール設定、メンテナンス） |

#### BREAKING CHANGE の判定

以下のいずれかに該当する場合は BREAKING CHANGE を付与：
- 既存のAPIやインターフェースを破壊的に変更した
- 下位互換性のない変更を加えた

BREAKING CHANGE の記述方法：
- typeの後に `!` を付与: `feat!: 既存スキルの構造を大幅変更`
- またはフッターに `BREAKING CHANGE: 変更内容の説明` を記述

#### 生成フォーマット

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**生成ルール**:
- `<description>` は日本語で簡潔に（50文字以内推奨）
- body は変更の詳細・理由が必要な場合のみ記述（1行空行後に開始）
- footer は BREAKING CHANGE や関連Issue番号がある場合のみ記述
- 前置きや説明は不要、メッセージ本文のみを出力

#### scope の例（このプロジェクト固有）

- `skills`: スキル関連の変更
- `commands`: コマンド関連の変更
- `agents`: Agent定義の変更
- `hooks`: フック関連の変更
- `readme`: README.mdの変更

### ステップ4: メッセージ表示

生成したコミットメッセージを以下の形式で表示してください：

```
=== 生成されたコミットメッセージ ===

```git-commit
<生成されたメッセージ>
```

===
```

### ステップ5: ユーザー確認

AskUserQuestion で以下の選択肢を提示してください：

```python
AskUserQuestion(
    questions=[{
        "question": "このコミットメッセージを使用しますか？",
        "header": "コミットメッセージ確認",
        "options": [
            {"label": "このメッセージでコミット", "description": "生成されたメッセージでコミットを実行"},
            {"label": "メッセージを編集してコミット", "description": "メッセージを修正後にコミット"},
            {"label": "キャンセル", "description": "コミットせずに終了"}
        ],
        "multiSelect": False
    }]
)
```

**処理**:

- 「このメッセージでコミット」が選択された場合:
  - jjの場合: `jj commit -m "<生成されたメッセージ>"` を実行
  - gitの場合: `git commit -m "<生成されたメッセージ>"` を実行
  - 完了メッセージを表示

- 「メッセージを編集してコミット」が選択された場合:
  - ユーザーに修正内容を入力してもらうよう促す
  - 修正されたメッセージを確認後、コミットを実行

- 「キャンセル」が選択された場合:
  - 「コミットをキャンセルしました」と表示して終了

## 参考

- Conventional Commits仕様: https://www.conventionalcommits.org/ja/
- `writing-conventional-commits` スキル: type/scope/BREAKING CHANGE判定の詳細ガイド
