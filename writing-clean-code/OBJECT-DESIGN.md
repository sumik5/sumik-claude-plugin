# オブジェクト設計

## 概要

オブジェクト設計における最大の課題は、貧血モデル、プリミティブ型への執着、過度な変更可能性です。本章では、データではなく振る舞いを中心に設計し、カプセル化を保護し、不変性を重視する実践的なリファクタリングパターンを提供します。

## コードスメル検出チェックリスト

- [ ] ゲッター/セッターだけのクラスが存在する
- [ ] String/int等でドメイン概念を表現している
- [ ] DTOが乱用されている
- [ ] 空のコンストラクタでオブジェクトを生成している
- [ ] setXXX()メソッドで本質的な属性を変更している
- [ ] public属性が存在する
- [ ] 連想配列でビジネスオブジェクトを表現している
- [ ] 文字列操作が多い
- [ ] var宣言が多く、constが少ない
- [ ] 遅延初期化を多用している

---

## 貧血モデル（Ch.3）

### 概要

貧血オブジェクトは、実質的な振る舞いを持たず、属性のみで構成されます。ゲッター/セッターを通じた外部公開はカプセル化を侵害し、手続き型スタイルに陥りやすくします。

### レシピ3.1: 貧血オブジェクトのリッチオブジェクトへの変換

**問題**: 外部操作から保護されていないpublic属性を持つオブジェクト

**解決策**: すべての属性をprivateにし、振る舞いのみを公開

**コード例**:
```java
// Before
public class Song {
    public String name;
    public String authorName;
    public String albumName;
}

// After
public class Song {
    private String name;
    private Artist author;
    private Album album;

    public String albumName() {
        return album.name();
    }
}
```

**関連レシピ**: 3.5, 10.1

---

### レシピ3.2: オブジェクトの本質の見極め

**問題**: オブジェクトの不変条件が特定されておらず、本質的な属性が保護されていない

**解決策**: 本質的な属性の変更を防止。オブジェクト作成時に本質を設定し、以降は変更不可に

**コード例**:
```javascript
// Before
const date = new Date();
date.setMonth(4); // 本質を変更している

// After
const date = new ImmutableDate("2022-03-25");
// 以降、dateは不変
```

**関連レシピ**: 5.3, 17.11

---

### レシピ3.3: オブジェクトからのセッターの除去

**問題**: セッターによる外部からの操作で不変性が失われている

**解決策**: すべてのセッターを削除し、コンストラクタで本質的な属性を設定

**コード例**:
```java
// Before
public class Point {
    protected int x;
    protected int y;

    public void setX(int x) { this.x = x; }
    public void setY(int y) { this.y = y; }
}

// After
public class Point {
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

**関連レシピ**: 3.5, 3.7, 3.8

---

### レシピ3.4: 貧弱なコード生成ツールの利用の廃止

**問題**: コード生成ウィザードやAIツールが貧血クラスを生成している

**解決策**: コード生成を停止し、明示的で読みやすいコードを手動で作成

**コード例**:
```php
// Before (メタプログラミングで自動生成)
AnemicClassCreator::create('Employee', [
    new AutoGeneratedField('id', '$validators->getIntegerValidator()'),
    new AutoGeneratedField('name', '$validators->getStringValidator()')
]);

// After (明示的な実装)
final class Employee {
    private $name;
    private $workingStatus;

    public function __construct(string $name, WorkingStatus $workingStatus) {
        $this->name = $name;
        $this->workingStatus = $workingStatus;
    }

    public function name(): string {
        return $this->name;
    }
}
```

**関連レシピ**: 10.1, 23.1

---

### レシピ3.5: 属性から自動生成されるゲッター/セッターの除去

**問題**: 振る舞いを考慮せず、属性から機械的にゲッター/セッターを生成している

**解決策**: 自動生成を止め、MAPPERの原則に従って必要な振る舞いのみを手動で作成

**コード例**:
```csharp
// Before
class Person {
    public string name { get; set; }
}

// After
class Person {
    private string name;

    public Person(string personName) {
        name = personName;
    }
}
```

**関連レシピ**: 3.1, 3.3, 3.6, 3.8, 4.8

---

### レシピ3.6: DTOの除去

**問題**: DTOを使用してレイヤー間でデータを転送している

**解決策**: DTOを廃止し、振る舞いを持つドメインオブジェクトを使用。部分情報の転送にはプロキシやNullオブジェクトを活用

**コード例**:
```php
// Before
final class SocialNetworkProfile {
    private $userName;
    private $friends;
    private $feed;
}

final class SocialNetworkProfileDTO {
    public $userName;
    public $friends;
    public $feed;
}

// After (プロキシとNullオブジェクトを使用)
final class SocialNetworkProfile {
    private $userName;
    private $friends;
    private $feed;

    public function __construct(
        $userName,
        FriendsCollectionProtocol $friends,
        UserFeedBehavior $feed
    ) {
        $this->userName = $userName;
        $this->friends = $friends;
        $this->feed = $feed;
    }
}

final class FriendsCollectionProxy implements FriendsCollectionProtocol {
    // 軽量なプロキシとして転送
}

final class NullFeed extends UserFeedBehavior {
    // 必要に応じてエラーを投げる
}
```

**関連レシピ**: 3.1, 3.7, 16.1, 17.13

---

### レシピ3.7: 空のコンストラクタの除去と適切な初期化の実施

**問題**: 引数なしのコンストラクタで不完全なオブジェクトが生成される

**解決策**: すべての必須引数を渡す完全なコンストラクタを使用

**コード例**:
```java
// Before
public Person(); // 不完全

// After
public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
```

**関連レシピ**: 3.1, 3.3, 3.8, 11.2

---

### レシピ3.8: ゲッターの除去

**問題**: ゲッターによって内部実装の詳細が露呈している

**解決策**: getXXX()形式を避け、振る舞いに基づいた明示的なメソッドを作成

**コード例**:
```php
// Before
final class Window {
    public $width;
    public function getWidth() {
        return $this->width;
    }
}

// After
final class Window {
    private $width;

    public function width() {
        return $this->width;
    }

    public function area() {
        return $this->height * $this->width;
    }
}
```

**関連レシピ**: 3.1, 3.3, 3.5, 8.4, 17.16

---

### レシピ3.9: オブジェクトの無秩序な結合の防止

**問題**: ほかのオブジェクトのカプセル化された属性を侵害している

**解決策**: 属性を保護し、振る舞いのみを公開

**コード例**:
```php
// Before
final class Point {
    public $x;
    public $y;
}

// After
final class Point {
    private $rho;
    private $theta;

    public function x() {
        return $this->rho * cos($this->theta);
    }

    public function y() {
        return $this->rho * sin($this->theta);
    }
}
```

**関連レシピ**: 3.1, 3.3

---

### レシピ3.10: 動的属性の除去

**問題**: クラス内で宣言されていない動的属性を使用している

**解決策**: 属性は明示的に定義

**コード例**:
```python
# Before
class Dream:
    pass

nightmare = Dream()
nightmare.presentation = "私がサンドマンだ"

# After
class Dream:
    def __init__(self):
        self.presentation = ""

nightmare = Dream()
nightmare.presentation = "私がサンドマンだ"
```

**関連レシピ**: 3.1, 3.5

---

## プリミティブへの執着(Ch.4)

### 概要

プリミティブ型の過剰使用は、適切な抽象化の欠如を示します。String、Integer、Collectionへの単純なマッピングは、フェイルファストの原則に反します。小さなオブジェクトを見出し、具象化することで、コードの重複を避け、凝集度を高めます。

### レシピ4.1: 小さなオブジェクトの生成

**問題**: プリミティブ型のみを属性として持つ大きなオブジェクト

**解決策**: MAPPERモデル内で小さなオブジェクトの責務を見つけ、具象化

**コード例**:
```java
// Before
public class Person {
    private final String name;
}

// After
public class Name {
    private final String name;

    public Name(String name) {
        this.name = name;
        // 検証ロジック
    }
}

public class Person {
    private final Name name;
}
```

**関連レシピ**: 4.2, 4.9

---

### レシピ4.2: プリミティブデータの具象化

**問題**: 多くのプリミティブ型を過剰に使用している

**解決策**: 小さなオブジェクトを使用

**コード例**:
```java
// Before
int port = 8080;
InetSocketAddress in = open("example.org", port);

// After
Port server = Port.parse(this, "www.example.org:8080");
Port in = server.open(this);
URI uri = server.asUri(this);
```

**関連レシピ**: 4.1, 4.4, 4.7, 17.15

---

### レシピ4.3: 連想配列のオブジェクトとしての具象化

**問題**: 振る舞いを持たない連想配列で現実世界のオブジェクトを表現している

**解決策**: 適切なオブジェクトを使用

**コード例**:
```php
// Before
$coordinate = array('latitude'=>1000, 'longitude'=>2000);

// After
final class GeographicCoordinate {
    function __construct($latitudeInDegrees, $longitudeInDegrees) {
        if (!$this->isValidLatitude($latitudeInDegrees)) {
            throw new InvalidLatitudeException($latitudeInDegrees);
        }
        $this->longitude = $longitudeInDegrees;
        $this->latitude = $latitudeInDegrees;
    }
}

$coordinate = new GeographicCoordinate(1000, 2000); // エラー発生
```

**関連レシピ**: 3.1

---

### レシピ4.4: 文字列の乱用の防止

**問題**: 文字列操作関数を過剰に使用している

**解決策**: 適切に設計されたオブジェクトを使用

**コード例**:
```php
// Before
$schoolDescription = 'College of Springfield';
preg_match('/[^ ]*$/', $schoolDescription, $results);
$location = $results[0];

// After
class School {
    private $name;
    private $location;

    function description() {
        return $this->name . ' of ' . $this->location->name;
    }
}
```

**関連レシピ**: 4.2, 4.7

---

### レシピ4.5: タイムスタンプの適切なモデル化

**問題**: 単なる順序付けのためにタイムスタンプに依存している

**解決策**: タイムスタンプではなく、順序付けの振る舞いのみが必要な場合は数値シーケンスを使用

**コード例**:
```python
# Before
import time
ts1 = time.time()
ts2 = time.time() # 同じ時刻になる可能性

# After
numbers = range(1, 100000)
```

**関連レシピ**: 17.2, 18.5, 24.3

---

### レシピ4.6: サブセットの独立したオブジェクトとしての具象化

**問題**: スーパーセットのドメインでオブジェクトをモデル化し、検証が重複している

**解決策**: サブセットに特化した小さなオブジェクトを作成し、検証を一箇所に集約

**コード例**:
```java
// Before
validDestination = "destination@example.com"
invalidDestination = "destination.example.com" // エラーなし

// After
public class EmailAddress {
    public String emailAddress;

    public EmailAddress(String address) {
        String expression = "^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$";
        if (!address.matches(expression)) {
            throw new Exception("無効なメールアドレスです");
        }
        this.emailAddress = address;
    }
}

destination = new EmailAddress("destination@example.com");
```

**関連レシピ**: 4.2, 25.1

---

### レシピ4.7: 文字列検証のオブジェクトとしての実装

**問題**: 特定形式の文字列を単なる文字列型として扱っている

**解決策**: ドメイン固有のオブジェクトを見出し、独立したクラスとして実装

**コード例**:
```php
// Before
class Address {
    function __construct(string $emailAddress) {
        $this->validateEmail($emailAddress);
    }
}

// After
class EmailAddress {
    private function __construct(string $emailAddress) {
        $regex = "/[a-zA-Z0-9_-.+]+@[a-zA-Z0-9-]+.[a-zA-Z]+/";
        if (!preg_match($regex, $emailAddress)) {
            throw new Exception('無効なメールアドレスです');
        }
        $this->address = $emailAddress;
    }
}

class Address {
    function __construct(EmailAddress $emailAddress) {
        // 常に有効
    }
}
```

**関連レシピ**: 4.4, 6.10

---

### レシピ4.8: 不要な属性の除去

**問題**: 振る舞いではなく、属性に基づいてオブジェクトを作成している

**解決策**: 偶発的な属性を取り除き、必要な振る舞いを追加した後、振る舞いに必要な属性のみを追加

**コード例**:
```ruby
# Before
class PersonInQueue
    attr_accessor :name, :job
end

# After
class PersonInQueue
    def moveForwardOnePosition
        # 振る舞いを実装
    end
end
```

**関連レシピ**: 3.1, 3.5, 3.6, 17.17

---

### レシピ4.9: 日付範囲オブジェクトの具象化

**問題**: 「開始日は終了日よりも前であるべき」といった不変条件が設定されていない

**解決策**: 日付範囲を表す独立したオブジェクトを具象化

**コード例**:
```kotlin
// Before
val from = LocalDate.of(2018, 12, 9)
val to = LocalDate.of(2022, 12, 22)
val elapsed = elapsedDays(from, to) // チェックなし

// After
data class Interval(val fromDate: LocalDate, val toDate: LocalDate) {
    init {
        if (fromDate >= toDate) {
            throw IllegalArgumentException("開始日は終了日よりも前でなければなりません")
        }
    }

    fun elapsedDays(): Long {
        return ChronoUnit.DAYS.between(fromDate, toDate)
    }
}
```

**関連レシピ**: 4.1, 4.2, 10.1

---

## 変更可能性（Ch.5）

### 概要

不適切な変更は、設計原則に違反し、不完全な表現を生み出し、波及効果を引き起こします。オブジェクトが偶発的に変更されているのか、本質的に変更されているのかを見分け、本質的な変更を禁止します。

### レシピ5.1: varのconstへの変更

**問題**: 実質的には定数であるものがvarで宣言されている

**解決策**: 値の変更が必要な場合を除き、すべての値をconst(定数)として宣言

**コード例**:
```javascript
// Before
var pi = 3.14
pi = 3.1415 // エラーなし

// After
const pi = 3.14
pi = 3.1415 // エラー
```

**関連レシピ**: 5.2, 5.4

---

### レシピ5.2: 変更が必要な変数の適切な宣言

**問題**: 値が決して変更されていない変数

**解決策**: 変更可能性を明示的に示す宣言を使用

**コード例**:
```php
// Before
function configureUser() {
    $password = '123456';
    $user = new User($password);
}

// After
define("USER_PASSWORD", '123456');
function configureUser() {
    $user = new User(USER_PASSWORD);
}
```

**関連レシピ**: 5.1, 5.6, 6.1, 6.8

---

### レシピ5.3: 本質に対する変更の禁止

**問題**: オブジェクトがその本質を変更している

**解決策**: 一度設定された本質的な属性の変更を禁止

**コード例**:
```javascript
// Before
const date = new Date();
date.setMonth(4); // 本質を変更

// After
class Date {
    // setMonth()を削除
}
```

**関連レシピ**: 17.11

---

### レシピ5.4: 変更可能なconst配列の回避

**問題**: constで宣言した配列の内容を変更している

**解決策**: 言語の変更可能性宣言のスコープを正確に理解し、スプレッド構文等を使用

**コード例**:
```javascript
// Before
const array = [1, 2];
array.push(3) // 変更される

// After
const array = [1, 2];
const newArray = [...array, 3] // 新しい配列を作成
```

**関連レシピ**: 5.1, 5.6

---

### レシピ5.5: 遅延初期化の除去

**問題**: 生成にコストのかかるオブジェクトを遅延初期化している

**解決策**: 遅延初期化を使用せず、オブジェクトプロバイダーを使用

**コード例**:
```ruby
# Before
class Employee
    def emails
        @emails ||= []
    end
end

# After
class Employee
    attr_reader :emails

    def initialize
        @emails = []
    end
end
```

**関連レシピ**: 15.1, 17.2

---

### レシピ5.6: 変更可能な定数の凍結

**問題**: constキーワードで宣言しても一部を変更できてしまう

**解決策**: イミュータブルな定数を使用

**コード例**:
```javascript
// Before
const ALL_CONSTANTS = {
    DISCOUNT: {
        PLATINUM: 0.1
    }
};
ALL_CONSTANTS.DISCOUNT.PLATINUM = 0.12; // エラーなし

// After
export const ALL_CONSTANTS = Object.freeze({
    DISCOUNT: Object.freeze({
        PLATINUM: 0.1
    })
});
```

**関連レシピ**: 5.4, 6.1, 6.8

---

### レシピ5.7: 副作用の除去

**問題**: 副作用を伴う関数が存在する

**解決策**: 副作用を避け、参照透過性を高める

**コード例**:
```typescript
// Before
let counter = 0;
function incrementCounter(value: number): void {
    counter += value; // グローバル変数を変更
    console.log(`カウンタの値は${counter}です`);
}

// After
function incrementCounter(counter: number, value: number): number {
    return counter + value; // 副作用なし
}
```

**関連レシピ**: 18.1

---

### レシピ5.8: 変数の巻き上げの防止

**問題**: 変数を宣言する前に使用している

**解決策**: 変数を明示的に宣言し、スコープに注意

**コード例**:
```javascript
// Before
console.log(willBeDefinedLater); // undefined
var willBeDefinedLater = "Beatriz";

// After
const dante = "abandon hope all ye who enter here";
console.log(dante);
```

**関連レシピ**: 5.1, 21.3

---

## 相互参照

- 3.1 → 3.5, 3.8, 10.1
- 3.2 → 5.3, 17.11
- 3.5 → 3.1, 3.3, 3.6, 3.8, 4.8
- 3.6 → 3.1, 3.7, 16.1, 17.13
- 3.8 → 3.1, 3.3, 3.5, 8.4, 17.16
- 4.1 → 4.2, 4.9
- 4.2 → 4.1, 4.4, 4.7, 17.15
- 5.1 → 5.2, 5.4
- 5.3 → 17.11
