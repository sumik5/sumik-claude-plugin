# 要件定義とクラス設計

アプリケーション開発の出発点となる要件定義と、良いクラス設計の2大目標（高凝集・低結合）を体系化する。

## 要件定義の全体像

**「正しいアプリケーション」を作る**ことが先決。いくら良く設計されていても、クライアントが求めるものでなければ失敗。

開発タイムライン上の主要マイルストーン:

| フェーズ | 主な活動 |
|---------|---------|
| 要件収集 | インタビュー・観察・プロトタイプ提示 |
| 機能仕様書 | 要件・ユースケースの文書化 |
| 要件フリーズ | 変更受付の締め切り（柔軟な対応も必要） |
| 設計・実装 | 反復開発（design→code→test） |
| フィーチャーフリーズ | 機能追加の締め切り |
| リリース | デプロイ |

## 機能要件（Functional Requirements）

アプリケーションが**必ず行うべき操作**を定義する。強い助動詞 `must`・`shall` を使って記述する。

```
- ユーザーはカタログに書籍を追加できなければならない（must）
- 文字列マッチングは大文字・小文字を区別しないものとする（shall）
- ユーザーはワイルドカード属性を指定できなければならない（must）
```

弱い表現（`should`・`could`）は避ける。あいまいな要件は悪いアプリケーションを生む。

## 非機能要件（Nonfunctional Requirements）

アプリケーションが満たすべき**制約・制限**を定義する。機能要件と同等に重要。

| カテゴリ | 例 |
|---------|-----|
| パフォーマンス | 検索は2秒以内に完了すること |
| プラットフォーム | Windows・macOS・Linuxで動作すること |
| UI一貫性 | 旧バージョンのUIに近い形とすること |
| 国際化 | 英語・スペイン語・ベトナム語に対応すること |

非機能要件も `must`・`shall` で記述し、検証可能な形にする。

## 良い要件の7条件

| 条件 | 説明 |
|------|------|
| 明確性（Clarity） | 非技術者・開発者の双方が理解できる平易な表現 |
| 一貫性（Consistency） | 要件間で矛盾がない |
| 正確性（Correctness） | 各要件が正確である |
| 完全性（Completeness） | 抜け漏れがない（ギャップは誤推測を招く） |
| 現実性（Realistic） | 達成不可能な要件を含まない |
| 検証可能性（Verifiable） | テストで要件充足を確認できる |
| トレーサビリティ（Traceability） | 各要件→機能・制約が追跡でき、不要機能が混入しない |

## 要件の収集方法

### インタビューとその落とし穴

- クライアントへのインタビュー（複数回必要）
- クライアントは**自分が何を望むか分からない**ことがある
- 圧力をかけると架空の要件を作り上げてしまう
- クライアントのドメイン知識と開発者のスキルの橋渡しが必要

### 補完的な収集手法

| 手法 | 説明 |
|------|------|
| 観察 | 現在の作業方法を観察し、改善ポイントを見つける |
| プロトタイプ | 動くコード・スライドデッキで具体化し反応を得る |
| 暗黙の要件発見 | A・Cが必要なら、Bも必要なはずと推論する |
| 継続的な関与 | クライアントを仮想チームメンバーとして扱う |

要件収集も反復プロセス。プロトタイプ提示 → フィードバック → 要件更新 を繰り返す。

## ユースケース（Use Cases）

要件に文脈を与え、エンドユーザーの視点でアプリケーションの振る舞いを記述する。

### UMLユースケース図の要素

| 要素 | 説明 |
|------|------|
| ユースケース（楕円） | 動詞＋名詞形で命名（例: "Add Book", "Search Catalogue"） |
| アクター（人形） | アプリケーション外部のエージェント（人・他システム） |
| 境界ボックス | アプリケーションの内側・外側を明確に区分 |
| インタラクション線 | アクターとユースケースの関係を示す |

1つのダイアグラムに含めるユースケースは6つ程度まで。複雑な場合は複数のダイアグラムに分割。

### ユースケース記述の構成

| 要素 | 内容 |
|------|------|
| 名称 | 動詞＋名詞（"Search Catalogue"） |
| ゴール | アクターが達成したいこと |
| 概要 | 1〜2文での説明 |
| アクター | 関与する人・システム |
| 事前条件 | このユースケース開始前に成立すべき条件 |
| トリガー | ユースケースを開始するアクターの行為 |
| 主要アクションシーケンス | 正常系のステップ（最大10ステップ程度） |
| 代替アクションシーケンス | エラー・例外時の対応ステップ |
| 事後条件 | ユースケース完了後の状態 |
| 非機能要件 | 適用される非機能要件の参照 |
| 用語集 | 専門用語の定義 |

ユースケース記述は**実装詳細を含めない**。何をするかを書き、どう実装するかは書かない。

### ユースケース記述の例（書籍検索）

```
名称: Search Catalogue
ゴール: 目標属性に一致する書籍を検索する

主要アクションシーケンス:
  1. アプリケーションが入力フォームの内容を検証する
  2. アプリケーションが書籍属性からデータベースクエリを構築する
  3. アプリケーションがクエリをデータベースに送信する
  4. データベースが一致する書籍リストを返す
  5. アプリケーションが書籍リストを整形・表示する
  6. カスタマーが一致する書籍を確認する

代替シーケンス1（フォーム入力エラー）:
  2. エラーのあるフィールドをハイライト表示する
  3. エラーメッセージを表示する
  4. カスタマーがフィールドを修正する
  5. ステップ1に戻る
```

## 機能仕様書（Functional Specification）

開発チームが作成する、非技術的・ジャーゴン不使用の文書。クライアントが読んで承認できる内容にする。

### 含むべき内容

- アプリケーション名
- 問題の明確な説明
- 目的
- 機能要件リスト（`must`・`shall` で記述）
- 非機能要件リスト
- ユースケース（UML図＋記述）

クライアントが機能仕様書を読んで**承認することが検証（Validation）**：「正しいものを作る」の確認。開発者がテストで**正しく作れているか確認することが検証（Verification）**：「正しく作る」の確認。

## 要件からクラスを導出する

### ステップ1: テキスト分析 — 名詞からクラスを探す

要件文の名詞をリストアップし、クラスになるかを判断する。

| 名詞 | クラスにするか | 理由 |
|------|--------------|------|
| catalogue | Yes | アプリケーションの中核オブジェクト |
| book | Yes | カタログが保管するオブジェクト |
| attribute | Yes | 書籍の属性セット |
| librarian | No | アプリケーション外部のアクター |
| customer | No | アプリケーション外部のアクター |
| form | Yes | ユーザー入力フォーム |
| kind | No | 列挙定数の属性値 |
| title | No | 文字列の属性値 |
| year | No | 整数の属性値 |
| genre | No | 列挙定数の属性値 |
| string | No | Python組み込み型 |

### ステップ2: テキスト分析 — 動詞からメソッドを探す

要件文の（他動詞の）動詞をリストアップし、どのクラスのメソッドになるかを決める。

| 動詞 | クラス | メソッド |
|------|--------|---------|
| add | Catalogue | `add()` — booklist に書籍を追加 |
| update | Catalogue | `update()` — 既存書籍を更新 |
| delete | Catalogue | `delete()` — 書籍を削除 |
| search | Catalogue | `find()` — 一致する書籍を検索 |
| verify | Form | `verify()` — フォーム入力を検証 |
| match | Attributes | `is_match()` — 属性が一致するか判定 |

### 初期クラス一覧の例

| クラス | 状態 | インスタンス変数 |
|--------|------|----------------|
| Catalogue | 書籍リスト | `_booklist: list[Book]` |
| Book | 書籍属性 | `_attributes: Attributes` |
| Attributes | 属性値辞書 | `_dictionary: dict[Key, Any]` |
| Form | 入力値 | 書籍属性ごとの個別変数 |

## クラス設計の2大目標

### 目標1: 高凝集（Cohesion）— Single Responsibility Principle

**クラスは単一の主要責務のみを持つべき**。責務が1つなら、変更理由も1つで済む。

凝集していないクラスの問題:

```python
# 悪い例: Automobile が3つの責務を持つ
class Automobile:
    # 運転操作
    def accelerate(self): ...
    def apply_brakes(self): ...
    def turn_left(self): ...

    # 整備
    def change_oil(self): ...
    def rotate_tires(self): ...
    def tuneup_engine(self): ...

    # 洗車
    def vacuum_car(self): ...
    def wash_car(self): ...
    def wax_car(self): ...
```

```python
# 良い例: 責務ごとに分離
class Automobile:
    """自動車の運転操作を担う"""
    def accelerate(self): ...
    def apply_brakes(self): ...
    def turn_left(self): ...
    def turn_right(self): ...

class Garage:
    """自動車の整備を担う"""
    def __init__(self, car: Automobile):
        self._car = car

    def change_oil(self): ...
    def rotate_tires(self): ...
    def tuneup_engine(self): ...

class CarWash:
    """自動車の洗車を担う"""
    def __init__(self, car: Automobile):
        self._car = car

    def vacuum_car(self): ...
    def wash_car(self): ...
    def wax_car(self): ...
```

### 目標2: 低結合（Loose Coupling）— Principle of Least Knowledge

**クラスは互いの実装詳細をなるべく知らないべき**。依存が少ないほど、一方の変更が他方に波及しない。

```python
# Catalogue は Attributes の内部実装を知らない
class Catalogue:
    def __init__(self):
        self._booklist: list[Book] = []

    def add(self, attrs: Attributes) -> None:
        # attrs の内部構造を知らなくていい
        self._booklist.append(Book(attrs))

    def find(self, target_attrs: Attributes) -> list[Book]:
        # マッチング処理を Attributes に委譲（Catalogue は詳細を知らない）
        return [b for b in self._booklist
                if b.attributes.is_match(target_attrs)]
```

結合の強度チェック:

| 確認項目 | 低結合 | 高結合 |
|---------|--------|--------|
| インスタンス変数 | 相手クラスの内部変数を参照しない | 相手の `_private` 変数を直接使用 |
| メソッド依存 | インターフェース（公開メソッド）のみを使う | 実装詳細のメソッドに依存 |
| 変更時影響 | 相手変更に追随不要 | 相手変更のたびに修正が必要 |

## UMLクラス図

クラス設計を文書化する標準的な手段。

### 基本表記

- `+` : public（公開）
- `-` : private（非公開）
- 下線 : static メソッド

### クラス間の関係

| 矢印の種類 | 意味 | Pythonでの対応 |
|-----------|------|----------------|
| 実線矢印 | 依存関係 | インスタンス変数・引数として参照 |
| 破線矢印 | 一時的な依存 | メソッドの引数・ローカル変数のみ |
| 開いたひし形 | 集約（Aggregation） | コンテナが要素を保持（独立して存在可能） |
| 塗りつぶしひし形 | 合成（Composition） | 要素がコンテナなしに存在不可 |
| 開いた三角矢印 | 汎化（継承） | `class Subclass(Superclass):` |
| 破線＋開いた三角 | 実装（インターフェース） | `class Concrete(Interface):` |

### 抽象クラスとインターフェースクラス

```python
from abc import ABC, abstractmethod

# 抽象クラス: 抽象メソッド + 共通実装を持てる
class MotorVehicle(ABC):
    def __init__(self):
        self._speed = 0

    @abstractmethod
    def start_engine(self) -> None: pass

    @abstractmethod
    def stop_engine(self) -> None: pass

    def drive(self) -> None:
        # 共通実装（サブクラスで上書き可能）
        self.start_engine()
        self.accelerate()
        self.stop_engine()

# インターフェースクラス: 抽象メソッドのみ（インスタンス変数なし）
class MotorVehicleInterface(ABC):
    @abstractmethod
    def start_engine(self) -> None: pass

    @abstractmethod
    def stop_engine(self) -> None: pass

    @abstractmethod
    def accelerate(self) -> None: pass
```

UML図では:
- 抽象クラス: クラス名をイタリック体
- インターフェース: クラス名の上に `«interface»`

## UML状態図（State Diagram）

単一オブジェクトが実行時にどのように状態変化するかを視覚化する。クラスに正しいインスタンス変数・メソッドが設計できているかの確認ツール。

主な構成要素:

| 要素 | 意味 |
|------|------|
| 丸みある矩形 | 状態 |
| 矢印 | 状態遷移 |
| 矢印のラベル | 遷移を引き起こすイベント（メソッド呼び出し等） |
| 塗りつぶし円 | 開始点 |
| 塗りつぶし円＋外側円 | 終了点 |
| 塗りつぶしひし形 | 条件分岐 |

## UMLシーケンス図（Sequence Diagram）

ユースケース実行中のオブジェクト間の相互作用を時系列で示す。メソッドの割り当てとクラス間の関係が正しく設計できているかの確認ツール。

| 要素 | 意味 |
|------|------|
| 上部の箱（下線付き）| インスタンス化されたオブジェクト |
| 縦の点線 | オブジェクトのライフライン（時間軸） |
| 縦の細い矩形 | オブジェクトがアクティブな期間 |
| 横矢印 | オブジェクト間のメッセージ（メソッド呼び出し） |

## 設計仕様書（Design Specification）

開発チームが作成する技術文書。現在・将来の開発者に向けて設計の理由と詳細を記録する。

含むべき内容:

- UMLクラス図（静的設計）
- UML状態図（動的振る舞い）
- UMLシーケンス図（オブジェクト間インタラクション）
- 内部テスト計画（ユニットテスト・回帰テスト）

機能仕様書（外部向け）とは対照的に、実装詳細を含める。

## 設計の進め方: 分析麻痺を避ける

| 注意点 | 対処 |
|--------|------|
| 完璧なクラス設計を一発で決めようとする | 初期クラスを決めたら反復開発で改善する |
| 要件が固まるまで実装しない | プロトタイプで要件を引き出しながら並行して進める |
| 要件変更を恐れる | 変更しやすい設計（カプセル化・疎結合）で対応する |
