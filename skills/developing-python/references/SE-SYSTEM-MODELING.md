# システムモデリングとアーキテクチャ設計

Pythonプロジェクトにおけるシステム設計の基盤。論理/物理アーキテクチャ、ユースケース、データフロー、IPC設計を体系化する。正式なドキュメントが存在しない場合も、ここで示す考え方は設計品質を高める思考習慣として有効。

---

## 論理アーキテクチャと物理アーキテクチャ

### 論理アーキテクチャ

**論理アーキテクチャ**は、コンポーネントが「物理的にどこに存在するか」を問わず、「何の役割を担うか」に着目した設計ビュー。

コンポーネントを別のサーバーへ移動させても、論理的な機能は変わらない。開発は論理アーキテクチャを中心に進めることが多い。

#### 3-tier モデル（最も一般的な構成）

| Tier | 役割 | Web アプリでの例 |
|------|------|----------------|
| **Presentation** | ユーザーとのインタラクション | Web サーバー / フロントエンド |
| **Application** | ビジネスロジック処理 | バックエンドコード（Python等） |
| **Data** | データの永続化 | データベース / ストレージ |

**リクエスト/レスポンスフロー：**
1. ユーザーが Presentation tier にリクエストを送信
2. Application tier が処理を引き受ける
3. Data tier からデータを取得・操作
4. Application tier がレスポンスを生成
5. Presentation tier がユーザーに返却

Application tier と Data tier を合わせて **Backend tier** と呼ぶことも多い。

### 物理アーキテクチャ

**物理アーキテクチャ**は、論理コンポーネントが実際にどのデバイス（サーバー、VM、コンテナ）に配置されるかを定義する。

| ケース | 物理的な特徴 |
|--------|------------|
| 小規模システム | 複数の論理コンポーネントを1台の物理サーバーにまとめる |
| 中〜大規模 | 論理コンポーネントごとに専用サーバーを割り当てる |
| クラウド / コンテナ | VM・コンテナを「仮想的な物理コンポーネント」として扱う |
| サーバーレス | 物理アーキテクチャが不要（AWS Lambda、Cloud Functions 等） |

> **原則：** 何かが「実際の物理サーバーのように振る舞う」なら、物理アーキテクチャ上もその扱いでよい。

### ドキュメント戦略

アーキテクチャはテキストまたはダイアグラムで記述する。それぞれのトレードオフ：

| 形式 | 長所 | 短所 |
|------|------|------|
| テキスト | 素早く作成できる | 標準がなければ理解しにくい |
| ダイアグラム | 視覚的に把握しやすい・非技術者にも伝わる | 作成に時間がかかる |

代表的なダイアグラムツール：PlantUML（UMLテキストから自動生成）、Lucidchart（GUIダイアグラム作成）。

---

## ユースケースモデリング

**ユースケース**は、ユーザー（アクター）がシステムにどのように関わるかを文書化したもの。「誰が何をできるか」を定義する。

### アクターの定義

アクターはシステムを利用するエンティティ。人間ユーザーだけでなく、システム自体もアクターになりうる。

| アクター種別 | 説明 | 例 |
|------------|------|-----|
| 主要アクター | システムを直接操作する人 | 管理者、オペレーター、ドライバー |
| 補助アクター | 主要アクターを支援・承認する人 | 管理者、承認者 |
| システムアクター | 自動化されたプロセス | スケジューラー、通知システム |

アクターは「役割」と関連する。1人の人間が複数のアクター役割を持つことも可能。

### ユースケースの作成手順

1. **システムが支援すべき活動を洗い出す**（要件・業務ヒアリング）
2. **各活動のアクターを定義する**（誰が実行するか）
3. **各ユースケースを記述する：**
   - 名前（短く明確に）
   - 説明（何が行われるか）
   - アクター（誰が関与するか）
   - 期待するデータ（何が必要か）
4. **ユースケース間の関係を確認する**（連鎖・依存）
5. **ダイアグラムで可視化する**（UML ユースケース図）

### ユースケース記述の例（汎用テンプレート）

```
ユースケース名: イベント記録
概要: オペレーターがシステムにイベントデータを記録する
アクター: オペレーター
入力データ: 対象ID、数量、日時、オドメーター等
後続処理: 効率計算 → 閾値判定 → アラート（条件次第）
```

### ユースケースとアジャイルの関係

| 概念 | 関係 |
|------|------|
| ユースケース | 正式な UML 文書として定義 |
| ユーザーストーリー | アジャイルでの軽量な代替表現 |
| エピック | 複数ストーリーをまとめた上位概念 |

チームの慣習次第で、ユーザーストーリー/エピックがユースケース文書の代替として十分機能することもある。

---

## データ構造とデータフロー

### エンティティ抽出手順

ユースケースを起点にデータ構造を導出する。核心的な問いは：

> **「このプロセスにはどんなデータが必要か？」**
> **「そのデータはどこに置くべきか？」**

#### 抽出ステップ

1. ユースケースの説明から名詞・数値を拾い上げる
2. 各データポイントに適切な型を割り当てる
3. データの「所有者」（どのエンティティに属するか）を決定する
4. 重複を避け、**Single Source of Truth** を維持する
5. プロセス実行後に生成される派生データを追加する

#### 型選択の指針

| データ種別 | 推奨型 | 避けるべき型 |
|-----------|--------|------------|
| 識別子（ID） | `int` / `str` | — |
| 金額・精度が重要な数値 | `Decimal` | `float` |
| 比率・計算値 | `float` | — |
| 日時 | `datetime` | `str` |
| フラグ | `bool` | `int` |

> **Python の `Decimal` 型**
> 浮動小数点の精度問題を回避するために `decimal.Decimal` を使用する。金額・燃料量など正確な計算が必要な値に適用する。

#### エンティティ設計例（汎用）

```python
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass

@dataclass
class Event:
    entity_id: int
    quantity: Decimal
    cost: Decimal | None  # 有料イベントのみ
    odometer: int
    recorded_at: datetime

@dataclass
class Entity:
    entity_id: int
    last_odometer: int
    efficiency_threshold: float
    available: bool = True
```

### データフロー設計

データフロー図（DFD）は、データがどのプロセスを経由してどう変換されるかを示す。

#### DFD の要素

| 要素 | 説明 |
|------|------|
| 外部エンティティ | データの発生源・到達先（ユーザー、外部システム） |
| プロセス | データを受け取り変換・出力する処理 |
| データストア | データの保存場所（DB、ファイル） |
| データフロー | プロセス間を流れるデータ |

#### フロー設計の手順

1. ユースケースの入力データを特定する
2. 各プロセスが「何を受け取り、何を出力するか」を定義する
3. 必要な変換・計算を書き出す
4. 条件分岐（アラート発生等）を追加する
5. データの読み書き先（DB テーブル）を明確にする

#### 例：イベント処理のフロー

```
受信: EventData（entity_id, quantity, cost, odometer）
  ↓
Entity レコードを取得（entity_id をキーに DB 参照）
  ↓
efficiency = (odometer - entity.last_odometer) / quantity を計算
  ↓
EventData に efficiency を付与して DB に書き込み
  ↓
Entity.last_odometer を更新
  ↓
efficiency < entity.efficiency_threshold ?
  → Yes: Alert プロセスを起動
  → No: 終了
```

> **Single Source of Truth の原則：** 同じデータを複数箇所に持つと、更新時に不整合が生じる。データポイントは1つのエンティティに集約する。

---

## プロセス間通信（IPC）

プロセスが増えると、それらの通信方法を明確に設計する必要がある。

### メッセージ設計の考慮点

| 考慮点 | 内容 |
|--------|------|
| **メッセージの内容** | 含まれるデータと型 |
| **フォーマット** | JSON、YAML、XML 等のシリアライズ形式 |
| **転送方法** | HTTP、メッセージキュー、直接呼び出し |
| **配信保証** | exactly-once / at-least-once / at-most-once |
| **受信後の処理** | メッセージの削除・再試行・エラー処理 |

### 通信パターン比較

#### 1. Monolithic Callables（関数呼び出し）

全コードが同一プロセス内に存在し、関数が関数を直接呼び出す。

```python
def handle_event(event: Event) -> None:
    result = process_event(event)
    if result.needs_alert:
        send_alert(result)  # 直接呼び出し
```

#### 2. API Calling Callables（REST / HTTP）

各機能をAPIエンドポイントとして公開し、HTTP経由で呼び出す。

```python
# メッセージのシリアライズ（JSON）
{
  "entity_id": 12,
  "odometer": 12345,
  "quantity": "12.345",
  "cost": "43.20"
}
# POST /api/events で送信
# アラート必要時: POST /api/maintenance-alerts に転送
```

HTTPメソッドとCRUD操作の対応：

| HTTP メソッド | CRUD 操作 |
|-------------|-----------|
| POST | Create |
| GET | Read |
| PUT | Update |
| DELETE | Delete |

#### 3. Queue-based Event-listener（メッセージキュー）

イベントをキューに積み、リスナーが非同期で処理する。

```python
# Producer: キューにメッセージを送信
queue.send(event.to_json())

# Consumer: キューをポーリングしてイベント処理
while True:
    message = queue.receive()
    if message:
        handle_event(Event.from_json(message))
        # アラート必要時は別キューに送信
```

代表的なキュー実装：RabbitMQ、Apache Kafka、AWS SQS、Google Cloud Pub/Sub。

### IPC 選択基準テーブル

| 基準 | Monolithic | API | Queue |
|------|-----------|-----|-------|
| **通信方式** | 同期（直接呼び出し） | 同期（HTTP） | 非同期 |
| **結合度** | 高（密結合） | 中（インターフェース分離） | 低（疎結合） |
| **スケーラビリティ** | 低（単一デプロイ） | 中（API単位でスケール） | 高（独立スケール） |
| **開発・デバッグ難度** | 低（単一コードベース） | 中 | 高（分散トレーシング必要） |
| **データ損失リスク** | 高（エラー時に未保存） | 中 | 低（キューが保持） |
| **インフラ複雑さ** | 低 | 中 | 高（キューサービス必要） |
| **デプロイ単位** | 全体を一括 | API 単位で独立 | 関数単位で独立 |
| **適したシステム規模** | 小〜中 | 中〜大 | 大・バースト処理 |

#### 選択ガイド

```
小規模 / 単一チーム / 迅速な開発優先
  → Monolithic

外部公開 / 複数クライアント / 独立デプロイ必要
  → API

高可用性 / 高スループット / データ損失許容不可 / サーバーレス
  → Queue-based
```

---

## システムスコープとスケール

### スコープの定義

設計文書が揃ったとき、以下がすべて把握できている状態がシステムスコープの完成：

| 設計成果物 | カバーする範囲 |
|-----------|------------|
| 論理アーキテクチャ | コンポーネントの役割と関係 |
| 物理アーキテクチャ | 配置先の実体（サーバー、クラウド等） |
| ユースケース | 実装すべき全ビジネスプロセス |
| データフロー | データの構造と移動経路 |
| IPC 設計 | プロセス間の通信フォーマット・プロトコル |

### スケールの計画

**スケール** = どれだけのオブジェクト・ユーザーが同時にシステムを利用するか。

| システム種別 | スケール予測精度 | 考慮点 |
|-----------|----------------|--------|
| 社内業務システム | 高（ユーザー数・データ量が限定的） | 予測可能な最大値で設計 |
| B2C Webアプリ | 低（バースト・急増あり） | 水平スケーリング・負荷分散必要 |

#### スケールが設計に与える影響

- **少量データ（数百〜数千件）**: 効率性より明確さを優先したコードでも問題なし
- **大量データ（数百万〜数十億件）**: クエリ最適化・インデックス設計・ページネーション必須
- **バースト対応が必要**: ロードバランサー・オートスケール・キュー導入を検討

### 非機能要件の設計反映

スコープとスケールを定義する際、以下の非機能要件も設計に織り込む：

| 非機能要件 | 設計への影響 |
|-----------|------------|
| 可用性（SLA） | デプロイ構成・冗長化 |
| レイテンシ | IPC 選択・キャッシュ戦略 |
| スループット | キュー・バッチ処理 |
| データ整合性 | トランザクション管理・べき等性 |
| セキュリティ | 認証・認可・入力検証 |

---

## まとめ：設計フロー

```
要件 / ユーザーヒアリング
  ↓
[1] 論理アーキテクチャ設計（コンポーネント・役割・関係）
  ↓
[2] 物理アーキテクチャ設計（配置先・インフラ・クラウド選択）
  ↓
[3] ユースケース定義（アクター・ワークフロー・データ要件）
  ↓
[4] データ構造設計（エンティティ抽出・型定義・単一ソース）
  ↓
[5] データフロー設計（DFD・処理順序・変換ポイント）
  ↓
[6] IPC 設計（通信パターン選択・メッセージフォーマット）
  ↓
[7] スコープ・スケール確認（非機能要件の設計反映）
  ↓
実装へ
```

正式な文書化が求められないプロジェクトでも、この思考フローを内面化することで設計品質が向上する。経験を積むことで、これらは自然な設計習慣となる。
