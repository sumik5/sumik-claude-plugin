# 高度な調査・攻撃手法リファレンス

## 概要

ブラックボックステストを超えた発展的手法をまとめたリファレンス。ソースコード解析戦略、クラウドサービス調査、制限回避・認証突破の技術を網羅。

---

## ソースコード解析戦略

### アプリケーション構成の把握

効率的な解析のため、対象システムの設計パターンとフレームワーク構成を事前に理解する。

| 把握対象 | 確認項目 | 効果 |
|---------|---------|------|
| **デザインパターン** | MVC、Clean Architecture、Hexagonal Architecture | 調査対象箇所の効率的な絞り込み |
| **フレームワーク構成** | ルーティング、DI利用有無、自動エスケープ | セキュリティ対策の実装箇所を推測 |
| **ルーティング設定** | エンドポイント一覧、特徴的な命名 | ファイルアップロード、認証、デバッグ機能を発見 |

**デザインパターン別の調査箇所**

| パターン | 層構造 | 脆弱性調査時の着目点 |
|---------|--------|-------------------|
| **MVC** | Model / View / Controller | 入力検証→Controller、SQLi→Model |
| **Spring MVC** | Controller / Service / Repository | ビジネスロジック→Service、データアクセス→Repository |
| **Clean/Hexagonal** | ドメイン層 / インフラ層 | ビジネスロジックは独立、技術詳細はインターフェース経由 |

---

### 入口（Source）からの解析

外部入力の入り口から調査するアプローチ。以下の脆弱性検出に効率的：

| 脆弱性種別 | 入口からの解析が効率的な理由 | 調査箇所 |
|-----------|--------------------------|---------|
| **CSRF** | トークン検証はミドルウェア・コントローラで実装 | リクエスト受信直後の検証ロジック |
| **認可制御（エンドポイントレベル）** | 主要処理の前に実行される | ミドルウェア、コントローラ、サービス呼び出し |
| **認可制御（オブジェクトレベル）** | DB取得後の検証、クエリでの絞り込み | フロー全体の把握が必要（入口から追跡） |
| **リスクの高いエンドポイント** | 認証、パスワードリセット、外部ID連携等 | 機能全体を丁寧に確認 |
| **怪しいパラメータ** | `filepath`, `url`, `command` 等 | grep検索でパラメータ名を探索 |

---

### 出口（Sink）からの解析

脆弱性が顕在化する箇所から呼び出し元を逆追跡するアプローチ。以下の脆弱性検出に効率的：

| 脆弱性種別 | Sinkの特徴 | 探索方法 |
|-----------|-----------|---------|
| **SQLインジェクション** | SQL実行関数（`query()`, `exec()`等） | 関数呼び出しを検索→呼び出し元を追跡 |
| **OSコマンドインジェクション** | シェル実行関数（`system()`, `exec()`等） | 危険な関数を検索→引数の伝搬を確認 |
| **SSRF** | HTTPリクエスト送信関数 | `http.get()`, `fetch()` 等を検索 |
| **パストラバーサル** | ファイル操作関数（`open()`, `readFile()`等） | ファイルアクセス関数の引数を追跡 |

**Sinkからの追跡フロー**

```
1. 危険な関数呼び出しを検索（例: os.system()）
2. 呼び出し元の関数を特定
3. さらに呼び出し元をたどる（コントローラ→ルーティング）
4. 各ステップで入力値の検証・無害化を確認
5. Source→Sinkの経路が存在し、無害化なし→脆弱性
```

---

### Taint Tracking（汚染追跡）

データフロー解析の一種。外部入力（Source）から危険な処理（Sink）までのデータ伝搬を追跡。

| 要素 | 定義 | 例 |
|-----|------|-----|
| **Source** | 信頼できない外部入力の取得箇所 | `$_GET["name"]`, `req.query("id")` |
| **Propagation** | 汚染されたデータの伝搬 | 変数代入、関数引数、戻り値 |
| **Sanitizer** | 無害化処理 | エスケープ関数、入力検証 |
| **Validator** | フォーマット検証 | 正規表現チェック、型検証 |
| **Sink** | 脆弱性が顕在化する処理 | SQL実行、コマンド実行、ファイル操作 |

**Taint Trackingの流れ**

```
Source → Propagation → [Sanitizer/Validator] → Sink
                              ↓
                        汚染除去されれば安全
                        なければ脆弱
```

**解析コスト**

| 要因 | 影響 | 対策 |
|-----|------|------|
| 多数のSource | 追跡経路が指数関数的に増加 | Sinkから逆追跡するアプローチ |
| 複雑な分岐 | 各経路を個別に追跡 | 静的解析ツール（SAST）の活用 |
| 手動解析の限界 | 大規模コードベースでは困難 | Semgrep、CodeQL等のツール利用 |

---

### 静的解析ツール（SAST）の活用

| ツール | 特徴 | 対応言語 | ライセンス |
|--------|------|---------|-----------|
| **CodeQL** | GitHub統合、QL言語で柔軟なクエリ | 多言語対応 | OSS/学術研究は無償、商用はGitHub Advanced Security必須 |
| **Semgrep** | Community版（OSS）とPro版 | 多言語対応 | Community版は単一ファイル内のみ、Pro版はファイル跨ぎ解析対応 |
| **SonarQube** | 2007年から開発、歴史が長い | 多言語対応 | OSS版と有償版 |

**静的解析ツールの注意点**

| 注意点 | 詳細 |
|--------|------|
| **過検知・未検知** | 検知ルールに依存、誤検知が多い |
| **独自ルール作成** | 既存ルールで検出できない場合は自作が必要 |
| **ビジネスロジック** | 認可制御等の仕様依存脆弱性は検出困難 |
| **DI（依存性注入）** | フレームワークによっては解析不可 |

**手動解析とツール解析の使い分け**

| 解析手法 | 得意 | 不得意 |
|---------|------|--------|
| **手動解析** | ビジネスロジック、詳細解析 | 大規模コード、解析者の知識に依存 |
| **ツール解析** | 機械的な大規模解析 | ビジネスロジック、誤検知・未検知 |

→ **相互補完的に活用**（ツール検出後に手動確認、手動発見後にルール作成）

---

### フロントエンドソースコード解析

#### 情報の抽出

| 抽出対象 | 発見可能な情報 | リスク |
|---------|--------------|--------|
| **API一覧** | 管理画面用API、デバッグAPI | 認可制御不備により攻撃可能 |
| **OpenAPIファイル** | パラメータ一覧、サンプル値、隠しAPI | 攻撃の手がかり |
| **認証プロバイダ情報** | Cognito、Auth0のクライアントID等 | プロバイダ設定不備と組み合わせた攻撃 |
| **SPAバンドルファイル** | 全画面（管理画面含む）の実装 | 管理機能の認可制御不備を発見 |

#### ロジックの解析観点

| 観点 | 脆弱性例 | 確認箇所 |
|-----|---------|---------|
| **DOM操作** | DOM Based XSS | `innerHTML`, `document.write()` への入力値 |
| **不適切なAPI呼び出し** | クライアントから決済API直接呼び出し | 決済金額改ざん、APIキー露出 |
| **クライアント暗号化** | AES暗号化、ハッシュ計算 | 暗号鍵、アルゴリズムの解析（DevToolsで回避も可） |

#### ブラウザ開発者ツールの活用

| 機能 | 用途 | 操作 |
|-----|------|------|
| **Pretty Print** | minifyコードの整形 | Chrome DevTools → Sources → `{}` ボタン |
| **ブレークポイント** | 処理の一時停止、変数の確認・書き換え | 行番号クリック → Console で変数操作 |
| **Source Map** | 元のソースコード復元 | `.map` ファイル公開時、DevTools で自動表示 |

**Source Map利用の流れ**

```
1. minifyファイルURL + ".map" にアクセス
2. Source Map取得成功 → DevTools の Sources に元コード表示
3. 変数名、コメント、構造が復元される
```

---

## クラウドサービスの調査（AWS中心）

### AWS認証情報の窃取経路

| 脆弱性 | 窃取方法 | 対象 |
|--------|---------|------|
| **SSRF** | EC2メタデータサービス（IMDS）へアクセス | IAMロールの一時認証情報 |
| **パストラバーサル** | `/proc/self/environ`, `.env` ファイル取得 | IAMユーザの長期認証情報 |
| **OSコマンドインジェクション** | ファイル探索、メタデータサービスへリクエスト | 認証情報全般 |
| **設定ファイル公開** | 公開リポジトリ、誤設定サーバ | IAMユーザの長期認証情報 |

### IAM権限列挙ツール

| ツール | 機能 | 使い分け |
|--------|------|---------|
| **Pacu** | ペネトレーションテストフレームワーク、権限総当たり、AWS CLI統合 | 包括的な調査、インタラクティブ操作 |
| **enumerate-iam** | 権限総当たり専用（Pacuと同様の実装ベース） | シンプルな権限列挙 |
| **aws_consoler** | `sts:GetFederationToken` 権限でAWSコンソールログインURL発行 | Web画面での操作が必要な場合 |

**IAM権限探索の基本フロー**

```
1. AWS認証情報取得（SSRF/パストラバーサル等）
2. Pacu/enumerate-iamで権限列挙
3. 特定された権限で攻撃展開（S3アクセス、Lambda実行等）
4. aws_consolerでコンソールログイン（可能なら）
```

---

### Amazon Cognito設定不備

#### 自己サインアップの悪用

| 設定 | リスク | 攻撃シナリオ |
|-----|--------|------------|
| **管理画面でセルフサインアップ許可** | 権限昇格 | 一般ユーザが管理画面にサインアップ→管理機能悪用 |
| **ユーザプール未検証** | 認証回避 | 意図しないユーザプールへのアクセス |

#### ユーザ属性の書き換え

| 属性タイプ | 変更可否 | 攻撃方法 |
|-----------|---------|---------|
| **標準属性** | 変更不可（`email`, `phone_number`等） | - |
| **カスタム属性** | 変更可能（例: `custom:role`） | API経由で`custom:role=admin`に書き換え→権限昇格 |

**カスタム属性悪用の流れ**

```
1. カスタム属性（例: custom:role）がロール判定に使用されていることを発見
2. Cognito APIでユーザ属性更新リクエスト送信
3. custom:role を "admin" に書き換え
4. アプリケーションが昇格後のロールで認証→管理機能にアクセス
```

#### Identity Pool経由の過剰な権限付与

| 設定 | リスク | 対策 |
|-----|--------|------|
| **未認証アクセス許可** | 誰でもAWS一時認証情報取得 | 必要最小限のアクセスのみ許可 |
| **過剰なIAMロール権限** | S3フルアクセス、DynamoDB書き込み等 | 最小権限の原則を適用 |

---

### S3バケット設定不備

| 設定不備 | 影響 | 確認方法 |
|---------|------|---------|
| **バケットリスティング許可** | バケット内オブジェクト一覧取得 | `aws s3 ls s3://bucket-name` |
| **オブジェクト公開** | 非公開ファイルの取得 | 直接URLアクセス、署名付きURL不要 |
| **バケットポリシー過剰許可** | 意図しないアクセス元からの操作 | バケットポリシーJSON確認 |

---

## 制限の回避と突破

### アクセス制御回避

#### IPアドレス偽装

| ヘッダ | 用途 | 悪用例 |
|--------|------|--------|
| `X-Forwarded-For` | プロキシ経由の元IPアドレス | 内部IPに偽装してアクセス制御を回避 |
| `X-Real-IP` | Nginx等で利用される実IPアドレス | 同上 |
| `X-Originating-IP` | 一部プロキシで利用 | 同上 |

**IPアドレス偽装の手順**

```http
GET /admin HTTP/1.1
Host: example.com
X-Forwarded-For: 127.0.0.1
X-Real-IP: 192.168.1.1

→ サーバがヘッダを信頼している場合、内部IPと判定してアクセス許可
```

#### URLパス正規化の差異

| 技法 | 例 | 効果 |
|-----|-----|------|
| **URLエンコーディング** | `/admin` → `/%61dmin` | WAF/アプリケーション間の解釈差異 |
| **二重エンコーディング** | `/admin` → `/%2561dmin` | 多段デコード時の検証回避 |
| **パスセグメント操作** | `/admin` → `/./admin`, `/public/../admin` | 正規化前後での検証回避 |
| **大文字小文字混在** | `/admin` → `/AdMiN` | 大文字小文字を区別しないサーバでの回避 |

#### CDN迂回

| 手法 | 詳細 | 対策 |
|-----|------|------|
| **オリジンサーバ直接アクセス** | DNS/IPアドレス特定後、Hostヘッダ操作 | オリジンサーバでCDN IPのみ許可 |
| **古いDNSレコード利用** | 過去のIPアドレスが残存 | 古いIPアドレスの無効化 |

---

### WAF回避

| 技法 | 具体例 | 原理 |
|-----|--------|------|
| **エンコーディング** | `<script>` → `%3Cscript%3E` | WAFがデコード前にチェック |
| **大文字小文字混在** | `<ScRiPt>` | パターンマッチのみのWAF |
| **コメント挿入（SQL）** | `SELECT/**/FROM` | 空白検出回避 |
| **コメント挿入（HTML）** | `<scr<!---->ipt>` | タグ検出回避 |
| **POSTデータサイズ操作** | 大量のダミーデータ追加 | 検査バッファ超過によるスキップ |

**WAF回避のペイロード例（SQLi）**

```sql
-- 通常
' OR '1'='1

-- エンコーディング
%27%20OR%20%271%27=%271

-- コメント挿入
'/**/OR/**/'1'='1

-- 大文字小文字混在
' Or '1'='1
```

---

### 認証回避とアカウントテイクオーバー

#### SAML攻撃

| 攻撃手法 | 前提条件 | 攻撃内容 |
|---------|---------|---------|
| **署名検証不備** | 署名検証が不十分 | アサーションの改ざん（ユーザID変更等） |
| **XML署名ラッピング** | 署名対象外の要素を処理 | 署名済みアサーションをラップして別のアサーション挿入 |
| **アサーション改ざん** | 署名検証前のアサーション処理 | ユーザ属性（権限、メールアドレス）の書き換え |

**XML署名ラッピングの概念**

```xml
<Response>
  <Assertion ID="evil"> <!-- 攻撃者が挿入 -->
    <Subject>attacker@example.com</Subject>
  </Assertion>
  <Signature> <!-- 正規のアサーションの署名 -->
    <SignedInfo>
      <Reference URI="#legitimate"/>
    </SignedInfo>
  </Signature>
  <Assertion ID="legitimate"> <!-- 正規のアサーション -->
    <Subject>victim@example.com</Subject>
  </Assertion>
</Response>

→ 署名検証は通過するが、処理時に悪意のあるアサーションが優先される
```

#### OAuth 2.0 / OIDC攻撃

| 攻撃手法 | 脆弱な実装 | 影響 |
|---------|-----------|------|
| **stateパラメータ不備** | state検証なし | CSRF経由でアカウント紐付け |
| **リダイレクトURI検証不備** | 部分一致検証、オープンリダイレクト | 認可コード窃取 |
| **トークン窃取** | HTTPでのトークン送信、リファラ漏洩 | アクセストークン/IDトークン取得 |

**OAuth攻撃の典型例**

```
1. 攻撃者が認可リクエスト開始（stateなし）
2. 被害者がそのリンクを踏んで認可
3. 認可コードが攻撃者のリダイレクトURIに送信
4. 攻撃者がアクセストークン取得→被害者アカウント乗っ取り
```

---

### 暗号による防御機構の突破

#### JWT攻撃

| 攻撃手法 | 原理 | 対策 |
|---------|------|------|
| **alg=none** | 署名アルゴリズムを`none`に変更 | `alg=none`を拒否 |
| **公開鍵→共通鍵** | RS256（公開鍵）をHS256（共通鍵）に変更し、公開鍵を共通鍵として利用 | アルゴリズム固定検証 |
| **弱い共通鍵総当たり** | 短い共通鍵をブルートフォース | 十分な鍵長（256bit以上） |
| **JWKインジェクション** | JWTヘッダの`jwk`に攻撃者の公開鍵を埋め込み | `jwk`ヘッダを無視、事前登録鍵のみ利用 |
| **JKUスプーフィング** | `jku`で攻撃者サーバの鍵セットを指定 | `jku`検証、ホワイトリスト |

**JWT攻撃の例（alg=none）**

```json
// 元のJWT
{
  "alg": "HS256",
  "typ": "JWT"
}
{
  "sub": "user123",
  "role": "user"
}

// 攻撃
{
  "alg": "none",
  "typ": "JWT"
}
{
  "sub": "user123",
  "role": "admin"  // ロールを変更
}
// 署名なし

→ サーバが alg=none を受理すれば、署名検証なしで改ざん成功
```

#### ブロック暗号攻撃

| 攻撃手法 | 対象モード | 原理 | 対策 |
|---------|-----------|------|------|
| **ECBモード悪用** | ECB | 同一平文→同一暗号文 | CBC、GCM等の利用 |
| **CBCパディングオラクル** | CBC | パディングエラーメッセージで平文推測 | エラーメッセージの統一 |
| **CBCビットフリッピング** | CBC | 前ブロックのビット反転で次ブロックの平文を改ざん | CBC-MAC、認証付き暗号（GCM） |

**CBCビットフリッピングの原理**

```
CBC復号: C[i] を復号 → P[i] = D(C[i]) XOR C[i-1]

攻撃者がC[i-1]の特定ビットを反転
→ P[i]の対応ビットが反転
→ データ改ざん（例: "user" → "admin"）
```

#### 暗号鍵の使い回し問題

| リスク | 例 | 対策 |
|--------|-----|------|
| **異なるコンテキストでの鍵共有** | 署名と暗号化に同じ鍵 | 用途ごとに鍵を分離 |
| **JWT署名鍵の流用** | 同じ鍵でセッショントークン暗号化 | 鍵のスコープを明確化 |
| **複数サービスでの共通鍵** | マイクロサービス間で同じ秘密鍵 | サービスごとに独立した鍵 |

---

## 判断基準テーブル（総合）

### 調査手法の選択

| 状況 | 推奨手法 | 理由 |
|-----|---------|------|
| ソースコード入手可能 | Source/Sinkからの解析 + 静的解析ツール | 効率的な脆弱性検出 |
| 大規模コードベース | 静的解析ツール優先 | 手動解析は時間がかかる |
| ビジネスロジック依存 | 手動解析 | ツールでは検出困難 |
| フロントエンドのみアクセス可能 | DevTools + Source Map | バンドルコード解析 |
| AWS認証情報取得 | Pacu/enumerate-iam | 権限の網羅的探索 |
| クラウド設定調査 | Cognito/S3設定確認 | 設定不備の発見 |
| アクセス制御回避 | IPヘッダ偽装、パス正規化 | 制限の迂回 |
| 認証機構突破 | SAML/OAuth/JWT攻撃 | 認証・認可の回避 |

### 脆弱性別の攻撃優先度

| 脆弱性 | 優先度 | 影響 | 検出難易度 |
|--------|--------|------|-----------|
| AWS認証情報露出 | 🔴 最高 | AWSアカウント侵害 | 低（SSRF/パストラバーサル） |
| JWT alg=none | 🔴 最高 | 認証回避 | 低 |
| S3バケット公開 | 🟠 高 | 機密情報漏洩 | 低 |
| Cognito設定不備 | 🟠 高 | 権限昇格 | 中 |
| SAML署名検証不備 | 🟠 高 | アカウント乗っ取り | 高 |
| WAF回避 | 🟡 中 | 他の攻撃との組み合わせ | 中 |
| CBCビットフリッピング | 🟡 中 | データ改ざん | 高 |

---

## 防御側への示唆

### コード解析の組み込み

| フェーズ | 対策 | ツール例 |
|---------|------|---------|
| **開発時** | IDEでの静的解析、pre-commitフック | SonarLint、CodeQL |
| **CI/CD** | 自動スキャン、脆弱性検出時のビルド停止 | Semgrep、SonarQube |
| **デプロイ前** | ペネトレーションテスト、手動レビュー | 専門家によるレビュー |

### クラウドセキュリティのベストプラクティス

| 対策 | 具体例 |
|-----|--------|
| **最小権限の原則** | IAMポリシーは必要最小限、定期的な権限レビュー |
| **認証情報の保護** | 環境変数、AWS Secrets Manager、IMDSv2の利用 |
| **Cognito設定** | セルフサインアップ制限、カスタム属性の権限判定回避 |
| **S3バケット** | パブリックアクセスブロック、バケットポリシーの最小化 |
| **監査ログ** | CloudTrail有効化、異常なAPI呼び出しの検知 |

### 認証・暗号化の実装

| 対策 | 具体例 |
|-----|--------|
| **JWT** | `alg=none`拒否、アルゴリズム固定検証、十分な鍵長 |
| **SAML** | 署名検証の厳格化、XML署名ラッピング対策 |
| **OAuth/OIDC** | state検証、リダイレクトURI厳格検証、HTTPS必須 |
| **ブロック暗号** | GCM等の認証付き暗号、ECB禁止、パディングオラクル対策 |
| **鍵管理** | 用途ごとの鍵分離、定期的なローテーション |

---

## まとめ

高度な調査手法は、ブラックボックステストでは発見困難な脆弱性を検出するために不可欠。ソースコード解析、クラウド設定調査、制限回避技術を組み合わせることで、より深い侵害シナリオを実証できる。

**重要な考え方**

1. **効率性**: 調査対象に応じて手法を使い分ける（Source/Sink、ツール/手動）
2. **深さ**: 表層的な脆弱性だけでなく、設計・実装の深い問題を追求
3. **組み合わせ**: 単一の脆弱性ではなく、複数の弱点を連鎖させる
4. **防御視点**: 攻撃手法を理解することで、効果的な対策を設計

これらの技術は防御側にとっても重要な知識であり、システムの設計・実装・運用のあらゆるフェーズで活用すべきである。
