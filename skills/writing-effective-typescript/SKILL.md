---
name: writing-effective-typescript
description: TypeScript best practice decision criteria covering type system design and inference patterns. MUST load when writing TypeScript code detected by tsconfig.json. Provides 83 guidance items on why/when to apply patterns. For language reference, use mastering-typescript instead.
---

# TypeScript実装判断基準ガイド

## 概要

このスキルは、TypeScript実装における**判断基準と意思決定ガイド**を提供します。「どのパターンを使うべきか」「なぜそのアプローチが推奨されるのか」という判断に焦点を当てた83項目の実践的知識です。

**ポジショニング:**
- **判断基準ガイド**: 実装の「なぜ」「いつ」に答える
- 型システムの設計判断、推論パターン、ジェネリクス、健全性のトレードオフを扱う
- コード例と実用的な意思決定フレームワークを提供

## 使用タイミング

以下の場面でこのスキルを参照してください:

- **型設計の判断時**: `interface` vs `type`、`readonly`の使い方、型の統一vs差異のモデリング
- **推論の活用時**: 型アノテーションを付けるべきか推論に任せるか、型の拡大制御
- **ジェネリクス実装時**: 型パラメーターの数・制約、条件型の使い分け
- **実行時と型の境界**: タグ付きユニオン、ブランド型、型の再構築
- **リファクタリング時**: 型を変更した際の影響範囲、型カバレッジ
- **移行・モダン化時**: JavaScriptからの移行戦略、コンパイラーオプション選択

## 関連スキルとの使い分け

| スキル | 焦点 | 使い分け |
|--------|------|----------|
| **writing-effective-typescript** (本スキル) | 判断基準・ベストプラクティス | 「なぜこの型設計か」「いつこのパターンか」を知りたい時 |
| **mastering-typescript** | 言語機能リファレンス | 「この構文は何か」「どう書くか」を知りたい時 |
| **enforcing-type-safety** | 厳格な型安全ルール | 「any禁止」「型ガード必須」などの規約を適用したい時 |

**選択の指針:**
- **実装前の設計**: 本スキルで判断基準を確認
- **実装中の構文**: mastering-typescriptで構文を確認
- **レビュー・品質**: enforcing-type-safetyで規約準拠を確認

## 章構成とナビゲーション

### [CH01: 基礎と型システム (項目1-17)](CH01-FUNDAMENTALS.md)
**カバー内容**: TypeScript/JavaScript関係、コンパイラーオプション、構造的型付け、型空間vs値空間、型アノテーション、`interface` vs `type`、`readonly`、型演算
**最重要判断**: `strict`の有効化、型アノテーション vs 推論の使い分け、`interface` vs `type`選択

### [CH03: 型推論と制御フロー (項目18-28)](CH03-TYPE-INFERENCE.md)
**カバー内容**: 推論可能な型、異なる型には異なる変数、型の拡大、型の絞り込み、エイリアス、文脈、進化する型
**最重要判断**: 型アノテーションを省略すべき場面、型の絞り込み戦略、`async`関数の活用

### [CH04: 型設計 (項目29-42)](CH04-TYPE-DESIGN.md)
**カバー内容**: 有効な状態のみ表現、寛容な入力・厳格な出力、null管理、ユニオン設計、精度の高い型、ドメイン言語
**最重要判断**: 不正な状態を型で防ぐ、型の精度 vs 複雑さのトレードオフ、命名規則

### [CH05: 不健全性とany型 (項目43-49)](CH05-UNSOUNDNESS-AND-ANY.md)
**カバー内容**: anyの最小スコープ化、具体的なany形式、型アサーション隠蔽、unknown、モンキーパッチ、健全性の罠、型カバレッジ
**最重要判断**: anyを使う場合の最小スコープ化、unknown優先、不健全性パターンの認識

### [CH06: ジェネリックと型レベルプログラミング (項目50-58)](CH06-GENERICS.md)
**カバー内容**: ジェネリック型、不必要な型パラメーター、条件型、分配制御、テンプレートリテラル型、型テスト、型の表示、再帰型、コード生成
**最重要判断**: 型パラメーター数の決定、条件型 vs オーバーロード、型の複雑さの限界

### [CH07: TypeScriptのレシピ (項目59-64)](CH07-RECIPES.md)
**カバー内容**: never型による網羅性チェック、オブジェクト反復処理、Record型、レストパラメーター、排他的論理和、ブランド型
**最重要判断**: 網羅性チェック、型同期、排他的論理和のモデリング

### [CH08: 型宣言と@types (項目65-71)](CH08-TYPE-DECLARATIONS.md)
**カバー内容**: devDependencies、3つのバージョン、型のエクスポート、TSDoc、this型、依存の断ち切り、モジュールオーグメンテーション
**最重要判断**: 型のバンドル vs DefinitelyTyped、型の推移的依存回避

### [CH09: TypeScript実践のコツ (項目72-78)](CH09-PRACTICAL-TIPS.md)
**カバー内容**: ECMAScript機能優先、ソースマップ、実行時型の再構築、DOM型階層、環境モデリング、型チェックとテスト、コンパイラーパフォーマンス
**最重要判断**: 独自機能回避、実行時型システム選択、型チェック vs テスト範囲

### [CH10: モダン化と移行 (項目79-84)](CH10-MIGRATION.md)
**カバー内容**: モダンJavaScript、@ts-check、allowJs、依存関係グラフの下から上へ、noImplicitAny有効化、リンターによる規約適用
**最重要判断**: 移行の開始点、段階的型付け戦略、完了基準

## 最重要判断基準 TOP10

全83項目から抽出した、最も重要な10の判断基準:

### 1. **`noImplicitAny`と`strictNullChecks`は必須** (項目2)
- **判断**: 新規プロジェクトでは最初から有効化。移行中でも最優先で有効化を目指す
- **理由**: これらなしではTypeScriptの型安全性の大部分が失われる
- **例外**: JS→TS移行の初期段階のみ一時的にオフ

### 2. **型アノテーション vs 推論の使い分け** (項目18)
- **判断**: 関数シグネチャには型アノテーション、ローカル変数は推論に任せる
- **理由**: 関数は契約、ローカルは実装詳細
- **追加基準**: オブジェクトリテラルには型アノテーション(余剰プロパティチェック有効化)

### 3. **`interface` vs `type`の選択** (項目13)
- **判断**: オブジェクト型には`interface`優先、ユニオン・条件型には`type`必須
- **理由**: `interface`は拡張に最適化、マージ可能、エラーメッセージ明確
- **例外**: 既存コードベースのスタイルに従う

### 4. **有効な状態のみを表現する型** (項目29)
- **判断**: 不正な状態を型で表現不可能にする設計を優先
- **理由**: 実行時チェックより型による防止が確実
- **トレードオフ**: 型が複雑になっても長期的には価値がある

### 5. **anyの最小スコープ化** (項目43, 44)
- **判断**: anyが必要な場合は、関数全体でなく個別プロパティに限定
- **理由**: any汚染の拡散を防ぐ
- **代替**: `any[]`、`{[key: string]: any}`など具体的な形式を優先

### 6. **`unknown` over `any`** (項目46)
- **判断**: 型が不明な値には`any`でなく`unknown`を使用
- **理由**: `unknown`は型の絞り込みを強制し型安全性を保つ
- **使い分け**: 絞り込み可能→`unknown`、本当に何でも→`any`(最終手段)

### 7. **構造的型付けの理解と活用** (項目4)
- **判断**: テストでは構造的型付けを活用、本番ではクラスの不用意な代入に注意
- **理由**: モックが簡潔になる一方、型が「開いている」ことを忘れない
- **注意**: オブジェクトは宣言以外のプロパティを持ちうる

### 8. **型の絞り込み戦略** (項目22)
- **判断**: タグ付きユニオン > プロパティチェック > 型アサーション
- **理由**: 型安全性と可読性のバランス
- **実装**: 判別子フィールドを明示的に設計

### 9. **ジェネリック型パラメーターの制約** (項目51)
- **判断**: 型パラメーターは2回以上登場しなければ不要
- **理由**: 単発の型パラメーターは推論を妨げ複雑化するだけ
- **リファクタリング**: 不要な`<T>`は`unknown`に置換

### 10. **型チェック vs ユニットテスト** (項目77)
- **判断**: 型チェックは構造の正しさ、テストは振る舞いの正しさ
- **理由**: 補完的な技術であり、両方必要
- **実装**: 型エラーになるケースのテストは書かない

## AskUserQuestion使用指示

以下の判断分岐でユーザーに確認してください:

### 型設計の選択肢が複数ある場合

```python
AskUserQuestion(
    questions=[{
        "question": "型設計のアプローチを選択してください",
        "header": "型設計選択",
        "options": [
            {
                "label": "タグ付きユニオン",
                "description": "判別子フィールドで型を区別(推奨: 型の絞り込みが明確)"
            },
            {
                "label": "プロパティの有無チェック",
                "description": "in演算子でプロパティ存在を確認(推奨: 既存型に手を入れられない場合)"
            },
            {
                "label": "ブランド型",
                "description": "名前的型付けで厳密に区別(推奨: プリミティブ型を区別したい場合)"
            }
        ],
        "multiSelect": False
    }]
)
```

### anyの使用が避けられない場合

```python
AskUserQuestion(
    questions=[{
        "question": "anyの使用について確認します",
        "header": "any使用確認",
        "options": [
            {
                "label": "unknownに変更可能",
                "description": "型の絞り込みを追加してunknownに変更(推奨)"
            },
            {
                "label": "具体的なany形式",
                "description": "any[]、{[key: string]: any}など範囲を限定(次善)"
            },
            {
                "label": "コメント付きany",
                "description": "なぜanyが必要かコメントを付けて使用(最終手段)"
            }
        ],
        "multiSelect": False
    }]
)
```

### 移行戦略の選択

```python
AskUserQuestion(
    questions=[{
        "question": "TypeScript移行の開始点を選択してください",
        "header": "移行戦略",
        "options": [
            {
                "label": "@ts-checkから開始",
                "description": "JSファイルのまま型チェック導入(推奨: 段階的移行)"
            },
            {
                "label": "allowJsで共存",
                "description": "TS/JS混在環境を構築(推奨: 大規模コードベース)"
            },
            {
                "label": "全面書き換え",
                "description": "全ファイルを一気にTSに変換(非推奨: リスク高)"
            }
        ],
        "multiSelect": False
    }]
)
```

## クイックリファレンス: よくある判断シーン

| シーン | 判断基準 | 該当項目 |
|--------|---------|---------|
| 型アノテーション付けるか | 関数シグネチャ→付ける、ローカル変数→推論 | 項目18 |
| interfaceかtypeか | オブジェクト→interface、ユニオン→type | 項目13 |
| readonlyを付けるか | パラメーターを変更しない→付ける | 項目14 |
| anyを使うべきか | 最終手段。まずunknown検討 | 項目43, 46 |
| 型アサーション使うか | TypeScriptが知らない情報がある場合のみ | 項目9 |
| オプションプロパティか | 本当に必須でないか再検討。可能なら必須化 | 項目37 |
| ユニオンか分岐型か | インターフェイスのユニオン優先 | 項目34 |
| ジェネリック必要か | 型が2回以上登場するか確認 | 項目51 |
| テストか型チェックか | 両方必要。役割を分ける | 項目77 |

## 実装フロー推奨手順

1. **要件確認**: 本スキルで判断基準を確認
2. **構文確認**: mastering-typescriptで実装方法を確認
3. **実装**: 判断基準に基づいて実装
4. **品質確認**: enforcing-type-safetyで規約準拠を確認
5. **レビュー**: 判断の妥当性を本スキルで再確認

## 注意事項

- **判断基準は文脈依存**: プロジェクトの規模・チーム・要件で最適解は異なる
- **トレードオフの認識**: 型安全性 vs 開発速度、精度 vs 複雑さを意識
- **段階的適用**: すべてを一度に適用せず、優先順位を付けて導入
