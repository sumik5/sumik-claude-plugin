# API仕様ファースト開発 - 方法論ガイド

## 1. 優れたAPI仕様の書き方

### API仕様の3要件

保守性を高め、サービスの品質を保ちながら開発スピードを向上させるためには、以下の3点が重要:

| 要件 | 説明 |
|------|------|
| **理解が容易** | 実装コードを読まなくても機能・動作・エラーが理解できる |
| **変更が容易** | API仕様の修正が容易に実装へ反映でき、変更結果を自動テストで確認できる |
| **テストが容易** | 自動テストが整備されており、ローカルPC上で容易に実行できる |

### よくある問題点

| 問題 | 結果 |
|------|------|
| API仕様が記述されていない | 実装コードを読まないと正確な仕様がわからない |
| エラーの説明が書かれていない | どのエラーが返るかを開発者に都度問い合わせる必要がある |
| API仕様に基づく自動テストがない | 手動テストに依存し、リグレッションが検出できない |

### API仕様に書くべきこと

**サービス概要**
- 提供するAPIが全体としてどのような機能を提供するかの説明
- 全エンドポイントに共通な事柄（認証方式など）
- サービス理解に必要な用語の定義

**個々のエンドポイントの説明**
- 提供する機能の正常な動作の明確な定義
- 引数・戻り値の説明
- 取り得る正常な値の範囲
- 他エンドポイントとの関連性（呼び出し順序の制約など）

**エラーの説明**（必須）
- パラメータの不正値（空文字・長さ制限・数値範囲など）
- 誤った順序での呼び出し
- 認証・認可のエラー
- その他の発生し得るエラー（内部エラーは除く）

> **重要**: エラーを仕様に書くことは実装での防御的プログラミングに直結する。エラー仕様なしでは、E2Eテストを書くことができない（詳細は付録Cの防御的プログラミング参照）。

---

## 2. API仕様ファースト開発サイクル（核心）

### 新規開発の順序

```
1. API仕様の記述（PRとして独立させてレビュー）
   ↓
2. E2Eテストフレームワークの検討と実装
   ↓
3. テストコード作成（繰り返し）
   ↓
4. 機能実装（繰り返し）
   ↓
5. リファクタリングとカバレッジ確認
   ↓
6. PRレビュー
```

### テストコード作成と機能実装の繰り返しサイクル

**エラーケースを先に実装する**

- [ ] エラーケースのテストコードを書く（失敗することを確認）
- [ ] エラーケースの実装を書く（正常ケース部分は `panic("Not Implemented Yet")` のまま）
- [ ] テストが合格することを確認
- [ ] 正常ケースのテストコードを書く（失敗することを確認）
- [ ] 正常ケースの実装を書く
- [ ] テストが合格することを確認

> **なぜエラーを先に?** エラーケース実装→正常ケース実装の順序により、コードの前半がバリデーション、後半が正常処理という自然な構造になり、可読性が向上する。

### 不具合修正の順序

```
1. 不具合原因の調査
   ↓
2. 再現テストの作成（この時点でテストは失敗する）
   ↓
3. 実装の修正
   ↓
4. 再現テストが合格することを確認
   ↓
5. 全E2Eテストを実行して副作用がないことを確認
   ↓
6. リファクタリングとカバレッジ確認
   ↓
7. API仕様の更新（必要な場合）
```

> **重要**: 再現テストを書かずに修正してしまうと、テスト不足の状態が改善されない。修正前に必ず再現テストを書く習慣を持つこと。

### PRレビューのチェック観点

レビュアーはAPI仕様を確認しながらE2Eテストをレビューする:

- [ ] API仕様に記述されているエラーケースが網羅されているか
- [ ] API仕様に記述されている正常ケースが網羅されているか
- [ ] テストコードがAPI仕様に記述されていない事柄をテストしていないか
- [ ] E2Eテスト実行後のカバレッジを確認し、実行されていないコードがないか

### E2Eテストの長期的利点

| 利点 | 説明 |
|------|------|
| リファクタリングの自由 | 内部構造をどれだけ変えても、E2Eテストで正しい動作を確認できる |
| 言語移行 | API仕様を変えずに実装言語を変更する場合、E2Eテストで従来動作を担保できる |
| 環境切り替え | フレームワークを工夫すれば、ローカル→クラウド環境向けに切り替えてそのまま実行できる |

---

## 3. E2Eテストフレームワークのアーキテクチャ

### 基本原則

1. **本番同一バイナリの使用**: テストのためのコードをサービス本体に挿入しない
2. **カバレッジの取得**: テスト実行後に行単位でどのコードが実行されたかを確認できる

### 2プロセスモデル（マイクロサービス構成）

```
┌─────────────────────┐    ┌──────────────────────────────┐
│  Target Service     │    │  Test Suite Process          │
│  (本番バイナリ)      │◄──▶│  ┌──────────────────────┐   │
│                     │    │  │ テストコード           │   │
│  → 依存サービスへの  │    │  ├──────────────────────┤   │
│    呼び出しを        │    │  │ フェイクサービス群     │   │
│    Test Suiteへ      │    │  │ (スタブ/モック)       │   │
│    リダイレクト      │    │  └──────────────────────┘   │
└─────────────────────┘    └──────────────────────────────┘
```

### プロセス間シーケンス

```
Test Suite                    Target Service
    │                              │
    │──フェイクサービス起動──────────│
    │──Target Service起動───────────►
    │                              │ (初期化処理)
    │◄──「サービスReady」通知────────│
    │                              │
    │──テスト実行────────────────────►
    │◄──レスポンス──────────────────│
    │                              │
    │──「サービス終了」指示──────────►
    │                              │ (カバレッジ保存)
    │◄──「サービス終了」通知────────│
    │ (終了)                       │(終了)
```

### フェイクサービスの設計

マイクロサービス構成での依存サービスに対してはフェイクサービスを作成する。フェイクサービスの動作は**単純**にすること:

- テストコードから指示されたレスポンス/エラーを返す
- モックとして設定された場合はリクエストパラメータを保存する
- 設定がなければ panic する（テストの意図外呼び出しを即座に検出）

**スタブとモックの使い分け**:

| パターン | 準備 | 検証 |
|---------|------|------|
| レスポンス確認（スタブ） | 返すレスポンス/エラーを設定 | 返ってきたレスポンスを検証 |
| 呼び出し確認（モック） | 返すレスポンス + パラメータ保存を設定 | レスポンス + 渡されたパラメータを検証 |

### 依存サービスが外部サービスの場合

優先順位:
1. **Dockerシミュレータ**: クラウドプロバイダ提供のシミュレータをローカルで起動
2. **開発用本物環境**: シミュレータが使えない場合
3. **フェイクサーバを自作**: Test Suiteプロセス内で起動する（必要なエンドポイントのみ実装）

### 骨格コード（言語非依存）

**Test Suiteプロセスのエントリポイント (`TestMain`相当)**:
```
function TestMain(m):
    // フェイクサービスを同プロセス内でサーバとして起動（ポート割当）
    // テスト対象サービスの依存先接続先を、このプロセスのポートへ向ける環境変数を設定
    // テスト対象サービスを別プロセスとして起動
    // 「サービスReady」通知を待つ

    m.Run()  // テスト実行

    // 「サービス終了」指示を送信
    // 「サービス終了」通知を待つ（カバレッジ保存後）
```

**テストコードの骨格**:
```
// エラーケース（個別テスト関数として分ける）
function TestEndpoint_ErrorType():
    // フェイクサービスの設定（不要な場合が多い）
    // エンドポイントを呼び出す
    // 期待するエラーコードが返ることを検証

// 正常ケース
function TestEndpoint_Normal():
    // フェイクサービスのレスポンス設定
    // エンドポイントを呼び出す
    // レスポンスを検証
```

> **注意**: `DeadlineExceeded`、`Canceled`、`Aborted` などのエラーは、フェイクサービスを使えば容易にテストできる。本物のサービスやシミュレータではこれらのテストは困難。

---

## 4. API仕様の技術的負債の返済

### 技術的負債の定義

以下の状態を「API仕様の技術的負債」と呼ぶ:
- [ ] E2Eテストフレームワークが構築されていない
- [ ] API仕様が記述されていない
- [ ] API仕様に基づく自動テストが存在しない

### 返済の第一歩: E2Eテストフレームワークの構築

負債を抱えているサービスでは、まずE2Eテストフレームワークを構築する。既存のサービスであっても、新規サービスと同様のフレームワークを使えるように設計すること。

### 3つのケースでの段階的返済

実際のサービス開発では、すべての作業を止めて返済だけに専念することは困難。以下の3タイミングで着実に返済する:

**ケース1: 既存エンドポイントを修正するとき**

```
Step 1: 既存API仕様の更新（なければゼロから記述、実装コードを調べながら）
         ↓ フロントエンド/バックエンドチームにレビュー依頼
Step 2: 既存API仕様のテストコード作成と実行
         ↓ テストが合格しない場合はデバッグして実装を修正
Step 3: 新たな修正のためのAPI仕様の再修正（本来行いたい修正）
         ↓
Step 4: 新たな修正に対するテストコード作成（合格しないことを確認）
         ↓
Step 5: 新たな修正の実装
         ↓
Step 6: リファクタリングとカバレッジ確認
```

> **⚠️ 注意**: ステップ1〜2に余裕がなくても、ステップ3以降は必ず行うこと。省略すると返済の習慣が身につかない。

**ケース2: 新たなエンドポイントを追加するとき**

Section 2の「新規開発の順序」に従う。「新たな負債を作り出さない」こと自体が返済の一部。

**ケース3: 既存エンドポイントの不具合を修正するとき**

Section 2の「不具合修正の順序」に従いつつ、同時にStep1〜2も実施する。

### E2EテストによるリファクタリングへのActive活用

E2Eテストが整備されると、大規模な設計変更（パッケージ再編成など）も安全に行える。設計変更はAPI仕様の変更ではないため、E2Eテストを修正する必要がなく、テストで正しい動作を確認しながらリファクタリングできる。

### API仕様ファースト開発が定着した組織の特徴

- フロントエンド開発者がバックエンドAPI仕様を確認できる（口頭確認不要）
- バックエンド開発者が自分の担当エンドポイントの詳細を忘れても仕様を参照できる
- 新規参加者が実装コードを読まずにエンドポイントの仕様を理解できる
- API仕様のないPRは却下される文化になる
- E2Eテストのないエンドポイント実装PRは承認されない文化になる

---

## 5. 防御的プログラミングとAPI仕様

### 防御的プログラミングとは

公開APIの呼び出しで渡されるパラメータの値が正しい範囲かを検査し、問題を即座に検出するプログラミング手法。具体的には:

- 関数・メソッド・エンドポイントの**パラメータ検証**を実装する
- 設計上到達し得ない状態に対して**防御的なアサーション**を書く
- 不正な値を検出した時点で**即座にエラーを返す**（処理を続行しない）

### 防御的プログラミングの欠如がもたらす工数増大

```
不正な値での呼び出し
   ↓ 検査なしで処理を続行
   ↓
かなり先の処理で不具合発生
   ↓
原因調査に長時間を要する（不正な呼び出しと発生箇所が離れているため）
```

防御的プログラミングを行っていれば、不正な値を検出した時点で即座にエラーを返し、原因の調査が短時間で済む。

### API仕様との関係

防御的プログラミングとAPI仕様策定は本質的に同じ原則:

| 一般的プログラミング | API仕様策定 |
|-------------------|------------|
| パラメータの前提条件を文書化する | リクエストの入力条件をエラー仕様として記述する |
| 無効なデータの動作を明確に定義する | 不正なリクエストに対するエラーを仕様化する |
| すべての前提条件をコードに反映する | すべての前提条件をAPI仕様に反映する |

**API仕様にエラーを書く → E2Eテストでエラー検証を書く → 実装で防御的プログラミングが強制される**

この連鎖により、API仕様・テスト・実装が整合した堅牢なバックエンドサービスになる。

### よくある問題パターン

| 問題 | 原因 | 解決 |
|------|------|------|
| `InternalServerError` が返る | パラメータ検証なしに処理が進んだ | 不正な入力を早期に検出してクライアントエラーを返す |
| フロントエンドがバリデーションするから不要 | 悪意のあるクライアントを想定していない | バックエンドでも必ずパラメータ検証を実装する |
| テストで再現困難 | 防御的検査の欠如 | E2Eテストフレームワークのフェイクサービスで容易に再現できる |
