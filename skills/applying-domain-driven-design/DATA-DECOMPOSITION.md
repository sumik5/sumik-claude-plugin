# 業務データの分解 / Data Decomposition

本ファイルでは、モノリシックなデータベースを境界づけられたコンテキストに基づいて分解する方法を解説する。

---

## 1. データ分解の推進要因 / Data Decomposition Drivers

モノリシックなデータベースを分解すべきかを判断するために、**データ分解要因**と**データ統合要因**のバランスを分析する。

### 1.1 主なデータ分解要因

| 要因 | 説明 | 影響 |
|------|------|------|
| **変更制御** | テーブルスキーマの破壊的変更が複数サービスに影響 | 変更調整の困難さ、本番障害リスク |
| **コネクション管理** | サービス増加によるデータベースコネクション枯渇 | タイムアウト、サーキットブレーカー作動 |
| **スケーラビリティ** | サービスのスケールアウトに伴うDB負荷増大 | パフォーマンス低下、容量不足 |
| **耐障害性** | 単一データベースが単一障害点（SPOF）となる | システム全体の停止 |
| **Architecture Quantum** | 共有DBが複数サービスを単一量子に結合 | 独立デプロイ不可、運用特性の制約 |
| **ポリグロットDB** | ユースケースごとに最適なDB種別の選択不可 | パフォーマンス非効率 |

---

### 1.2 変更制御の課題

**破壊的変更の例**:
- テーブル・カラムの削除
- テーブル名・カラム名の変更
- カラムの型変更

**問題点**:
```
破壊的変更 → 影響を受ける全サービスの更新・テスト・デプロイが必要
            → サービス見落としによる本番障害
```

**解決策: Bounded Contextによるデータ境界**

```
┌─────────────────────┐
│ Bounded Context A   │
│  ┌──────┐           │
│  │SvcA  │───┐       │
│  └──────┘   │       │
│             ↓       │
│         ┌──────┐    │
│         │DB-A  │    │  変更の影響がContext内に隔離される
│         └──────┘    │
└─────────────────────┘

┌─────────────────────┐
│ Bounded Context B   │
│  ┌──────┐           │
│  │SvcB  │───┐       │
│  └──────┘   │       │
│             ↓       │
│         ┌──────┐    │
│         │DB-B  │    │
│         └──────┘    │
└─────────────────────┘
```

**データベース抽象化の重要性**:

サービスCがサービスDのデータを必要とする場合、データベースDに直接アクセスせず、サービスD経由でデータを取得する。これにより、データベースDのスキーマ変更がサービスCに影響しない。

```
サービスC ──REST/Message──> サービスD ──直接アクセス──> データベースD

JSONコントラクト（抽象化層）:
{
  "cust_id": "string",
  "item_id": "string",
  "qty": number,
  "exp_dt": number  // エポック時間
}

データベーススキーマ（内部実装）:
CUSTOMER_ID VARCHAR(10)
ITEM_ID VARCHAR(20)
QUANTITY INT
EXPIRATION_DT DATE
```

データベースのカラム名や型が変わっても、JSONコントラクトは変更不要（またはマッピング層で吸収）。

---

### 1.3 コネクション管理の課題

**問題の例**:

```
モノリシックアプリケーション: 200コネクション
↓ マイクロサービス化
50サービス × 各10コネクション × 最小2インスタンス = 1,000コネクション

さらにスケールアウト:
25サービス × 各10コネクション × 5インスタンス = 1,250コネクション
25サービス × 各10コネクション × 2インスタンス = 500コネクション
合計: 1,750コネクション
```

**コネクション統制戦略**:

1. **均等配分**: 初期段階で全サービスに同数割り当て
2. **可変分散**: サービスごとの実負荷に応じて調整

| サービス | 割当数 | 最大使用数 | インスタンス数 | 合計使用数 |
|---------|-------|----------|--------------|----------|
| A | 8 | 5 | 2 | 10 |
| B | 29 | 27 | 3 | 81 |
| C | 20 | 15 | 3 | 45 |
| D | 25 | 25 | 2 | 50 |
| E | 18 | 14 | 4 | 56 |
| **計** | **100** | **86** | **14** | **242** |

**適応度関数**: メトリクス収集により各サービスのコネクション使用状況を監視し、動的に再配分。

---

### 1.4 Architecture Quantumとの関係

**単一DBを共有 → 単一Architecture Quantum**:
```
すべてのサービスが静的に結合され、独立したデプロイ・スケール・障害対応が不可能
```

**DBを分離 → 複数のArchitecture Quantum**:
```
各サービスが独立し、運用特性（スケーラビリティ、耐障害性、パフォーマンス）を個別に最適化可能
```

---

## 2. モノリシックデータの分解手順 / 5-Step Process

### 2.1 データドメインの概念

**データドメイン**: 特定のドメインに関連し、限られた範囲の機能で頻繁に使用される、結合されたデータベースアーティファクト（テーブル、ビュー、外部キー、トリガー等）の集合。

**サッカーボールの比喩**:
```
┌──────────┐
│ドメインA  │  白い六角形 = データドメイン
│ Table1   │  六角形内の依存関係 = 維持可能
│ Table2   │  六角形間の依存関係 = 削除必要
│ View1    │
└──────────┘
     ↕ (削除必要な依存関係)
┌──────────┐
│ドメインB  │
│ Table3   │
│ Table4   │
└──────────┘
```

---

### 2.2 ステップ1: データベースを分析し、データドメインを特定

**目的**: 関連するテーブルをグループ化し、データドメイン候補を特定。

**例: Sysops Squadのデータドメイン分類**:

| テーブル | データドメイン |
|---------|--------------|
| customer, customer_notification | 顧客 |
| survey, question, survey_question, survey_administered, survey_response | アンケート |
| billing, contract, payment_method, payment | 支払い |
| sysops_user, profile, expert_profile, expertise, location | プロフィール |
| article, tag, keyword, article_tag, article_keyword | ナレッジベース |
| ticket, ticket_type, ticket_history | チケット |

---

### 2.3 ステップ2: テーブルをデータドメインに割り当てる

**目的**: 境界づけられたコンテキストに沿ってテーブルをスキーマに割り当てる。

**スキーマの定義**: データベースサーバーの論理的構成要素。テーブル、ビュー、関数などを含む。

**移行方法**:

```sql
-- テーブルをスキーマに移動
ALTER SCHEMA payment TRANSFER sysops.billing;

-- シノニムの作成（一時的な抽象化）
CREATE SYNONYM ticketing.sysops_user
FOR profile.sysops_user;
```

**注意**: シノニムはスキーマ横断アクセスを容易にするが、最終的には削除してサービスレベルでの通信に移行する必要がある。

---

### 2.4 ステップ3: データベースコネクションをデータドメインごとに分離

**目的**: 各サービスが特定のスキーマにのみ接続し、スキーマ横断アクセスを排除。

**移行前**:
```
サービスC ──┐
            ├──> 単一DB (全スキーマにアクセス可能)
サービスD ──┘
```

**移行後**:
```
サービスC ──> スキーマC (チケット) ──┐
                                    ├──> 単一DBサーバー
サービスD ──> スキーマD (支払い) ────┘

サービスCが支払いデータを必要とする場合:
サービスC ──REST/Message──> サービスD ──> スキーマD
```

**影響**:
- すべてのスキーマ横断SQLクエリをサービス間通信に変換
- ストアドプロシージャ内のドメイン横断ロジックをサービス層に移動
- シノニムをすべて削除

**メリット**:
- サービスごとにデータ所有権が確立
- 他ドメインの変更を気にせずスキーマ変更可能

**デメリット**:
- 大量データアクセス時のパフォーマンス低下
- データベース参照整合性の喪失（アプリケーション側で管理）

---

### 2.5 ステップ4: スキーマを別個のデータベースサーバーに移動

**目的**: 単一のArchitecture Quantumを複数に分割し、スケーラビリティと耐障害性を向上。

**移行方法の選択**:

| 方法 | 手順 | メリット | デメリット |
|------|------|---------|----------|
| **バックアップ&リストア** | 1. スキーマをバックアップ<br>2. 新DBサーバーにリストア<br>3. サービス接続先を切替<br>4. 元のスキーマを削除 | シンプル | ダウンタイム発生 |
| **レプリケーション** | 1. 新DBサーバーをセットアップ<br>2. スキーマをレプリケート<br>3. サービス接続先を切替<br>4. レプリケーションを停止<br>5. 元のスキーマを削除 | ダウンタイムなし | 設定・調整作業増 |

**移行後の構成**:
```
サービスC ──> DBサーバーC (チケットスキーマ)

サービスD ──> DBサーバーD (支払いスキーマ)
```

---

### 2.6 ステップ5: ポリグロットデータベースへの切り替え（オプション）

**目的**: 各データドメインに最適なデータベース種別を選択。

データベース種別の選択基準は「3. ポリグロットデータベース選択基準」を参照。

---

## 3. ポリグロットデータベース選択基準 / Polyglot Database Selection

### 3.1 データベース種別の分類

| DB種別 | 代表例 | 最適なユースケース | データ構造 |
|-------|-------|----------------|----------|
| **リレーショナル** | PostgreSQL, MySQL, Oracle | 複雑なクエリ、トランザクション整合性 | 正規化されたテーブル |
| **キーバリュー** | Redis, DynamoDB | セッション管理、キャッシュ、高速アクセス | Key-Value ペア |
| **ドキュメント** | MongoDB, Couchbase | 柔軟なスキーマ、階層データ、JSON/XML | JSON/BSONドキュメント |
| **カラムファミリー** | Cassandra, HBase | 時系列データ、大規模ログ、書き込み重視 | 列指向ストレージ |
| **グラフ** | Neo4j, Amazon Neptune | ソーシャルネットワーク、レコメンデーション、関係分析 | ノードとエッジ |
| **NewSQL** | CockroachDB, Google Spanner | ACID + 水平スケーラビリティ | 分散リレーショナル |
| **クラウドネイティブ** | Aurora, Cosmos DB | マネージドサービス、自動スケーリング | クラウド最適化 |
| **時系列** | InfluxDB, TimescaleDB | IoT、メトリクス、ログ集約 | タイムスタンプ付きデータ |

---

### 3.2 選択判断テーブル

#### 3.2.1 データ特性による選択

| データ特性 | 推奨DB種別 | 理由 |
|-----------|-----------|------|
| 構造化データ + ACID必須 | リレーショナル | トランザクション整合性保証 |
| 非構造化データ | ドキュメント | スキーマの柔軟性 |
| 単純なKey取得 | キーバリュー | 最速のアクセス速度 |
| 高度な関係性分析 | グラフ | 最短パス、推薦アルゴリズムに最適 |
| 大量の時系列データ | 時系列、カラムファミリー | 書き込みパフォーマンス、圧縮率 |

---

#### 3.2.2 ワークロード特性による選択

| ワークロード | 推奨DB種別 | 考慮事項 |
|------------|-----------|---------|
| 読み取り重視 | リレーショナル + キャッシュ（Redis） | Read Replica + インメモリキャッシュ |
| 書き込み重視 | カラムファミリー、時系列 | 書き込みスループット優先 |
| 複雑なクエリ | リレーショナル | JOIN、集計、サブクエリのサポート |
| 単純なCRUD | キーバリュー、ドキュメント | オーバーヘッド最小化 |
| グラフトラバーサル | グラフ | 関係性探索の効率化 |

---

#### 3.2.3 スケーラビリティ要件による選択

| スケーラビリティ要件 | 推奨DB種別 | 注意点 |
|--------------------|-----------|-------|
| 垂直スケーリング | リレーショナル | ハードウェア制約あり |
| 水平スケーリング（AP） | カラムファミリー、ドキュメント | 結果整合性 |
| 水平スケーリング（CP） | NewSQL | ACID維持、やや複雑 |
| グローバル分散 | NewSQL、クラウドネイティブ | レイテンシとコストのトレードオフ |

---

### 3.3 Sysops Squadでの適用例

| データドメイン | 選択したDB種別 | 理由 |
|--------------|--------------|------|
| **チケット** | PostgreSQL（リレーショナル） | 複雑なクエリ、ACID必須、チケット履歴の整合性 |
| **アンケート** | MongoDB（ドキュメント） | 柔軟な質問形式、スキーマ変更頻度高 |
| **ナレッジベース** | Elasticsearch（全文検索） | 記事検索、タグ・キーワード検索 |
| **プロフィール** | PostgreSQL（リレーショナル） | エキスパートと専門分野の関係管理 |
| **支払い** | PostgreSQL（リレーショナル） | 金融トランザクション、ACID厳守 |
| **セッション** | Redis（キーバリュー） | 高速アクセス、TTL管理 |

---

## 4. 境界づけられたコンテキストとデータ境界の対応

### 4.1 基本原則

```
Bounded Context ≒ データドメイン ≒ スキーマ ≒ データベース
```

ただし、1つのBounded Contextが複数のデータドメインを含む場合もある（密結合したデータ関係が存在する場合）。

---

### 4.2 データ所有権のルール

1. **単一所有権**: 各テーブルは1つのサービスのみが書き込み可能
2. **読み取り専用アクセス禁止**: 他のサービスのDBに直接読み取りアクセスしない
3. **サービス経由のデータ取得**: データが必要な場合はサービスAPIを呼び出す
4. **Event-Carried State Transfer**: 頻繁にアクセスするデータはイベントで投影（キャッシュ）

**良い例**:
```
サービスA（チケット管理）
  ├─ チケットDB（所有）
  └─ 顧客名キャッシュ（顧客サービスからのイベント投影）

サービスB（顧客管理）
  └─ 顧客DB（所有）
      ↓ CustomerUpdatedイベント発行
      └─→ サービスAがイベントを受信してキャッシュ更新
```

**悪い例**:
```
サービスA（チケット管理）
  ├─ チケットDB
  └─ 顧客DBへの直接読み取りアクセス ❌
```

---

## 5. データ分解の注意事項

### 5.1 参照整合性の喪失

**課題**: 外部キー制約がデータベース間で使用できない。

**対策**:
1. **アプリケーション層での整合性チェック**: サービス内で明示的にバリデーション
2. **Saga パターン**: 分散トランザクションの補償処理
3. **適応度関数**: データ整合性の定期的な検証

---

### 5.2 データ結合の代替手段

**課題**: データベース間でJOINができない。

**対策**:
1. **サービス間通信**: REST/gRPCで複数サービスからデータ取得
2. **Event-Carried State Transfer**: 必要なデータを事前にキャッシュ
3. **CQRS**: 読み取り専用のビューモデルを構築
4. **データメッシュ**: 分析用のデータプロダクトを別途提供

---

### 5.3 パフォーマンスへの影響

**課題**: ネットワーク通信のオーバーヘッド。

**対策**:
1. **非同期処理**: イベント駆動で結果整合性を許容
2. **バッチ処理**: 複数リクエストをまとめて処理
3. **キャッシュ戦略**: Redis等でホットデータをキャッシュ
4. **GraphQL**: 1リクエストで複数リソースを取得

---

## 6. まとめ

### 6.1 データ分解の判断基準

データ分解を検討すべき状況:
- ✅ 共有DBのコネクション枯渇
- ✅ スキーマ変更時の調整コストが高い
- ✅ サービスごとに異なるDB種別が必要
- ✅ 単一障害点の排除が必要

データ統合を維持すべき状況:
- ✅ 複雑なJOINクエリが頻繁に必要
- ✅ 強いACID整合性が必須
- ✅ データ量が少なくスケール不要

---

### 6.2 DDD戦略的設計との統合

```
Subdomain分類
   ↓
Bounded Context定義
   ↓
データドメイン特定
   ↓
スキーマ分離
   ↓
物理的DB分離
   ↓
ポリグロットDB選択
```

Bounded Contextの境界とデータドメインの境界を一致させることで、変更の影響範囲を最小化し、マイクロサービスアーキテクチャのメリットを最大化できる。

---

## 関連ドキュメント

- **STRATEGIC-DESIGN.md**: Bounded Contextの定義方法
- **INTEGRATION.md**: マイクロサービス・イベント駆動・データメッシュとの統合
- **TACTICAL-PATTERNS.md**: Aggregateとトランザクション境界
