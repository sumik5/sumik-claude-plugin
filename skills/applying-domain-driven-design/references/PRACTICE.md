# DDD 実践ガイド

ドメイン駆動設計の実践的なヒューリスティックス（経験則）、進化戦略、イベントストーミング、既存システムへの導入方法を提供する。

---

## 設計の経験則（Heuristics）

### Bounded Context の分割基準

Bounded Context の境界は、以下の基準で判断する：

| 基準 | 説明 | 例 |
|------|------|-----|
| **業務領域の一貫性** | ユビキタス言語が一貫して使用できる範囲 | 「注文」という用語が販売と在庫で異なる意味を持つ場合は分割 |
| **変更の頻度・方向性** | 一緒に変更される機能の集まり | 価格計算ロジックは頻繁に変わるが、在庫管理は安定 → 分割 |
| **組織の境界** | チーム構成やオーナーシップの境界 | チームAが請求、チームBが配送を担当 → 分割 |
| **技術要件の違い** | 性能要件・データ永続化方法の違い | リアルタイム分析（CQRS）と基幹業務（トランザクション）→ 分割 |
| **セキュリティ境界** | アクセス制御・監査要件の違い | 顧客向け機能と管理者向け機能 → 分割 |

**原則**: 小さく始めて、必要に応じて分割する。早すぎる分割は過度な複雑性を生む。

---

### 業務ロジック実装方法の選択フロー

実装パターンは業務領域のカテゴリ、データ構造の複雑さ、金銭/監査要件に基づいて選択する。

```
┌─────────────────────────────────────┐
│  業務領域のカテゴリは？              │
└────────┬────────────────────────────┘
         │
    ┌────┴────┬──────────────┐
    │         │              │
┌───▼────┐ ┌──▼──────┐  ┌───▼─────┐
│ 補完的 │ │ 一般的  │  │  中核   │
│業務領域│ │業務領域  │  │業務領域 │
└───┬────┘ └──┬──────┘  └───┬─────┘
    │         │              │
    │    ┌────▼──────────┐   │
    │    │データ構造は   │   │
    │    │複雑か？       │   │
    │    └────┬──────────┘   │
    │         │              │
    │    ┌────┴────┐         │
    │    │         │         │
    │  いいえ     はい        │
    │    │         │         │
    │    │    ┌────▼────────────┐
    │    │    │金銭処理、データ分析│
    │    │    │または監査記録か？  │
    │    │    └────┬────────────┘
    │    │         │
    │    │    ┌────┴────┐
    │    │    │         │
    │    │  いいえ     はい
    │    │    │         │
    ▼    ▼    ▼         ▼
┌──────┐ ┌──────┐ ┌──────┐ ┌──────────────┐
│Transaction│ │Active │ │Domain│ │Event-Sourced │
│Script     │ │Record │ │Model │ │Domain Model  │
└──────────┘ └───────┘ └──────┘ └──────────────┘
```

**判断基準詳細**:

1. **業務領域カテゴリ**:
   - **補完的**: 他社と差別化不要、既製品で代替可能 → Transaction Script
   - **一般的**: 必要だが競争優位性はない、カスタマイズ可能な製品で対応 → データ構造で判断
   - **中核**: 競争優位の源泉、最大の投資対象 → データ構造・監査要件で判断

2. **データ構造の複雑さ**:
   - **単純**: CRUD操作が中心、ビジネスルールが少ない → Active Record
   - **複雑**: 不変条件、複雑なビジネスルール、集約が必要 → Domain Model

3. **金銭/監査要件**:
   - **あり**: 完全な監査証跡、時間軸での状態再構築が必要 → Event-Sourced Domain Model
   - **なし**: Domain Model で十分

---

### 技術方式の選択基準

実装パターンに応じた技術方式（アーキテクチャ）の選択:

```
┌──────────────────────────────────┐
│  永続化モデルは複数か？           │
│ (読取モデル ≠ 書込モデル)         │
└────────┬─────────────────────────┘
         │
    ┌────┴────┐
    │         │
  いいえ     はい
    │         │
    ▼         ▼
┌─────────┐ ┌──────┐
│業務ロジック│ │ CQRS │
│実装方法   │ └──────┘
└────┬────┘
     │
┌────┴────────────────────────────┐
│                                 │
▼                                 ▼
┌────────────────┐       ┌────────────────┐
│Transaction Script│       │   Domain Model  │
│  Active Record   │       │Event-Sourced DM │
└────────┬─────────┘       └────────┬────────┘
         │                          │
         ▼                          ▼
┌────────────────┐       ┌────────────────┐
│ Layered        │       │ Ports &        │
│ Architecture   │       │ Adapters       │
│ (3層 or 4層)   │       │ (Hexagonal)    │
└────────────────┘       └────────────────┘
```

**選択ガイドライン**:

| 実装パターン | 技術方式 | 理由 |
|------------|---------|------|
| Transaction Script | Layered Architecture (3層) | シンプルなCRUD操作に適合 |
| Active Record | Layered Architecture (3-4層) | データ中心の設計に適合 |
| Domain Model | Ports & Adapters | ビジネスロジックを外部依存から隔離 |
| Event-Sourced Domain Model | Ports & Adapters + CQRS | イベント履歴と読取モデルの分離が必要 |

**CQRS の適用判断**:
- ✅ **適用すべき**: 読取モデルと書込モデルが異なる、複数の永続化モデルが必要、高度な検索・分析が必要
- ❌ **不要**: 単純なCRUD、モデルの分離が複雑性を上回らない

---

### テスト方針

実装パターンごとに最適なテスト形状（テストピラミッド）が異なる:

| 実装パターン | テスト形状 | 説明 | テスト配分 |
|------------|----------|------|-----------|
| **Transaction Script** | 逆ピラミッド形 | エンドツーエンドテスト重視。ビジネスロジックがUI・データアクセスと密結合しているため、統合テストが効率的 | E2E: 70%, 統合: 20%, 単体: 10% |
| **Active Record** | ダイヤモンド形 | 統合テスト重視。データベースとの統合をテストすることが重要 | E2E: 30%, 統合: 50%, 単体: 20% |
| **Domain Model** | ピラミッド形 | 単体テスト重視。ビジネスロジックが隔離されているため、高速な単体テストが可能 | E2E: 10%, 統合: 20%, 単体: 70% |
| **Event-Sourced Domain Model** | ピラミッド形 | 単体テスト重視。イベントベースのテストで決定論的に検証可能 | E2E: 10%, 統合: 20%, 単体: 70% |

**視覚化**:

```
Transaction Script    Active Record      Domain Model       Event-Sourced DM
(逆ピラミッド)        (ダイヤモンド)     (ピラミッド)        (ピラミッド)

    ┌─────┐              ┌───┐           ┌───┐             ┌───┐
    │ E2E │              │E2E│           │E2E│             │E2E│
    ├─────┤              ├───┤           ├───┤             ├───┤
    │統合 │              │   │           │   │             │   │
    ├─────┤              │統合│           │統合│             │統合│
    │単体 │              │   │           │   │             │   │
    └─────┘              ├───┤           │   │             │   │
                         │単体│           │   │             │   │
                         └───┘           │単体│             │単体│
                                         │   │             │   │
                                         └───┘             └───┘
```

---

## 設計の進化

### 業務領域の変遷パターン

業務領域のカテゴリは時間とともに変化する。以下の6パターンが典型的:

```
┌─────────┬─────────┬─────────┐
│  中核   │  一般   │  補完   │
└────┬────┴────┬────┴────┬────┘
     │          │          │
     │          │          │
┌────▼──────┐   │          │
│1. 中核→一般│   │          │
│ (競争優位  │   │          │
│  の喪失)  │   │          │
└───────────┘   │          │
                │          │
     ┌──────────▼─────┐    │
     │2. 一般→中核     │    │
     │ (差別化の機会)  │    │
     └─────────────────┘    │
                            │
┌────────────┐   ┌──────────▼─────┐
│3. 補完→一般│   │4. 補完→中核     │
│ (重要性増) │   │ (戦略転換)      │
└────────────┘   └─────────────────┘

┌────────────┐   ┌─────────────────┐
│5. 中核→補完│   │6. 一般→補完     │
│ (外注化)   │   │ (単純化)        │
└────────────┘   └─────────────────┘
```

**変遷パターンの詳細**:

| パターン | トリガー | 対応アクション |
|---------|---------|--------------|
| **1. 中核 → 一般** | 競合が同等機能を提供、標準化が進む | 投資削減、既製品への移行検討 |
| **2. 一般 → 中核** | 新たな差別化の機会発見、市場変化 | 投資増加、Domain Model への移行 |
| **3. 補完 → 一般** | ビジネス成長により重要性増加 | カスタマイズ可能な製品への移行 |
| **4. 補完 → 中核** | 戦略的価値の再評価 | フルカスタム実装、Domain Model 採用 |
| **5. 中核 → 補完** | 外注化・クラウドサービス化の決定 | 段階的な外部サービスへの移行 |
| **6. 一般 → 補完** | 業務の単純化、標準製品で十分に | 既製品への置き換え |

---

### 実装方法のアップグレードパス

実装パターンは段階的に進化させることができる:

```
Transaction Script
    ↓ (データ構造が複雑化)
Active Record
    ↓ (ビジネスルールが増加)
Domain Model
    ↓ (監査要件・時間軸分析が必要)
Event-Sourced Domain Model
```

**各段階の移行トリガー**:

1. **Transaction Script → Active Record**:
   - データ構造が増加
   - 基本的なビジネスルールが出現
   - データベース操作の重複が増加

2. **Active Record → Domain Model**:
   - 複雑な不変条件が必要
   - ビジネスルールが複数エンティティにまたがる
   - データアクセスとビジネスロジックの分離が必要

3. **Domain Model → Event-Sourced Domain Model**:
   - 完全な監査証跡が必要
   - 時間軸での状態再構築が必要
   - イベント駆動アーキテクチャへの移行

---

### 組織変更と連係パターンの進化

チーム間の関係性は組織変更に伴って進化する:

```
Partnership
(初期の協力)
    ↓
Customer-Supplier
(関係の明確化)
    ↓
Separate Ways
(完全な独立)
```

**連係パターンの詳細**:

| パターン | 関係性 | 移行のトリガー |
|---------|-------|--------------|
| **Partnership** | 双方向の緊密な協力。相互依存が高い | 初期開発、共通の目標 |
| **Customer-Supplier** | 明確な上流/下流関係。下流チームが顧客 | 要件が安定、契約的関係の確立 |
| **Separate Ways** | 独立したBounded Context。連係なし | 業務領域の分離、技術スタックの分離 |

---

### システムの成長パターン

システムは以下の3つの次元で成長する:

#### 1. 業務領域の分割

```
単一の大きな業務領域
    ↓
┌──────────┬──────────┬──────────┐
│ 販売促進 │ 決済     │ 在庫管理 │
└──────────┴──────────┴──────────┘
```

#### 2. Bounded Context の分割

```
販売促進の Bounded Context
    ↓
┌────────────┬────────────┬────────────┐
│広告素材管理│キャンペーン │広告最適化   │
└────────────┴────────────┴────────────┘
```

#### 3. Aggregate の分割

```
大きな Aggregate (注文)
    ↓
┌──────────┬──────────┬──────────┐
│注文ヘッダ│配送情報  │支払情報   │
└──────────┴──────────┴──────────┘
```

**分割の判断基準**:

| 分割対象 | トリガー | 効果 |
|---------|---------|------|
| **業務領域** | ビジネス戦略の変化、新規事業領域の追加 | 組織境界の明確化 |
| **Bounded Context** | チーム間の調整コスト増加、技術スタックの多様化 | デプロイ独立性の向上 |
| **Aggregate** | トランザクション競合の増加、スケーラビリティ問題 | 並行性の向上 |

---

## イベントストーミング（EventStorming）

イベントストーミングは、ドメインエキスパートと開発者が協力してシステムの全体像を素早く理解するワークショップ手法。

### 10ステップワークフロー

```
1. 発散的に探索 (ドメインイベントを付箋に書き出す)
    ↓
2. 時系列に並べる (タイムラインを作成)
    ↓
3. 問題点を洗い出す (pain point を可視化)
    ↓
4. 転換イベントを見つける (pivotal event を特定)
    ↓
5. コマンドを見つける (イベントを引き起こすアクション)
    ↓
6. ポリシーを定義する (イベント → コマンドのルール)
    ↓
7. 読み取りモデルを見つける (意思決定に必要な情報)
    ↓
8. 外部システムを追加する (システム境界の明確化)
    ↓
9. 集約を見つける (コマンド → イベント の単位)
    ↓
10. Bounded Context に分割する (業務境界の確定)
```

### 付箋の色分け

| 色 | 要素 | 説明 | 例 |
|----|-----|------|-----|
| **オレンジ** | ドメインイベント | システム内で発生した事実（過去形） | 「注文が出荷された」「支払いが承認された」 |
| **青** | コマンド | ユーザーやシステムが実行するアクション | 「注文を送信する」「在庫を更新する」 |
| **黄（小）** | アクター | コマンドを実行する主体 | 「顧客」「管理者」「在庫システム」 |
| **紫** | ポリシー | イベントに反応して自動的に実行されるルール | 「VIP顧客の注文は即座に出荷承認」 |
| **緑** | 読み取りモデル | 意思決定に必要な情報・画面 | 「ショッピングカート」「在庫一覧」 |
| **ピンク** | 外部システム | Bounded Context 外のシステム | 「CRMシステム」「決済ゲートウェイ」 |
| **黄（大）** | 集約 | コマンドとイベントをまとめる単位 | 「注文」「顧客」「商品」 |
| **赤/ピンク** | 問題点 | 不明点・懸念事項・ボトルネック | 「どのように価格が比較されているのか？」 |

### ワークショップの進め方

```
┌─────────────────────────────────────────┐
│ ステップ1-2: イベントの発散と整理       │
│ ・全員が自由にドメインイベントを書く    │
│ ・時系列に並べて全体の流れを把握       │
└────────────┬────────────────────────────┘
             ↓
┌─────────────────────────────────────────┐
│ ステップ3-4: 問題の発見と焦点の絞込     │
│ ・不明点・矛盾点を赤い付箋で記録        │
│ ・転換イベント（重要なポイント）を特定 │
└────────────┬────────────────────────────┘
             ↓
┌─────────────────────────────────────────┐
│ ステップ5-8: システム要素の追加         │
│ ・コマンド、アクター、ポリシーを追加    │
│ ・読み取りモデル、外部システムを識別   │
└────────────┬────────────────────────────┘
             ↓
┌─────────────────────────────────────────┐
│ ステップ9-10: 境界の確定                │
│ ・集約を見つけてコマンド/イベントを囲む │
│ ・Bounded Contextに分割                 │
└─────────────────────────────────────────┘
```

**ファシリテーションのコツ**:

1. **発散フェーズ（ステップ1-2）**:
   - 批判厳禁、すべてのアイデアを歓迎
   - ドメインエキスパートに積極的に発言してもらう
   - 時間制限を設けて集中力を維持（15-30分）

2. **収束フェーズ（ステップ3-10）**:
   - 問題点を可視化し、優先順位をつける
   - 転換イベント（pivotal event）に注目して議論を深める
   - 技術的な実装詳細には踏み込まない

3. **リモート開催**:
   - Miro、Mural などのオンラインホワイトボードツールを使用
   - 付箋の色分けはツールの機能で再現
   - タイムボックスを厳守してテンポを保つ

---

## 既存システムへのDDD導入

### 戦略的分析

既存システムにDDDを導入する前に、現状を理解する:

#### 1. 事業活動の理解

| 分析項目 | 目的 | 手法 |
|---------|------|------|
| **ビジネス戦略** | 競争優位性の源泉を特定 | 経営陣へのインタビュー、戦略文書のレビュー |
| **業務領域の分類** | 中核/一般/補完を判定 | ビジネスモデルキャンバス、バリューチェーン分析 |
| **組織構造** | チーム境界とコミュニケーションパターンを把握 | 組織図、Conway の法則の適用 |

#### 2. 既存システム構造の調査

| 調査対象 | 確認内容 | ツール |
|---------|---------|--------|
| **コードベース** | モジュール構成、依存関係、技術スタック | 依存関係グラフ、静的解析ツール |
| **データモデル** | テーブル構造、ER図、データフロー | データベースリバースエンジニアリング |
| **デプロイ単位** | アプリケーション境界、デプロイ頻度 | インフラ構成図、CI/CDパイプライン |

---

### 設計改善の段階

DDD導入は段階的に進める。以下の3つのレベルで改善を積み重ねる:

#### レベル1: 基本方針の改善

最も影響が大きく、早期に取り組むべき改善:

| 改善項目 | 内容 | 効果 |
|---------|------|------|
| **業務領域の整理** | 中核/一般/補完の分類を見直す | 投資配分の最適化 |
| **チーム構造の調整** | Bounded Context とチームを一致させる | コミュニケーションコストの削減 |
| **連係パターンの定義** | Partnership/Customer-Supplier を明確化 | 責任範囲の明確化 |

#### レベル2: 実装方法の改善

コードレベルでの戦術パターンの適用:

| 改善項目 | 内容 | 効果 |
|---------|------|------|
| **Aggregate の導入** | トランザクション境界を明確化 | データ整合性の向上 |
| **Value Object の活用** | プリミティブ型の置き換え | ビジネスルールの集約 |
| **Domain Event の導入** | 状態変化をイベントとして表現 | 疎結合化、監査証跡 |

#### レベル3: ユビキタス言語の育成

最も時間がかかるが、長期的に最も重要:

| 活動 | 内容 | 効果 |
|------|------|------|
| **用語集の整備** | ドメイン用語を文書化 | 認識の統一 |
| **イベントストーミング** | 定期的なワークショップ | 知識の共有 |
| **コードとドキュメントの一致** | 用語をコードに反映 | 保守性の向上 |

---

### ストラングラーフィグパターン

既存システムを段階的に置き換える戦略:

```
移行の初期
┌─────────┐
│ 利用者  │
└────┬────┘
     │
┌────▼────┐
│ファサード│ (新システムへのルーティング開始)
└─┬───┬───┘
  │   │
  │  ┌▼──────┐
  │  │新システム│ (一部機能のみ)
  │  └───────┘
  │
┌─▼─────────┐
│既存システム │ (ほとんどの機能)
└────────────┘

移行の中盤
┌─────────┐
│ 利用者  │
└────┬────┘
     │
┌────▼────┐
│ファサード│ (多くが新システムへ)
└─┬───┬───┘
  │   │
  │  ┌▼──────┐
  │  │新システム│ (主要機能)
  │  └───────┘
  │
┌─▼─────────┐
│既存システム │ (一部機能)
└────────────┘

移行の完了
┌─────────┐
│ 利用者  │
└────┬────┘
     │
┌────▼────┐
│新システム│ (全機能)
└─────────┘
```

**ストラングラーフィグの原則**:

1. **ファサードの導入**: 既存システムの前にファサードを配置し、新旧システムへのルーティングを制御
2. **段階的移行**: 機能単位で少しずつ新システムに移行
3. **並行稼働**: 移行期間中は新旧システムが共存
4. **完全置換**: 既存システムの全機能が移行完了したら廃止

**データベースの移行戦略**:

```
移行の初期
┌──────────┐  ┌──────────┐
│新システム │  │既存システム│
└────┬─────┘  └────┬─────┘
     │             │
     │        ┌────▼─────┐
     └────────► データベース│ (共有)
              └──────────┘

移行の中盤
┌──────────┐     ┌──────────┐
│新システム │     │既存システム│
└────┬─────┘     └────┬─────┘
     │                │
┌────▼─────┐     ┌────▼─────┐
│新DB      │◄────┤既存DB     │ (同期)
└──────────┘     └──────────┘

移行の完了
┌──────────┐
│新システム │
└────┬─────┘
     │
┌────▼─────┐
│新DB      │
└──────────┘
```

---

### DDDの非公式な導入

組織全体でのDDD採用が難しい場合、小さく始める:

#### 戦術1: 小さな成功から始める

| ステップ | 活動 | 成果物 |
|---------|------|--------|
| **1. パイロットプロジェクト** | 小さな機能でDDDパターンを試す | 実証された価値 |
| **2. 成功の共有** | チーム内で結果を報告 | 賛同者の獲得 |
| **3. 段階的拡大** | 他の機能にも適用 | 組織への浸透 |

#### 戦術2: 既存コードの改善

| 改善対象 | 具体的アクション | 効果 |
|---------|----------------|------|
| **Setter の封印** | public setter を private に変更 | カプセル化の強化 |
| **ビジネスロジックの集約** | データクラスにメソッドを追加 | ロジックの一元化 |
| **Value Object の導入** | プリミティブ型を Value Object に置換 | 型安全性の向上 |

**例: Setter の段階的除去**

```csharp
// ステップ1: 現状 (貧血ドメインモデル)
public class Player
{
    public Guid Id { get; set; }
    public int Points { get; set; }
}

public class ApplyBonus
{
    public void Execute(Guid playerId, byte percentage)
    {
        var player = _repository.Load(playerId);
        player.Points *= 1 + percentage/100.0;  // ロジックが外部に
        _repository.Save(player);
    }
}

// ステップ2: Setter を private に変更
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }
}
// → コンパイルエラーで問題箇所を発見

// ステップ3: ドメインロジックをエンティティ内に移動
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }

    public void ApplyBonus(int percentage)  // ビジネスルールをカプセル化
    {
        this.Points *= 1 + percentage/100.0;
    }
}

public class ApplyBonus
{
    public void Execute(Guid playerId, byte percentage)
    {
        var player = _repository.Load(playerId);
        player.ApplyBonus(percentage);  // 意図が明確に
        _repository.Save(player);
    }
}
```

---

## まとめ

DDD の実践は、以下の原則を守ることで成功率が高まる:

1. **小さく始める**: 全社的な導入ではなく、パイロットプロジェクトから
2. **段階的に進化させる**: Transaction Script → Active Record → Domain Model
3. **ビジネス価値を常に意識**: 技術的完璧さより、ビジネス成果を優先
4. **チーム全体で学ぶ**: イベントストーミングなどの協働手法を活用
5. **失敗から学ぶ**: 設計の誤りは早期に修正し、次に活かす
