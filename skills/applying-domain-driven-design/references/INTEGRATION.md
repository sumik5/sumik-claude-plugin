# 他技法との関係 / Integration with Other Techniques

本ファイルでは、DDDとマイクロサービス、イベント駆動型アーキテクチャ、データメッシュの関係を解説する。

---

## 1. マイクロサービスとDDD / Microservices and DDD

### 1.1 サービスの定義

**OASISのSOA参照モデルによる定義**:

サービスとは「ある機能を公開するメカニズムであり、公開されたインターフェースを介してアクセスされ、定義された制約と方針に従って実行される」。

重要なのは「公開されたインターフェース」である。

---

### 1.2 マイクロサービスの設計目的

マイクロサービスアーキテクチャは、システムを独立してデプロイ可能な小さなサービスに分割することで、変更の影響範囲を局所化し、開発・デプロイの俊敏性を向上させることを目的とする。

しかし、誤った境界設定は「分散した大きな泥団子」を生み出す。

**複雑さのトレードオフ**:
```
# 複雑さ

大きな泥団子 ────────→ 分散した大きな泥団子
  局所的複雑さ大            大局的複雑さ大

        ↓ 適切な境界設定

      Bounded Context
  （粒度のスイートスポット）
```

**大きな泥団子**: すべてのロジックが1つのモノリシックシステムに集約され、内部の複雑さ（局所的複雑さ）が高い。

**分散した大きな泥団子**: 不適切な境界でサービスを分割した結果、サービス間の依存関係が複雑化し、システム全体の複雑さ（大局的複雑さ）が増大する。

**Bounded Context（境界づけられた文脈）**: DDDの戦略的設計で定義される境界は、マイクロサービスの粒度設計における有力な候補となる。

---

### 1.3 深いモジュール（The Philosophy of Software Design）

**深いモジュールの原則**:
- **インターフェース（機能）**: 少ないほうが良い
- **実装の複雑さ（ロジック）**: 多いほうが良い

```
深いモジュール:
┌────┐
│機能│ ← 少ない公開インターフェース
├────┤
│    │
│ロジ│ ← 複雑なロジックをカプセル化
│ック│
│    │
└────┘

浅いモジュール:
┌────┐
│機能│ ← 多くの公開インターフェース
├────┤
│ロジ│ ← 単純なロジック
└────┘
```

**アンチパターン**:
```csharp
int AddTwoNumbers(int a, int b)
{
    return a + b;
}
```

このような単純なロジックを1つのサービスにすることは、ネットワーク通信のオーバーヘッドが価値を上回る。

**DDDの適用**:
- Bounded ContextやAggregateは、業務的に意味のある境界を提供する
- これにより、深いモジュールとしての設計が可能になる

---

### 1.4 DDDとマイクロサービス境界の設計

**Bounded Contextを起点とした境界設計**:

1つのBounded Contextは、1つ以上のマイクロサービスに対応する可能性がある。

**例: 販売促進と営業活動のBounded Context**

Bounded Context:
```
販売促進
├─ キャンペーン管理
├─ 広告素材最適化
└─ カタログ

営業活動
├─ 見込み客管理
├─ 電話営業
├─ 契約
└─ 営業事務
```

**分け方1（Bounded Contextごと）**:
```
販売促進サービス
営業活動サービス
認証認可サービス
請求サービス
顧客管理サービス
```

**分け方2（Aggregateごと）**:
```
キャンペーン管理サービス
広告素材最適化サービス
カタログサービス
見込み客管理サービス
電話営業サービス
契約サービス
営業事務サービス
報奨金最適化サービス
認証認可サービス
請求サービス
顧客管理サービス
```

**分け方3（ハイブリッド）**:
```
キャンペーン管理サービス
広告最適化サービス（広告素材+カタログ統合）
営業支援サービス（見込み客+電話営業+契約+営業事務統合）
請求サービス
顧客管理サービス
認証認可サービス
```

**粒度のスイートスポット**:
```
粒度

大きな泥団子 ── Bounded Context ── マイクロサービス ── 分散した大きな泥団子
                     ↑
             最適な粒度の範囲
```

Bounded ContextとAggregateの間に、組織の変更速度やチーム構成を考慮した最適な境界が存在する。

---

### 1.5 Aggregateとマイクロサービス境界

Aggregateはトランザクション境界であり、マイクロサービスの境界候補となる。

**例: キャンペーン最適化サービス（11のAggregate）**

インターフェース（少ない）:
```
CampaignOptimizationService
+ OptimizeCampaign(CampaignId): OptimizationResult
```

ロジックの複雑さ（多い）:
- 広告配信最適化
- 予算配分アルゴリズム
- A/Bテスト管理
- パフォーマンス追跡
- 11のAggregate

このようにAggregateをサービス内部にカプセル化することで、深いモジュールとして設計できる。

---

### 1.6 Context Mappingによる連係パターン

マイクロサービス間の連係は、Context Mappingパターンを適用する。

**Shared Kernel（共用カーネル）**:
```
下流のBounded Context
     ↕（共用）
上流のBounded Context
     ↕（共用）
下流のBounded Context
```

共通のモデルやコードを複数サービスで共有する。

**Anti-Corruption Layer（腐敗防止層）**:
```
下流のBounded Context
     ↑（モデル変換装置）
上流のBounded Context
     ↑（モデル変換装置）
下流のBounded Context
```

上流のモデル変更から下流を保護するため、変換層を設ける。

詳細はSTRATEGIC-DESIGN.mdのContext Mappingセクション参照。

---

### 1.7 変更コストと粒度

```
# 変更コスト

大きな泥団子 ─ 適切なマイクロサービス ─ 分散した大きな泥団子
      ↑                ↑                      ↑
    高コスト       低コスト              非常に高コスト
```

適切に境界づけられたマイクロサービスは、変更コストを最小化する。

---

## 2. イベント駆動型アーキテクチャとDDD / Event-Driven Architecture and DDD

### 2.1 イベント駆動型アーキテクチャの基本

イベント駆動型アーキテクチャでは、サービス間の連係をイベントのpublish/subscribeで実現する。

```
サービス1 ─publish→ イベント ─subscribe→ サービス2
```

DDDのDomain Eventは、イベント駆動型アーキテクチャの基盤となる。

---

### 2.2 イベントの3カテゴリ

#### 2.2.1 Event Notification（イベント通知）

**特徴**:
- 発行者は「何かが起きた」ことを通知するのみ
- 詳細情報は含まない（あるいは最小限のメタデータのみ）
- 受信者は必要に応じて発行者に問い合わせる

**実装例**:
```json
{
  "type": "paycheck-generated",
  "event-id": "537ec7c2-d1a1-2005-8654-96aee1116b72",
  "delivery-id": "05011927-a328-4860-a106-737b2929db4e",
  "timestamp": 1615726445,
  "payload": {
    "employee-id": "456123",
    "link": "/paychecks/456123/2021/01"
  }
}
```

受信者は`link`にアクセスして詳細を取得する。

**メリット**:
- 発行者と受信者の結合度が低い
- 受信者が必要な情報のみ取得

**デメリット**:
- 追加のHTTPリクエストが必要
- 発行者のAPIが常に利用可能である必要がある

---

#### 2.2.2 Event-Carried State Transfer（イベントによる状態転送）

**特徴**:
- イベントに必要な状態をすべて含める
- 受信者はイベントから状態を投影（キャッシュ）し、問い合わせ不要

**実装例**:
```json
{
  "type": "customer-updated",
  "event-id": "6b7ce6c6-8587-4e4f-924a-cec028000ce6",
  "customer-id": "01b18d56-b79a-4873-ac99-3d9f767dbe61",
  "timestamp": 1615728520,
  "payload": {
    "first-name": "Carolyn",
    "last-name": "Hayes",
    "phone": "555-1022",
    "status": "follow-up-set",
    "follow-up-date": "2021/05/08",
    "birthday": "1982/04/05",
    "version": 7
  }
}
```

受信者は`customer-updated`イベントから顧客情報をローカルに投影し、発行者への問い合わせなしに利用できる。

**メリット**:
- 受信者の読み取りパフォーマンス向上
- 発行者への依存を削減

**デメリット**:
- イベントサイズが大きくなる可能性
- 結果整合性（eventually consistent）

**差分更新の例**:
```json
{
  "type": "customer-updated",
  "event-id": "6b7ce6c6-8587-4e4f-924a-cec028000ce6",
  "customer-id": "01b18d56-b79a-4873-ac99-3d9f767dbe61",
  "timestamp": 1615728520,
  "payload": {
    "status": "follow-up-set",
    "follow-up-date": "2021/05/10",
    "version": 8
  }
}
```

変更されたフィールドのみを含めることで、イベントサイズを削減できる。

---

#### 2.2.3 Domain Event（ドメインイベント）

**特徴**:
- 業務上の出来事を表現
- Event NotificationとEvent-Carried State Transferの中間
- 業務的に重要な情報を含む

**実装例**:
```json
{
  "type": "person-married",
  "person-id": "01b9a761",
  "payload": {
    "person-id": "126a7b61",
    "assumed-partner-last-name": true
  }
}
```

このイベントは「結婚した」という業務イベントを表し、パートナーのIDと姓の変更有無を含む。

**Event Notificationとの違い**:
```json
// Event Notification
{
  "type": "person-married",
  "person-id": "01b9a761",
  "payload": {
    "person-id": "126a7b61",
    "details": "/01b9a761/marriage-data"
  }
}
```

**Event-Carried State Transferとの違い**:
```json
// Event-Carried State Transfer
{
  "type": "person-married",
  "person-id": "01b9a761",
  "payload": {
    "new-last-name": "Williams"
  }
}
```

Domain Eventは業務的文脈を保持しつつ、必要な情報を含む。

---

### 2.3 結合の種類

イベント駆動型アーキテクチャにおける結合を理解し、設計に反映する。

#### 2.3.1 実装の結合（Implementation Coupling）

発行者と受信者が同じ実装詳細（データフォーマット、ライブラリ等）に依存する。

**回避策**: 標準化されたフォーマット（JSON、Protobuf等）を使用し、共有スキーマで管理。

---

#### 2.3.2 機能的な結合（Functional Coupling）

受信者が発行者の機能に依存する。

**例**:
```
販売促進サービス → publish: CampaignActivated
                            ↓ subscribe
                         顧客管理サービス
```

顧客管理サービスはキャンペーンアクティベーションという販売促進サービスの機能に依存している。

**回避策**: Event-Carried State Transferを活用し、受信者が必要な情報を自律的に保持する。

---

#### 2.3.3 時間的な結合（Temporal Coupling）

発行者と受信者が同時にオンラインである必要がある。

**回避策**: メッセージキュー（Apache Kafka、RabbitMQ等）を用いた非同期配信。

---

### 2.4 イベント駆動設計の経験則

1. **Event-Carried State Transferの活用**: 共用サービスから状態を投影し、受信者の自律性を高める。

```
販売促進サービス
       ↓ subscribe（状態投影）
   顧客管理サービス（共用）
       ↓ subscribe（状態投影）
広告最適化サービス
```

2. **Event Notificationの選択的利用**: リアルタイム性が必要で、かつ詳細情報が頻繁に変わる場合。

3. **Domain Eventの中心配置**: 業務的な意味を保ちながら、適切な粒度で情報を含める。

4. **Outboxパターンの必須化**: データベーストランザクションとイベント配信の整合性を保証（TACTICAL-PATTERNS.md参照）。

5. **Consumer-Driven Contract**: 受信者が期待するイベントスキーマを定義し、発行者との契約を明確化。

6. **イベントバージョニング**: スキーマ変更時の互換性を保つため、バージョン管理戦略を採用。

7. **冪等性の保証**: at-least-once配信により同じイベントが複数回配信される可能性があるため、受信者は冪等に処理する。

---

### 2.5 DDDとイベント駆動型アーキテクチャの統合

**Domain Event → イベント駆動型アーキテクチャ**:

DDDで定義されたDomain Eventは、そのままイベント駆動型アーキテクチャのイベントとして活用できる。

```csharp
public class Campaign
{
    List<DomainEvent> _events;

    public void Deactivate(string reason)
    {
        IsActive = false;
        var newEvent = new CampaignDeactivated(_id, reason);
        _events.Append(newEvent);
    }
}
```

永続化後、Outboxパターンでメッセージ通信基盤に配信する。

```csharp
public class ManagementAPI
{
    public ExecutionResult DeactivateCampaign(CampaignId id, string reason)
    {
        try
        {
            var campaign = repository.Load(id);
            campaign.Deactivate(reason);
            _repository.CommitChanges(campaign);

            var events = campaign.GetUnpublishedEvents();
            for (IDomainEvent e in events)
            {
                _messageBus.publish(e); // Outboxパターンで実装
            }
            campaign.ClearUnpublishedEvents();
        }
        catch(Exception ex) { ... }
    }
}
```

---

## 3. データメッシュとDDD / Data Mesh and DDD

### 3.1 従来のアプローチと課題

#### 3.1.1 データウェアハウス（Data Warehouse）

**基本コンセプト**:
- 業務データを中央集約型のDWHに統合
- 取り込み時にスタースキーマ（事実テーブル + 特性テーブル）に変換
- SQL的なインターフェースで分析
- BIレポートとダッシュボード生成

**スタースキーマの構造**:
```
       ┌─────────────┐
       │ 特性テーブル │
       │  (顧客)     │
       └──────┬──────┘
              │
┌─────────────┼─────────────┐
│ 特性テーブル│ 事実テーブル │ 特性テーブル
│  (日時)    ├──(売上)─────┤  (製品)
└────────────┘             └─────────────┘
              │
       ┌──────┴──────┐
       │ 特性テーブル │
       │  (店舗)     │
       └─────────────┘
```

**トレードオフ**:

| メリット | デメリット |
|---------|----------|
| データの集中的統合 | ドメイン知識の極端な分割 |
| 専用の分析サイロ隔離 | 統合の脆さ（スキーマ変更時） |
| | 複雑さ（変換パイプライン維持） |
| | 意図した目的に対する機能制限 |
| | 同期化によるボトルネック |

---

#### 3.1.2 データレイク（Data Lake）

**基本コンセプト**:
- データウェアハウスの逆パターン
- 生データをそのまま保存（Load then Transform）
- 事前の変換を最小化
- データサイエンティストが必要時に変換

**トレードオフ**:

| メリット | デメリット |
|---------|----------|
| データウェアハウスより構造化されていない | 関係性の把握が困難 |
| 事前変換が少ない | 場当たり的な変換が必要 |
| 分散アーキテクチャに適している | ドメイン知識の蒸発 |
| | PII（個人情報）の偶発的漏洩リスク |
| | 技術による分割（ドメイン分割ではない） |

**共通課題**:
- **技術による分割**: データをコンテキストから分離
- **パイプラインの脆さ**: 上流システムの変更に追従困難
- **データ陳腐化**: バッチ処理による遅延
- **運用ボトルネック**: データ品質テストが下流に集中

---

### 3.2 データメッシュ（Data Mesh）

#### 3.2.1 定義と背景

**データメッシュ**:
分析データを非中央集権的なやり方で共有、アクセス、管理するためのソシオテクニカルなアプローチ。

**設計思想**:
- マイクロサービス、サービスメッシュ、サイドカーパターンの分析データへの適用
- ドメイン指向の分離を分析データにも拡張
- 業務データと分析データの直交結合を整理

---

#### 3.2.2 データメッシュの4原則

##### 原則1: ドメイン主導のデータ所有権（Domain-Driven Data Ownership）

**定義**: データは、そのデータに最も精通しているドメインが所有し、共有する。

**実装**:
- Bounded Contextごとにデータ所有権
- ピアツーピア方式でのデータアクセス
- 中央管理されたデータレイクやデータウェアハウス、データ専門チームを不要化

**DDDとの統合**:
```
Bounded Context (業務データ) ←1:1対応→ データドメイン (分析データ)
     ↓                                      ↓
サービスが所有                        データプロダクト量子（DPQ）が所有
```

---

##### 原則2: プロダクトとしてのデータ（Data as a Product）

**定義**: データのサイロ化を防ぎ、ドメインのデータ共有を促すため、データを「プロダクト」として扱う。

**データプロダクト量子（DPQ）の構成**:
```
┌────────────────────────────────────┐
│   データプロダクト量子（DPQ）       │
│                                    │
│  ┌──────────────────────────────┐ │
│  │ データ本体                    │ │
│  │ - 事実テーブル                │ │
│  │ - 特性テーブル                │ │
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ メタデータ                    │ │
│  │ - スキーマ                    │ │
│  │ - データ品質指標              │ │
│  │ - データリネージ              │ │
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ アクセスインターフェース      │ │
│  │ - REST API                    │ │
│  │ - ストリーム（Kafka等）       │ │
│  │ - クエリエンドポイント（SQL） │ │
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ 品質保証                      │ │
│  │ - データバリデーション        │ │
│  │ - モニタリング                │ │
│  └──────────────────────────────┘ │
└────────────────────────────────────┘
```

**DPQの種類**:

| 種別 | 役割 | 例 |
|------|------|-----|
| **ソースアラインド（ネイティブ）DPQ** | 協調するマイクロサービスに代わって分析データを提供 | チケット管理サービスのDPQ |
| **集約DPQ** | 複数の入力からデータを同期/非同期で集約 | エキスパート供給DPQ |
| **目的特化DPQ** | 特定の要件に特化（BIレポート、機械学習等） | サプライレコメンデーション |

---

##### 原則3: セルフサービス型データプラットフォーム（Self-Serve Data Infrastructure）

**定義**: ドメインチームがデータプロダクトを自律的に構築・維持できるプラットフォームを提供。

**プラットフォーム機能**:
- データプロダクトの宣言的作成
- 検索・閲覧によるデータプロダクトの発見
- データリネージ・ナレッジグラフの生成・管理
- データパイプライン構築ツール
- データカタログ
- モニタリング・アラート

---

##### 原則4: コンピュテーショナルな連携型統制（Federated Computational Governance）

**定義**: データの所有権が分散しているにもかかわらず、組織全体の統制要件がすべての領域で一貫して満たされることを保証。

**実装**:
- ドメインのデータプロダクトオーナーで構成される連携型意思決定モデル
- ポリシーを自動化し、コードとして各DPQに埋め込む
- サイドカーがアクセスポイント（読み取り/書き込み）でポリシーを実行

**ガバナンス要素**:
- データのコンプライアンス
- セキュリティ（アクセス制御、暗号化）
- プライバシー（PII保護、GDPR対応）
- データ品質基準
- データプロダクトの相互運用性

---

### 3.3 DPQとマイクロサービスの関係

#### 3.3.1 協調量子としてのDPQ

**定義**: 協調するサービスとは運用上分離している独立した量子。

```
┌────────────────────────────────────┐
│   境界づけられたコンテキスト       │
│                                    │
│  ┌──────────────────────────────┐ │
│  │   サービス（業務データ）      │ │
│  │                              │ │
│  │   ┌────────────┐             │ │
│  │   │ 業務ロジック│             │ │
│  │   └────────────┘             │ │
│  │         ↓                    │ │
│  │   ┌────────────┐             │ │
│  │   │ データベースD│             │ │
│  │   └────────────┘             │ │
│  └──────────────────────────────┘ │
│           ↕ 非同期通信・結果整合性  │
│  ┌──────────────────────────────┐ │
│  │   DPQ（分析データ）           │ │
│  │                              │ │
│  │   ┌────────────┐             │ │
│  │   │ 分析モデル  │             │ │
│  │   └────────────┘             │ │
│  │         ↓                    │ │
│  │   ┌────────────┐             │ │
│  │   │ DPQデータ   │             │ │
│  │   └────────────┘             │ │
│  └──────────────────────────────┘ │
└────────────────────────────────────┘
          ↕ 疎な結合（分析量子と通信）
┌────────────────────────────────────┐
│   分析量子（BI・レポート）          │
│   - 複数のDPQから同期/非同期取得   │
│   - SQLインターフェース             │
│   - ストリーム処理                  │
└────────────────────────────────────┘
```

**結合の種類**:
- **協調サービスとDPQ**: 厳格なコントラクト（密な結合）
- **分析量子とDPQ**: 緩いコントラクト（疎な結合）

**通信パターン**:
- DPQへの通信は**常に非同期・結果整合性**
- サガパターン（Parallel Saga / Anthology Saga）を適用
- トランザクション要件を含めない（直交結合の維持）

---

#### 3.3.2 データメッシュ適用判断基準

**データメッシュが適している状況**:
- ✅ マイクロサービスアーキテクチャ
- ✅ トランザクションが適切に管理されている
- ✅ サービス間の隔離性が高い
- ✅ 結果整合性をサポート可能
- ✅ ドメインチームがデータ品質・タイミング・透明性を決定できる

**データメッシュが困難な状況**:
- ❌ 分析データと業務データが常に同期必須
- ❌ 強いACID整合性が必要
- ❌ ドメイン境界が不明確
- ❌ 中央集権的な組織構造

**トレードオフ**:

| メリット | デメリット |
|---------|----------|
| マイクロサービスアーキテクチャに最適 | DPQとのコントラクト調整を必要とする |
| 現代的なアーキテクチャ原則に従っている | 非同期通信と結果整合性を必要とする |
| 分析データと業務データの間に優れた分離 | |
| 慎重に形成されたコントラクトにより疎結合に進化可能 | |

---

### 3.4 イベントストアとデータメッシュの統合

#### 3.4.1 Event Sourcingを前提としたDPQ生成

**データプロダクトの生成フロー**:
```
┌────────────────────────────────────┐
│   イベントストア（Source of Truth） │
│   LeadInitialized                  │
│   → Contacted                      │
│   → FollowupSet                    │
│   → OrderSubmitted                 │
│   → PaymentConfirmed               │
└────────────┬───────────────────────┘
             │ イベントストリーム
             ↓
┌────────────────────────────────────┐
│   投影エンジン（Projection）        │
│   - イベントを購読                  │
│   - 分析モデルに変換                │
└────────────┬───────────────────────┘
             │
             ↓
┌────────────────────────────────────┐
│   分析モデル（事実テーブル）        │
│   事実_見込み客状態                 │
│   - LeadId (PK)                    │
│   - Followups (フォローアップ回数) │
│   - Status (現在ステータス)         │
│   - ConversionTime (成約までの時間)│
└────────────┬───────────────────────┘
             │
             ↓
┌────────────────────────────────────┐
│   データプロダクトAPI               │
│   GET /analytics/leads/conversion  │
│   GET /analytics/leads/funnel      │
└────────────────────────────────────┘
```

---

#### 3.4.2 実装例: エキスパート供給DPQ

**背景**: チケット、アンケート、エキスパートプロフィールのDPQから集約し、供給計画のためのレコメンデーションを提供。

**アーキテクチャ**:
```
┌──────────────┐
│ チケットDPQ  │──┐
└──────────────┘  │
                  │ 非同期イベント配信
┌──────────────┐  │
│ アンケートDPQ│──┼───→ ┌────────────────────┐
└──────────────┘  │     │ エキスパート供給DPQ │
                  │     │ - MLモデル学習      │
┌──────────────┐  │     │ - 日次レコメンデーション│
│プロフィールDPQ│──┘     └────────────────────┘
└──────────────┘               ↓
                        ┌────────────────────┐
                        │ サプライレコメンデーション│
                        └────────────────────┘
```

**ADR: データ完全性保証**:
- 各ソースDPQは、1日分の完全なデータを提供するか、データを提供しない
- 不完全なデータはトレンド分析を歪めるため排除
- 適応度関数: メッセージタイムスタンプのギャップをチェック（1分以上 → 対象外）
- Consumer-Driven Contract: コンシューマー駆動コントラクトの適応度関数を用意

---

### 3.5 DDDとデータメッシュの実践統合

#### 3.5.1 Bounded Context = データドメイン

**マッピング**:
```
Bounded Context: 販売促進
   ↓
データプロダクト:
  1. キャンペーンパフォーマンス分析
  2. 広告素材効果測定
  3. 顧客コンバージョンファネル
```

これらのデータプロダクトは、Event-Sourced Domain ModelまたはEvent-Carried State Transferで生成されたイベントから投影される。

---

#### 3.5.2 導入経験則

1. **Bounded Contextの明確化**: データドメイン境界を定義する前に、戦略的設計でBounded Contextを明確化。

2. **Event-Sourcing優先**: イベント履歴がある場合、DPQ生成が容易。イベントストアをSource of Truthとして活用。

3. **データプロダクトオーナーの設定**: 各DPQに責任者を置き、品質・タイミング・透明性を保証。

4. **段階的導入**: 全社一斉導入ではなく、1つのBounded Contextから開始し、成功パターンを確立。

5. **Consumer-Driven Data Contracts**: データ消費者（分析量子）の要件を起点にDPQを設計。

6. **データリネージの可視化**: イベント → 投影 → 分析モデル → DPQ APIのフローを追跡可能に。

7. **非同期通信の徹底**: DPQへの通信は常に非同期・結果整合性。同期通信は直交結合を破壊する。

8. **プラットフォームチームの設置**: セルフサービス基盤の構築・維持を専任チームが担当。

---

### 3.6 分析データモデルの設計

#### 3.6.1 事実テーブルと特性テーブル

**事実テーブル（Fact Table）**:
- 業務イベント（トランザクション）を記録
- 測定可能な数値データ（売上、数量、時間等）
- 外部キーで特性テーブルと連携

**特性テーブル（Dimension Table）**:
- 事実を説明する属性（顧客、製品、日時、場所等）

**例: サポート案件の分析モデル**

```sql
-- 事実テーブル
CREATE TABLE fact_completed_tickets (
    ticket_id INT PRIMARY KEY,
    expert_key INT,  -- FK to dim_expert
    category_key INT,  -- FK to dim_category
    start_date_key INT,  -- FK to dim_date
    end_date_key INT,  -- FK to dim_date
    customer_key INT,  -- FK to dim_customer
    resolution_time_minutes INT,
    customer_satisfaction_score INT
);

-- 特性テーブル
CREATE TABLE dim_expert (
    expert_key INT PRIMARY KEY,
    expert_id VARCHAR(50),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    email VARCHAR(200),
    is_active BOOLEAN,
    expertise_area VARCHAR(100)
);

CREATE TABLE dim_category (
    category_key INT PRIMARY KEY,
    category_id VARCHAR(50),
    category_name VARCHAR(100)
);

CREATE TABLE dim_date (
    date_key INT PRIMARY KEY,
    full_date DATE,
    year INT,
    quarter INT,
    month INT,
    week INT,
    day_of_week INT
);
```

---

#### 3.6.2 スタースキーマの非正規化

**目的**: クエリのシンプル化とパフォーマンス向上。

**設計原則**:
- 意図的に非正規化
- 複雑なJOINを削減
- シンプルなビジネスロジック
- 高速なクエリと集約
- マルチディメンションクエリの容易化

---

## まとめ

| 技法 | DDDとの関係 | 活用ポイント |
|---|---|---|
| マイクロサービス | Bounded ContextとAggregateが境界候補 | 深いモジュール設計、Context Mapping |
| イベント駆動型アーキテクチャ | Domain Eventがイベントのソース | Event-Carried State Transfer、Outbox |
| データメッシュ | Bounded Context = データドメイン | イベントストア活用、データプロダクト化 |

DDDの戦略的設計と戦術的パターンは、これらの技法と組み合わせることで、スケーラブルで保守性の高いシステムを実現する。
