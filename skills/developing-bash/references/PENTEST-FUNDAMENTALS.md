# ペンテスト用 Bash スクリプティング基礎

倫理的セキュリティテストにおける Bash スクリプティングの原則・ラボ環境構築・I/O 操作・基礎文法の実践ガイド。

---

## 1. ペンテスト自動化の意義

### 1.1 自動化が生む効率性と精度

手動で実施すると時間とミスのリスクが高い繰り返し作業を、スクリプト化することで次の利益が得られる:

| 課題 | 手動の問題 | スクリプト化の利益 |
|------|-----------|-------------------|
| ポートスキャン (1,000 ホスト) | 3 時間以上 + 疲労によるミス | 10〜15 分 + 一貫した結果 |
| サブドメイン列挙 | 抜け漏れが発生しやすい | ツールを組み合わせて網羅的に収集 |
| 脆弱性スキャン (複数ホスト) | 手順のぶれが生じる | 同一手順を全ホストに適用可能 |
| ログ分析 | 目視では見落としが多い | パターンマッチで自動抽出 |

**アセスメントにおける自動化のループ:**

```bash
# 自動化の基本パターン: 発見 → スキャン → 列挙 → 記録
while IFS= read -r target; do
    # 存在確認
    if ping -c 1 -W 1 "$target" &>/dev/null; then
        # 詳細スキャン（認可済みターゲットのみ）
        nmap -sV -sC -T4 -oN "${target}.nmap" "$target"
    fi
done < authorized_targets.txt
```

### 1.2 スケーラビリティ

実際のアセスメントでは数百〜数千のデバイスを対象とする。スクリプトにより:
- **広範囲な対象への一貫した適用**: 全ターゲットに同じ手順を漏れなく実施
- **ツールの連携**: Nmap → Enum4Linux → 脆弱性スキャナーを自動で連鎖
- **監査可能な記録**: ログ出力・タイムスタンプにより再現性と監査性を確保

---

## 2. 倫理的考慮事項

### 2.1 認可された攻撃のみを実施する

スクリプトによる自動化は影響範囲が大きい。**認可されていないターゲットへの実行は違法**。
スクリプト内に認可チェックを組み込むことで、事故的な逸脱を防止する:

```bash
#!/usr/bin/env bash
set -euo pipefail

# 認可済みターゲットリストによるホワイトリスト検証
AUTHORIZED_TARGETS=("192.168.1.10" "10.0.0.5" "172.16.0.22")
TARGET="${1:?ターゲット IP を指定してください}"

is_authorized() {
    local target="$1"
    for authorized in "${AUTHORIZED_TARGETS[@]}"; do
        [[ "$target" == "$authorized" ]] && return 0
    done
    return 1
}

if ! is_authorized "$TARGET"; then
    echo "エラー: $TARGET は認可されていません。処理を中止します。" >&2
    exit 1
fi

echo "認可済みターゲット: $TARGET に対して処理を開始します。"
```

### 2.2 リソース過負荷への配慮

過度に積極的なスクリプトはターゲットシステムのパフォーマンスを低下させたり、
サービス障害を引き起こす可能性がある。スコープを守ること:

| 配慮事項 | 対策 |
|---------|------|
| スキャン速度 | Nmap `-T` オプションで速度を制限 (`-T3` 推奨) |
| 並列数の上限 | GNU Parallel で同時実行数を `--jobs 50%` に制限 |
| ブルートフォース | レート制限を設け、アカウントロックアウトを避ける |
| ネットワーク帯域 | スキャン間隔を設けて帯域を圧迫しない |

### 2.3 収集データの安全な取り扱い

アセスメント中に収集した機密データは適切に保護・削除する:

```bash
#!/usr/bin/env bash
set -euo pipefail

# 収集データの暗号化・安全転送・ローカルコピー削除
secure_transfer() {
    local data_file="$1"
    local remote_host="$2"
    local remote_path="$3"

    # AES-256 で暗号化
    gpg --symmetric --cipher-algo AES256 "$data_file"

    # セキュアな転送
    scp "${data_file}.gpg" "${remote_host}:${remote_path}/"

    # ローカルのオリジナルを安全削除
    shred -zuv "$data_file"
    rm -f "${data_file}.gpg"
}
```

---

## 3. ラボ環境構築

### 3.1 構成概要

安全な練習環境として以下の構成を推奨する:

| コンポーネント | 役割 | 用途 |
|--------------|------|------|
| Kali Linux VM | 攻撃マシン | ペンテストツール群が事前インストール済み |
| Metasploitable 2 VM | 脆弱なターゲット | 意図的に脆弱なサービスを提供 |
| VirtualBox | ハイパーバイザー | 仮想マシンを管理 |
| Host-Only Network | 分離ネットワーク | 外部への影響を完全に遮断 |

### 3.2 ハードウェア要件

| 項目 | 最小要件 | 推奨 |
|------|---------|------|
| CPU | 仮想化対応 (VT-x/AMD-V) | 4 コア以上 |
| RAM | 6〜8 GB | 16 GB 以上 |
| ストレージ | HDD 50 GB 以上 | SSD 100 GB 以上 |
| ネットワーク | - | 無線テスト用: monitor mode 対応アダプタ |

### 3.3 ネットワーク設計

```
[Kali Linux VM]          [Metasploitable 2 VM]
 192.168.5.101   ←───→    192.168.5.102
         │
  Host-Only Adapter (192.168.5.0/24)
         │
  インターネット接続なし（Metasploitable 2 は完全隔離）
```

**重要**: Metasploitable 2 は意図的に脆弱であるため、
インターネットに接続するネットワークには絶対に接続しないこと。

### 3.4 Vagrant による自動プロビジョニング

手動セットアップの代わりに Vagrant を使うと環境を自動化・再現可能にできる:

```ruby
# Vagrantfile の基本構成例
Vagrant.configure("2") do |config|
  # 攻撃マシン: Kali Linux
  config.vm.define "kali" do |kali|
    kali.vm.box = "kalilinux/rolling"
    kali.vm.network "private_network", ip: "192.168.52.101"
    kali.vm.provider "virtualbox" do |vb|
      vb.memory = 4096
      vb.cpus   = 2
    end
  end

  # ターゲット: Metasploitable 2
  config.vm.define "target" do |target|
    target.vm.box     = "Sliim/metasploitable2"
    target.vm.network "private_network", ip: "192.168.52.102"
    target.vm.provider "virtualbox" do |vb|
      vb.memory = 1024
      vb.cpus   = 1
    end
  end
end
```

```bash
# 環境の起動・停止
vagrant up        # 両 VM を起動
vagrant halt      # 停止（状態を保持）
vagrant destroy   # 完全削除
vagrant suspend   # スリープ（高速な再開が可能）
```

---

## 4. パフォーマンス最適化

### 4.1 GNU Parallel による並列実行

複数ターゲットの処理を同時に実行することで、スキャン時間を大幅に短縮できる:

```bash
#!/usr/bin/env bash
set -euo pipefail

# 関数として定義し、GNU Parallel で並列実行
port_scan() {
    local target_ip="$1"
    local output_file="${target_ip}.ports"
    nmap -p- --open -oG - "$target_ip" \
        | awk '/open/{print $1}' \
        | cut -d'/' -f1 \
        | tr '\n' ',' \
        | sed 's/,$//' > "$output_file"
    echo "完了: $target_ip -> $output_file"
}
export -f port_scan

# CPU コアの 50% を使用して並列スキャン
parallel --jobs 50% port_scan ::: "${TARGETS[@]}"
```

**判断基準:**

| ツール/手法 | 適した場面 |
|-----------|----------|
| GNU Parallel | 独立したタスクを並列実行 (スキャン、列挙等) |
| Masscan | 大規模ネットワークの高速ポートスキャン |
| バックグラウンドジョブ (`&` + `wait`) | シンプルな並列化 |
| 順次実行 | 前の結果が次に必要な場合 |

### 4.2 キャッシュ戦略

同じサブドメイン列挙を何度も実行することを避けるため、結果をキャッシュする:

```bash
#!/usr/bin/env bash
set -euo pipefail

get_subdomains() {
    local domain="$1"
    local cache_file="${domain}.subdomains.cache"

    # キャッシュが存在する場合は再利用
    if [[ -f "$cache_file" ]]; then
        echo "[キャッシュ] $domain のサブドメインを読み込みました" >&2
        cat "$cache_file"
        return 0
    fi

    # 列挙を実行してキャッシュに保存
    echo "[実行] $domain のサブドメインを列挙します..." >&2
    local results
    results=$(subfinder -d "$domain" -silent | sort -u)
    echo "$results" > "$cache_file"
    echo "$results"
}
```

### 4.3 バックグラウンドジョブの制御

```bash
#!/usr/bin/env bash
set -euo pipefail

TARGETS=("192.168.1.101" "192.168.1.102" "192.168.1.103")
PIDS=()

# バックグラウンドで並列スキャン
for target in "${TARGETS[@]}"; do
    nmap -sV -p- -oN "${target}.nmap" "$target" &
    PIDS+=($!)
done

# 全バックグラウンドジョブの完了を待機
for pid in "${PIDS[@]}"; do
    wait "$pid" || echo "警告: PID $pid が異常終了しました" >&2
done

echo "全スキャン完了"
```

---

## 5. セキュリティ文脈の I/O 操作

### 5.1 スキャン結果のリダイレクト

```bash
# 標準出力をファイルに保存（上書き）
nmap 192.168.1.100 > scan_results.txt

# 標準出力をファイルに追記
nmap 192.168.1.101 >> scan_results.txt

# 標準エラーを分離して保存
nmap 192.168.1.102 2> scan_errors.txt

# 標準出力と標準エラーを両方保存
nmap 192.168.1.103 &> all_output.txt

# Permission denied エラーを除去して SUID バイナリを検索
find / -perm -u=s -type f 2>/dev/null
```

### 5.2 ファイルからターゲットリストを読み込む

```bash
#!/usr/bin/env bash
set -euo pipefail

# ターゲットリストファイルから読み込んでスキャン
while IFS= read -r ip; do
    [[ -z "$ip" || "$ip" =~ ^# ]] && continue  # 空行・コメントをスキップ
    echo "スキャン開始: $ip"
    nmap -sV -Pn -oN "${ip}.nmap" "$ip"
done < targets.txt
```

### 5.3 awk / sed / grep のペンテスト活用例

**awk: 構造化データのフィールド抽出**

```bash
# /etc/passwd からユーザー名と UID を抽出
awk -F ':' '{print $1, $3}' /etc/passwd

# Nmap の grep 出力からオープンポートだけを抽出
nmap -sn -oG - 192.168.1.0/24 | awk '/Up/{print $2}'
```

**sed: 設定ファイルの編集と出力の整形**

```bash
# コメント行 (#) を除去してクリーンな出力を得る
sed '/^#/d' /etc/hosts

# 出力の不要なスペースを除去
nmap -sV 192.168.1.1 | sed 's/  */ /g'
```

**grep: パターンマッチによる情報抽出**

```bash
# ディレクトリ内のパスワード関連キーワードを再帰的に検索
grep -r 'password\|passwd\|secret' /path/to/directory 2>/dev/null

# リッスンしているポートを一覧表示
netstat -antup | grep 'LISTEN'

# ログからユーザーログイン成功だけを抽出
grep 'User login successful' access.log | awk -F ': ' '{print $3}'
```

**ツール連携パイプラインの例:**

```bash
# Nmap → awk で生存ホストを抽出 → xargs でサービス詳細スキャン
nmap -sn -oG - 192.168.1.0/24 \
    | awk '/Up/{print $2}' \
    | xargs -I{} nmap -sV -oN "{}.services" {}
```

---

## 6. Bash 基礎のペンテスト応用

### 6.1 変数とコマンド置換

```bash
#!/usr/bin/env bash
set -euo pipefail

TARGET_IP="192.168.1.100"
TARGET_PORT=80
SCRIPT_NAME=$(basename "$0")

# コマンド置換で結果を変数に格納
OPEN_PORTS=$(nmap -p- --open -oG - "$TARGET_IP" \
    | awk '/open/{print $1}' | cut -d'/' -f1 | tr '\n' ',')

echo "[$SCRIPT_NAME] $TARGET_IP のオープンポート: $OPEN_PORTS"
```

### 6.2 関数による再利用可能なモジュール化

```bash
#!/usr/bin/env bash
set -euo pipefail

# TCP 接続スキャン関数（認可されたターゲット専用）
tcp_connect_scan() {
    local target_ip="$1"
    local output_file="${target_ip}.ports"

    nmap -sT -p- --open --reason "$target_ip" \
        | grep '^[0-9]' \
        | cut -d '/' -f 1 \
        | tr '\n' ',' \
        | sed 's/,$//' > "$output_file"

    echo "$target_ip のオープンポート: $(cat "$output_file")"
}

# 複数ターゲットに関数を適用
TARGETS=("192.168.1.101" "192.168.1.102")
for target in "${TARGETS[@]}"; do
    tcp_connect_scan "$target"
done
```

### 6.3 制御構造によるスキャンロジック

```bash
#!/usr/bin/env bash
set -euo pipefail

TARGET_IP="${1:?ターゲット IP を指定してください}"
PORTS=(80 443 22 21 3389)

for port in "${PORTS[@]}"; do
    if nmap -p "$port" --open "$TARGET_IP" | grep -q 'open'; then
        echo "[OPEN]   ポート $port ($TARGET_IP)"
    else
        echo "[CLOSED] ポート $port ($TARGET_IP)"
    fi
done
```

### 6.4 ワンライナー活用例

ターミナルから素早く実行できるセキュリティ調査用ワンライナー:

```bash
# SUID ビットが設定されたファイルを列挙
sudo find / -perm /4000 -type f 2>/dev/null

# システムログのリアルタイム監視（エラー・警告を強調表示）
tail -f /var/log/syslog | grep --color 'error\|warning'

# nc を使った簡易ポートスキャン（認可済みホストのみ）
for port in {20..25} 80 443 8080 8443; do
    nc -zvw1 "$TARGET_HOST" "$port" 2>&1 | grep -v 'refused'
done

# リッスン中のサービス一覧
ss -tlnp | grep LISTEN
```

### 6.5 引数処理とバリデーション

```bash
#!/usr/bin/env bash
set -euo pipefail

usage() {
    echo "使用方法: $0 -t <ターゲット> -p <ポート>"
    echo "  -t  スキャン対象の IP アドレス"
    echo "  -p  スキャン対象のポート番号 (1-65535)"
    exit 1
}

# getopt による引数解析
PARSED=$(getopt -o "t:p:" -- "$@") || usage
eval set -- "$PARSED"

TARGET=""
PORT=""

while true; do
    case "$1" in
        -t) TARGET="$2"; shift 2 ;;
        -p) PORT="$2";   shift 2 ;;
        --) shift; break ;;
        *)  usage ;;
    esac
done

# 入力バリデーション
[[ -z "$TARGET" || -z "$PORT" ]] && usage
[[ "$PORT" =~ ^[0-9]+$ ]] && (( PORT >= 1 && PORT <= 65535 )) || {
    echo "エラー: ポート番号は 1〜65535 の整数で指定してください" >&2
    exit 1
}

echo "スキャン: $TARGET:$PORT"
nmap -p "$PORT" -sV "$TARGET"
```

---

## 関連ガイド

このリファレンスの発展的なトピックについては以下を参照:

- **[SECURITY.md](./SECURITY.md)** - 入力サニタイゼーション・コマンドインジェクション対策・認証情報管理
- **[HARDENING.md](./HARDENING.md)** - TOCTOU 競合・ファイルパーミッション・攻撃面最小化
- **[IO-PIPELINES.md](./IO-PIPELINES.md)** - パイプライン設計・リダイレクト・tee・プロセス置換
- **[PARALLELISM.md](./PARALLELISM.md)** - GNU Parallel・ジョブ制御・非同期実行パターン
- **[TEXT-PROCESSING.md](./TEXT-PROCESSING.md)** - awk・sed・grep の高度な活用テクニック
