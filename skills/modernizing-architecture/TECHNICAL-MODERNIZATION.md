# 技術的モダナイゼーション（Technical Modernization）

疎結合設計、マイグレーションパターン、Internal Developer Platform、Data Meshをカバーする。

---

## 1. カップリングの種類と強度

### 統合強度の分類（弱 → 強）

| 種別 | 知っている範囲 | リスク | 例 |
|------|-------------|--------|-----|
| **Functional** | コンポーネントの存在のみ | 最低 | イベント発行（Fire-and-forget） |
| **Model** | 公開インターフェース | 低 | REST API呼び出し |
| **Implementation** | 内部実装の詳細 | 高 | 共有DB、内部スキーマ依存 |
| **Intrusive** | 潜在的にすべて | 最高 | 直接的なコード参照、モンキーパッチ |

### Local vs Global Complexity

| 種類 | 説明 | 対策 |
|------|------|------|
| **Local Complexity** | 1つのサブシステム内の複雑さ | リファクタリング、DDD |
| **Global Complexity** | サブシステム間の相互作用の複雑さ | 境界設計、カップリング削減 |

> 局所的な複雑さの削減が全体的な複雑さを増加させることがある（逆も然り）。トレードオフを意識する。

---

## 2. アーキテクチャフローの設計

### Model Exploration Whirlpool

ドメインモデルの設計は直線的ではなく、反復的な探索プロセス:

```
シナリオ探索 → モデル設計 → コード実験 → 新たな洞察 → モデル改善 → ...
```

### Domain Message Flow Modeling

サブシステム間のメッセージフロー（コマンド、イベント、クエリ）を可視化:

1. **サブシステムをカードとして配置** — 名前、責任、主要な概念
2. **メッセージフローを描く** — サブシステム間のコマンド/イベント/クエリ
3. **フローを検証** — シナリオを歩いて抜けや矛盾を発見
4. **境界を調整** — フローから境界の改善を導出

### 個別サブシステムの設計

**キャンバスアプローチ** — 各サブシステムの設計を1枚のキャンバスにまとめる:

| セクション | 内容 |
|-----------|------|
| **名前** | サブシステムの名称 |
| **責任** | このサブシステムが担うビジネス機能 |
| **インバウンド** | 受け取るコマンド、クエリ |
| **アウトバウンド** | 発行するイベント、呼び出すAPI |
| **Ubiquitous Language** | このサブシステム固有の用語 |
| **ビジネスルール** | 主要なビジネスロジック |
| **非機能要件** | パフォーマンス、スケーラビリティ等 |

---

## 3. モダナイゼーション戦略セレクター

各サブシステムの最適なモダナイゼーション戦略を決定する2軸フレームワーク。

### X軸: 行動変更レベル

| レベル | 説明 |
|--------|------|
| **Expose** | 既存機能をAPIやイベントとして公開。最小限の変更 |
| **Polish** | 低リスクな技術的負債の整理 |
| **Replicate** | 既存機能を維持しつつ全面書き直し |
| **Remodel** | ドメインモデルを完全に再設計 |
| **Rethink** | ゼロからの再構築。ユーザーリサーチとドメイン発見から |

### Y軸: 技術変更レベル

| カテゴリ | 例 |
|---------|-----|
| **Infrastructure** | オンプレ → クラウド、VM → サーバーレス |
| **Programming Language** | C# .NET → Kotlin on JVM |
| **Data Storage** | Oracle SQL → MongoDB + RabbitMQ |
| **Libraries/Frameworks** | レガシーフレームワーク → モダンフレームワーク |

### 代表的な戦略

| 戦略 | X軸 | Y軸 | ROI |
|------|-----|-----|-----|
| **Sunset** | — | — | 維持コスト削減 |
| **Maintain** | — | 最小 | 現状維持 |
| **Legacy Encapsulate** | Expose | 最小 | API経由で既存価値を活用 |
| **Legacy Polish** | Polish | 最小 | 低コストの改善 |
| **Lift and Shift** | — | インフラ | インフラコスト最適化 |
| **Lift and Reshape** | Polish | インフラ+ | 漸進的改善 |
| **Extract and Remodel** | Remodel | 最小 | ドメイン最適化 |
| **Rehost and Remodel** | Remodel | インフラ+ | 全面的な刷新 |
| **Total Modernization** | Rethink | 全面 | 最大だが最もコスト高 |

---

## 4. マイグレーションパターン

### Strangler Fig

段階的にレガシーを新システムで置換する最も一般的なパターン:

```
[Router]
   ├─→ Legacy System（徐々に縮小）
   └─→ Modernized Subsystems（徐々に拡大）
```

**リスク管理:**
| リスク | 対策 |
|--------|------|
| データ同期 | Change Data Capture (CDC)、イベント駆動同期 |
| ルーティング複雑化 | 明確なルーティングルールとモニタリング |
| 両方のシステムの維持コスト | 移行の迅速化、明確なカットオーバー計画 |

### Branch by Abstraction

抽象レイヤーを挟んで段階的に実装を切り替え:

```
Step 1: 抽象化レイヤーを挿入
Step 2: 新しい実装を作成
Step 3: トラフィックを段階的に切替
Step 4: 旧実装を削除
```

### Parallel Running

新旧システムを並行稼働し、結果を比較して検証:

| 段階 | 内容 |
|------|------|
| **Shadow Mode** | 新システムは処理するが結果は使わない |
| **Canary** | 少量のトラフィックのみ新システムに |
| **Gradual Rollout** | 段階的に新システムのトラフィックを増加 |
| **Full Cutover** | 完全に新システムに切替 |

### Bubble Context

新しいBounded Contextをレガシーの横に配置し、Anti-Corruption Layer (ACL)で接続:

```
[Legacy System] ←─── ACL ───→ [Bubble Context（新）]
```

---

## 5. 現状の複雑さの評価

マイグレーション戦略を決定する前に、現状の複雑さを評価する:

| 評価観点 | 高い場合のリスク |
|---------|----------------|
| **コードの複雑さ** | リファクタリングコスト増大 |
| **データの複雑さ** | マイグレーション期間延長 |
| **統合の複雑さ** | 予期せぬ障害 |
| **ドメイン知識の欠如** | 要件の見落とし |
| **テストカバレッジの低さ** | リグレッションリスク |

---

## 6. Internal Developer Platform (IDP)

### Developer Experience (DX) の目標

| 目標 | ベンチマーク |
|------|------------|
| **Zero to Production** | 新アプリを数時間で本番デプロイ |
| **Continuous Delivery** | フリクションのないデプロイパイプライン |
| **Delightful Onboarding** | 新メンバーが数日で生産的に |
| **Frictionless Local Dev** | ローカル環境のセットアップが簡単 |

### プラットフォームケイパビリティ

| ケイパビリティ | 説明 |
|-------------|------|
| **Golden Paths** | 推奨される技術スタックとテンプレート |
| **Pipelines & Environments** | CI/CDパイプラインと環境管理 |
| **Observability** | ログ、メトリクス、トレーシング |
| **Software Catalog** | アプリケーション/サービスの一覧と依存関係 |
| **Security & Compliance** | セキュリティスキャン、ポリシー適用 |
| **API Management** | API Gateway、ドキュメント |
| **FinOps** | クラウドコストの可視化と最適化 |

### Platform as a Product

| 原則 | 説明 |
|------|------|
| **内部顧客を持つ** | 開発チームが「顧客」。彼らのニーズを理解する |
| **プロダクトマネジメント** | バックログ、ロードマップ、フィードバックループ |
| **適切な人員配置** | 少なすぎると品質低下、多すぎるとオーバーエンジニアリング |
| **Build vs Curate** | すべて自作せず、OSS/SaaSを組み合わせて提供 |
| **標準化 vs 柔軟性** | 80%はGolden Path、20%は柔軟性を許容 |

---

## 7. Data Mesh

### 4つの原則

| 原則 | 説明 |
|------|------|
| **Domain Ownership** | データの所有権をドメインチームに分散 |
| **Data as a Product** | データを製品として扱い、品質・発見可能性を保証 |
| **Self-serve Data Platform** | チームがデータ製品を自律的に構築できるプラットフォーム |
| **Federated Computational Governance** | 分散したガバナンスを計算的に実施 |

### Data Quantum（データの最小価値単位）

| コンポーネント | 説明 |
|-------------|------|
| **Input Port** | データの取り込み口 |
| **Output Port** | データの提供口 |
| **Transformation** | データの変換ロジック |
| **Data Contract** | データの品質・スキーマ・SLAの契約 |
| **Storage** | データの永続化 |

### Experience Planes

| プレーン | 対象 | 提供するもの |
|---------|------|------------|
| **Infrastructure Experience** | プラットフォームチーム | インフラのプロビジョニング、セキュリティ |
| **Data Product Experience** | ドメインチーム | データ製品の構築・公開ツール |
| **Mesh Experience** | データ消費者 | データ製品の発見・利用 |

### Data Contract

データ製品の品質保証の核:

| 要素 | 内容 |
|------|------|
| **Schema** | データの構造定義 |
| **SLA** | 可用性、鮮度、レイテンシの保証 |
| **Quality** | 完全性、正確性、一貫性の基準 |
| **Ownership** | 責任チームと連絡先 |
| **Lineage** | データの出自と変換履歴 |
