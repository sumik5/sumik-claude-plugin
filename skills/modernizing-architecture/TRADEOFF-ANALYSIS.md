# アーキテクチャトレードオフ分析

分散アーキテクチャにおけるトレードオフを体系的に分析し、「最悪でない」意思決定を導くための実践的フレームワーク。

---

## 核心メッセージ

> アーキテクトが行える最善のデザインとは、**少なくとも最悪でないトレードオフの集合**だ。
>
> どれか1つのアーキテクチャ特性の実現だけに特化するのではなく、**競合するすべてのアーキテクチャ特性のバランスを取る**こと。これこそが、プロジェクトを成功に導く。

「ベスト（最善）」という言葉は、設計の中で競合する要素を可能な限り最大化することを意味する。しかし、ソフトウェアアーキテクチャにおいて、すべてを最大化することは不可能だ。

---

## 1. トレードオフ分析の基礎

### 1.1 なぜトレードオフ分析が必要か

**アーキテクトが抱える問題の特性:**
- 組織の環境や状況と完全に融合しており、ユニークであることが多い
- 他の誰かがまったく同じシナリオに遭遇する可能性は低い
- Googleで答えを探すことができない
- 「銀の弾丸」は存在しない

**ベストプラクティスの限界:**
- 良い解決策がない問題が広く存在している
- 解決策は厄介な一連のトレードオフを持っている
- もともとの問題とほぼ同じくらい厄介なことが多い

### 1.2 トレードオフ分析の3ステップ

```
Step 1: どの部分が互いに絡み合っているかを見つける
           ↓
Step 2: それらがどのように結合しているかを分析する
           ↓
Step 3: 変更時にその結合がどんな影響をもたらすかを見極め、
        トレードオフを評価する
```

### 1.3 ADR（Architecture Decision Record）による文書化

アーキテクチャ決定を文書化する最も効果的な方法。短いテキストファイル（1-2ページ）で構成される。

**ADRフォーマット:**

```markdown
## ADR: [アーキテクチャ決定を含む短い名詞句]

**コンテキスト**
問題点を簡潔に1-2文で説明し、いくつかの案を列挙する。

**決定**
アーキテクチャ決定とその根拠を記述する。

**影響**
アーキテクチャ決定が適用されることによる影響を記述する。
検討されたトレードオフについても説明する。
```

### 1.4 アーキテクチャ適応度関数

**定義:**
何らかのアーキテクチャ特性やアーキテクチャ特性の組み合わせに対して、客観的な整合性評価を行う**あらゆる仕組み**。

**重要な要素:**

| 要素 | 説明 |
|------|------|
| **あらゆる仕組み** | 専用テストライブラリ、監視、カオスエンジニアリング等 |
| **客観的な整合性評価** | 測定可能な客観的な値を定める必要がある |
| **特性の組み合わせ** | アトミック（単一特性）またはホリスティック（組み合わせ） |

**適応度関数のスコープ:**

- **アトミック**: 単一のアーキテクチャ特性のみを扱う（例: コンポーネント循環チェック）
- **ホリスティック**: アーキテクチャ特性の組み合わせを検証（例: セキュリティとパフォーマンスのバランス）

**適応度関数 vs ユニットテスト:**

判断基準: **「このテストを実行するのにドメインの知識は必要となるか？」**

- **Yes** → ユニットテスト・機能テスト・ユーザー受入テスト
- **No** → 適応度関数

**実装例（循環依存チェック）:**

```java
public class CycleTest {
    private JDepend jdepend;

    @BeforeEach
    void init() {
        jdepend = new JDepend();
        jdepend.addDirectory("/path/to/project/persistence/classes");
        jdepend.addDirectory("/path/to/project/web/classes");
    }

    @Test
    void testAllPackages() {
        Collection packages = jdepend.analyze();
        assertEquals("Cycles exist", false, jdepend.containsCycles());
    }
}
```

**実装例（レイヤー統制）:**

```java
layeredArchitecture()
    .layer("Controller").definedBy("..controller..")
    .layer("Service").definedBy("..service..")
    .layer("Persistence").definedBy("..persistence..")
    .whereLayer("Controller").mayNotBeAccessedByAnyLayer()
    .whereLayer("Service").mayOnlyBeAccessedByLayers("Controller")
    .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Service")
```

---

## 2. Architecture Quantum（アーキテクチャ量子）

### 2.1 定義

**Architecture quantum（アーキテクチャ量子）:**
高度な機能的凝集、高度な静的結合、同期/非同期による動的結合を持つ、**独立してデプロイが可能なアーティファクト**。

一般的な例: あるワークフロー内の整ったマイクロサービス。

### 2.2 結合の2種類

| 結合タイプ | 説明 | 評価タイミング |
|----------|------|--------------|
| **静的結合** | アーキテクチャ内の静的な依存関係がコントラクトによってどう解決されるか | ビルド時 |
| **動的結合** | 実行時に量子がどのように通信するか（同期または非同期） | 実行時 |

**簡単な説明:**
- **静的結合**: サービスがどのように**つながっている**か
- **動的結合**: サービスが実行時に互いをどのように**呼び出す**か

### 2.3 独立してデプロイ可能

アーキテクチャ量子を構成する、独立してデプロイ可能な単位。

**量子数の例:**

| アーキテクチャスタイル | 量子数 | 理由 |
|-------------------|-------|------|
| モノリシック（レイヤード等） | 1 | 単一のユニットとしてデプロイ、単一DB |
| サービスベース | 1 | サービスは分離されているが単一DB |
| メディエーター型EDA | 1 | オーケストレーターと単一DBが結合点 |
| ブローカー型EDA（単一DB） | 1 | 単一DBが結合点 |
| ブローカー型EDA（複数DB、依存なし） | 複数 | 各データストアに依存するサービス群が独立 |
| マイクロサービス | 複数 | 各サービスが独自の量子を形成 |

**ユーザーインターフェイスの影響:**

- **密結合UI**: バックエンドサービスと密結合 → 単一量子
- **マイクロフロントエンド**: 各サービス + UI コンポーネントが量子を形成 → 複数量子

### 2.4 高度な機能的凝集

関連する要素（クラス、コンポーネント、サービス等）が構造的に近接していること。

**ドメイン駆動設計との対応:**
技術的な定義は、DDDの**境界づけられたコンテキスト**の目標（特定ドメインのワークフローを実行するデータと振る舞い）に重なる。

### 2.5 高度な静的結合

アーキテクチャ量子内の要素が密に結び付けられていること。コントラクトの側面。

**結合点の例:**
- OS、フレームワーク、ライブラリ
- データベース、検索エンジン、クラウド環境
- メッセージングインフラ（メッセージブローカー等）

**静的結合図の作成に必要な情報:**
- OS・コンテナの依存関係
- 推移的な依存関係管理によって提供される依存関係
- データベース、検索エンジン等の永続的な依存関係
- サービスが自己起動するために必要なアーキテクチャ統合点
- 他の量子との通信を可能にするメッセージングインフラ

### 2.6 動的な量子結合

実行時の同期結合。分散アーキテクチャ内でワークフローを形成するために相互作用するという振る舞い。

**動的結合の3次元:**

| 次元 | 説明 |
|------|------|
| **通信** | 使用される接続の種別（同期もしくは非同期） |
| **整合性** | ワークフローがアトミックである必要があるか、それとも結果整合性を備えていれば良いか |
| **調整** | ワークフローの実現がオーケストレーターによるものか、それともコレオグラフィに基づくサービス間通信によるものか |

#### 2.6.1 通信

**同期通信:**
- リクエスト送信側はリクエスト受信側からの応答を待つ必要がある
- リクエスト受信側は値を返すまで**ブロック**する

**非同期通信:**
- リクエスト送信側は、メッセージキュー等を介してメッセージを送り、処理を継続する
- 応答が必要な場合は、応答キューを使用して非同期的に結果を返す

#### 2.6.2 整合性

**アトミックトランザクション:**
- リクエストの処理がすべて実行されるか、あるいはまったく実行されないことを保証

**結果整合性:**
- 一時的な不整合を許容し、最終的に整合性が取れる

#### 2.6.3 調整

**オーケストレーション:**
- 単一のサービス（オーケストレーター）がワークフローの調整を担当

**コレオグラフィ:**
- オーケストレーターが存在せず、ワークフロー内のサービスがワークフローを調整する責務を共有

### 2.7 動的結合パターンのマトリクス

8つの組み合わせに基づく基本パターン:

| パターン名 | 通信 | 整合性 | 調整 | 結合度 |
|----------|------|--------|------|--------|
| **エピックサーガ (sao)** | 同期 | アトミック | オーケストレーション | とても高い |
| **伝言ゲームサーガ (sac)** | 同期 | アトミック | コレオグラフィ | 高い |
| **おとぎ話サーガ (seo)** | 同期 | 結果整合性 | オーケストレーション | 高い |
| **タイムトラベルサーガ (sec)** | 同期 | 結果整合性 | コレオグラフィ | 中程度 |
| **ファンタジーサーガ (aao)** | 非同期 | アトミック | オーケストレーション | 高い |
| **ホラーストーリーサーガ (aac)** | 非同期 | アトミック | コレオグラフィ | 中程度 |
| **パラレルサーガ (aeo)** | 非同期 | 結果整合性 | オーケストレーション | 低い |
| **アンソロジーサーガ (aec)** | 非同期 | 結果整合性 | コレオグラフィ | とても低い |

---

## 3. モジュール化の推進要因

### 3.1 ビジネス上の推進要因

**主な推進要因:**
- **市場投入速度**（Time to Market）
- **市場での競争優位性**

**推進要因の関係:**

```
市場投入速度 ← アジリティ ← 保守性、テスト性、デプロイ性
                    ↓
競争優位性 ← アジリティ + スケーラビリティ + 耐障害性
```

### 3.2 技術上の推進要因

#### 3.2.1 保守性（Maintainability）

機能の追加、変更、削除、メンテナンスパッチやフレームワークアップグレードの適用が容易である性質。

**評価指標:**
- コンポーネントの結合度（低いほど良い）
- コンポーネントの凝集度（高いほど良い）
- 循環的複雑度（低いほど良い）
- コンポーネントのサイズ（適切なサイズであること）
- ドメインによる分割（技術による分割より優れる）

**変更範囲の比較:**

| アーキテクチャ | 変更範囲 | チーム調整 |
|--------------|---------|-----------|
| モノリシックレイヤード | アプリケーションレベル | 3+ チーム |
| サービスベース | ドメインレベル | 1-2 チーム |
| マイクロサービス | 機能レベル | 1 チーム |

#### 3.2.2 テスト性（Testability）

テストのしやすさだけでなく、テストの**網羅性**も含む。

**アーキテクチャとテスト性:**
- **モノリシック**: テスト範囲が広大、実行時間が長い、失敗テストの原因特定が困難
- **モジュール化**: テスト範囲が縮小、実行時間が短縮、原因特定が容易

**注意点:**
サービス間の通信が増加すると、テスト性は急速に低下する（テスト範囲が拡大）。

#### 3.2.3 デプロイ性（Deployability）

デプロイのしやすさ、デプロイ頻度、デプロイに伴う全体的なリスク。

**アーキテクチャとデプロイ性:**

| アーキテクチャ | デプロイ頻度 | デプロイリスク | デプロイ儀式 |
|--------------|------------|--------------|------------|
| モノリシック | 数週間〜数ヶ月に1回 | 高い | 多い（コードフリーズ、モックデプロイ等） |
| モジュール化 | 日次〜週次 | 低い | 少ない |

**注意点:**
「分散した巨大な泥団子」となってしまうと、デプロイ性のメリットは失われる。
- サービス群を特定の順序でデプロイしなければならない
- 他のサービスが壊れるのを恐れて変更をデプロイしづらい

#### 3.2.4 スケーラビリティ（Scalability）と弾力性（Elasticity）

**スケーラビリティ:**
時間の経過とともにユーザー負荷が徐々に増加しても、システムが応答性を維持できる能力。

**弾力性:**
ユーザー負荷が瞬間的かつ不規則に著しく増加した場合に、システムが応答性を維持する能力。

**アーキテクチャとスケーラビリティ/弾力性:**

| アーキテクチャ | スケーラビリティ | 弾力性 | 理由 |
|--------------|----------------|-------|------|
| レイヤード | ⭐ | ⭐ | アプリケーションレベルのスケーリング、貧弱なMTTS |
| サービスベース | ⭐⭐⭐ | ⭐⭐ | ドメインレベルのスケーリング、まずまずのMTTS |
| マイクロサービス | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 機能レベルのスケーリング、優れたMTTS |

*MTTS: Mean Time To Startup（平均起動時間）*

**注意点:**
1つのビジネストランザクションを完了するのに、より多くのサービスの相互通信が必要になるほど、スケーラビリティと弾力性にもより悪影響が出る。

#### 3.2.5 可用性・耐障害性（Fault Tolerance）

システムの他の部分が故障しても、他の部分は応答性と可用性を維持する能力。

**アーキテクチャと耐障害性:**
- **モノリシック**: 耐障害性が低い（全体が停止するリスク）
- **モジュール化**: 壊滅的な障害をデプロイメントユニットに隔離可能

**重要な前提条件:**
他のサービスが障害が発生しているサービスに**同期的な依存を持っていると、耐障害性は実現できない**。非同期通信が不可欠。

---

## 4. 分解アプローチの選択基準

### 4.1 コードベースの分解可能性判断

#### 4.1.1 求心性結合と遠心性結合

**求心性結合（Afferent coupling）:**
コードアーティファクトに外部から**入力**される接続数。

**遠心性結合（Efferent coupling）:**
他のコードアーティファクトに**出力**する接続数。

#### 4.1.2 抽象度（Abstractness）

抽象的なアーティファクト（抽象クラス、インターフェイス）と具体的なアーティファクト（実装）の比率。

```
A = Σm^a / (Σm^c + Σm^a)
```

- `m^a`: 抽象的な要素（インターフェイス、抽象クラス）
- `m^c`: 具体的な要素

#### 4.1.3 不安定度（Instability）

遠心性結合と求心性結合の合計に対する遠心性結合の比率。

```
I = C^e / (C^e + C^a)
```

- `C^e`: 遠心性結合（依存出力数）
- `C^a`: 求心性結合（依存入力数）

**解釈:**
- `I ≈ 1`: 非常に不安定（変更されたときに壊れやすい）
- `I ≈ 0`: 安定しているか柔軟性がない

#### 4.1.4 主系列からの距離（Distance from the main sequence）

不安定度と抽象度から求められる総合的なメトリクス。

```
D = |A + I - 1|
```

**重要なゾーン:**

| ゾーン | 座標 | 説明 |
|-------|------|------|
| **無駄ゾーン** | 右上（高抽象度・低不安定度） | 抽象的すぎて使いにくい |
| **苦痛ゾーン** | 左下（低抽象度・高不安定度） | 具体的すぎて変更に脆い |
| **主系列** | 対角線 | バランスの良いコンポーネント |

### 4.2 分解アプローチの決定フロー

```
コードベースは分解可能か？
（主系列からの距離で判断）
        ↓
      Yes
        ↓
コードが構造化されていない
寄せ集めか？
        ↓
  Yes          No
   ↓            ↓
戦術的フォーク  コンポーネントベース分解
```

### 4.3 コンポーネントベース分解

**概要:**
さまざまなリファクタリングパターンを適用してコンポーネントを洗練させた上で抽出し、インクリメンタルかつ制御的に分散アーキテクチャを形成する。

**適用条件:**
- 明確に（あるいは緩やかにでも）定義されたコンポーネント境界が存在
- コードベースが分解可能（主系列からの距離が許容範囲内）

**メリット:**
- 各サービス内で重複するコードを最小化
- 共通機能、コンポーネント境界、ドメイン境界をチームが協力して特定可能
- 安全で管理された段階的な移行

**デメリット:**
- 戦術的フォークよりも時間がかかる

**ターゲットアーキテクチャ:**
主にサービスベースアーキテクチャへの移行を可能にする（マイクロサービス化の足がかりにも適している）。

### 4.4 戦術的フォーク

**概要:**
アプリケーションのレプリカを作成し、不要な部分を削り取ってサービスを形成する。

**適用条件:**
- コードベースが構造化されていない巨大な泥団子
- 見分け可能なコンポーネントがあまり多くない

**プロセス:**

```
Step 1: モノリス全体のクローンを作成
         各チームにコードベース全体のコピーを与える
           ↓
Step 2: 不要なコードを削除
         （抽出ではなく削除がポイント）
           ↓
Step 3: 粗い粒度の構造を手に入れる
```

**メリット:**
- 事前の分析を必要としない（すぐに作業開始可能）
- コードは抽出するより削除する方が簡単
- 混沌としたコードベースに適している

**デメリット:**
- 使われないコードが大量に残る可能性
- コードの品質が向上するわけではない（単に少なくなるだけ）
- 共有コードの識別や整合性の維持が困難

---

## 5. 独自トレードオフ分析の構築

### 5.1 結合点の発見

**問い:**
「アーキテクチャ内のパーツは、互いにどのように結合されているのか？」

**結合の定義:**
「**X**を変更した場合に、**Y**も変更する必要があるか？」

**静的結合図の作成に必要な情報:**
- OS・コンテナの依存関係
- 推移的な依存関係管理によって提供される依存関係（フレームワーク、ライブラリ）
- データベース、検索エンジン、クラウド環境等の永続的な依存関係
- サービスが自己起動するために必要なアーキテクチャ統合点
- メッセージングインフラ（メッセージブローカー等）

### 5.2 結合点の分析（マトリクス構築）

**目標:**
可能な組み合わせを軽量な方法でモデル化し、検討すべき特性（トレードオフ分析が必要な特性）を見極める。

**分析プロセス:**

```
Step 1: 各パターンを個別に分析
           ↓
Step 2: マトリクスを作成して特性を比較
           ↓
Step 3: 相関関係を発見
```

**動的結合パターンの統合比較例:**

| パターン | 結合度 | 複雑さ | 応答性/可用性 | スケール/弾力性 |
|---------|-------|--------|-------------|---------------|
| エピックサーガ | とても高い | 低い | 低い | とても低い |
| 伝言ゲームサーガ | 高い | 低い | 低い | 低い |
| おとぎ話サーガ | 高い | とても低い | 中程度 | 高い |
| タイムトラベルサーガ | 中程度 | 低い | 中程度 | 高い |
| ファンタジーサーガ | 高い | 高い | 低い | 低い |
| ホラーストーリーサーガ | 中程度 | とても高い | 低い | 中程度 |
| パラレルサーガ | 低い | 低い | 高い | 高い |
| アンソロジーサーガ | とても低い | 高い | 高い | とても高い |

**発見された相関関係:**
- **結合度** ↔ **スケール/弾力性**: 直接的な逆相関（結合度が高いほどスケーラビリティが低下）
- **結合度** ↔ **応答性/可用性**: 結合度が高いと応答性や可用性が低下

### 5.3 トレードオフの評価

**根本的な次元の選択:**
同期通信か非同期通信かなど、根本的な次元を最初に選択すると、将来の選択肢が狭まる。

**イテレーティブな設計:**
- アーキテクチャソリューションのたたき台を図にまとめる
- 「もしある出来事が起こったらどうなる？」ゲームを繰り返す
- アーキテクチャの次元が互いにどのような影響を与えるかを確認
- このプロセスを繰り返して最後に残ったものが設計

---

## 6. トレードオフ分析手法

### 6.1 定性的分析と定量的分析

**定性的分析:**
量ではなく質を測定する。大規模なデータセットを利用した統計的な分析により、合理的な定性分析が可能になる。

**定量的分析:**
真の定量的分析を行う機会はアーキテクチャではほとんどない。

**推奨:**
定性分析を行うスキルを磨くことをおすすめする。

### 6.2 MECEリスト

**Mutually Exclusive, Collectively Exhaustive（互いに重複せず、全体として漏れがない）**

**互いに重複せず:**
比較対象となる項目の間で、どの能力も重ならないこと。

- ❌ **悪い例**: メッセージキューとESB全体を比較（カテゴリーが異なる）
- ✅ **良い例**: メッセージング機能だけを比較

**全体として漏れがない:**
決定空間におけるすべての可能性を網羅していること。

- ❌ **悪い例**: ESBとシンプルなメッセージキューのみを検討（Kafkaを除外）
- ✅ **良い例**: 高性能メッセージキューの全選択肢を検討

**目標:**
穴や重なりがないように、カテゴリー空間を完全にカバーすること。

### 6.3 「コンテキスト外」の罠

**問題:**
汎用的なソリューションは、状況に応じた追加のコンテキストを適用しない限り、現実のアーキテクチャではほとんど役に立たない。

**対策:**

1. **意思決定に最適なコンテキストを見つける**
   - 選択肢を絞って検討できる
   - 意思決定プロセスを大幅に単純化

2. **イテレーティブに設計する**
   - アーキテクチャソリューションのたたき台を図にまとめる
   - 定性的な「もしある出来事が起こったらどうなる？」ゲームを繰り返す
   - 適切なコンテキストを発見

**例:**

```
一般的な分析:
共有サービス vs 共有ライブラリ
        ↓
一般的な特性で比較
（すべて共有ライブラリが優位に見える）
        ↓
追加のコンテキスト（実際の組織の状況）
（共有サービスが最適と判明）
```

### 6.4 関連するドメインのシナリオをモデル化する

**原則:**
何らかのビジネス価値につながる推進要因がない状態で、アーキテクトは決定を下すべきではない。

**プロセス:**

```
Step 1: 一般的な要因を検討
           ↓
Step 2: 関連するドメインのシナリオをモデル化
           ↓
Step 3: 各シナリオが関心のあるアーキテクチャ特性に
        どのような影響を与えるかを確認
           ↓
Step 4: 本当の意味でのトレードオフを見極める
```

**例（支払いサービスの粒度判断）:**

**シナリオ1: クレジットカードサービスの更新**
→ サービス分離のメリット: 保守性、テスト性、デプロイ性の向上

**シナリオ2: 支払い方法の追加**
→ サービス分離のメリット: 拡張性の向上

**シナリオ3: 支払いに複数の方法を用いる**
→ サービス分離のデメリット: ワークフローの調整が必要、パフォーマンス低下、データ整合性の課題

**結論:**
本当のトレードオフは、**パフォーマンスとデータ整合性** vs **拡張性とアジリティ**のどちらが重要かという点に帰着する。

### 6.5 根拠は示し過ぎず、肝心なものに絞る

**問題:**
収集した情報をすべて示すと、技術者ではないステークホルダーが圧倒されて意味のある知見を加えられない。

**対策:**
トレードオフ分析をいくつかの重要なポイントに絞る。

**トレードオフ表の例（同期 vs 非同期通信）:**

| 同期のメリット | 同期のデメリット | 非同期のメリット | 非同期のデメリット |
|--------------|----------------|----------------|------------------|
| 顧客からの申請が終わる前に与信審査が開始されることが保証される | クレジットカードの承認プロセスが開始されるまで顧客が待たなければならない | 処理の開始を待つ必要がない | プロセスが開始されたことが保証されない |
|  | オーケストレーターがダウンした場合、顧客の申請は拒否される | アプリケーションの送信がオーケストレーターに依存しない |  |

**最終決定:**
「**クレジット承認プロセスがすぐに開始されることの保証** vs **応答性や耐障害性**のどちらが重要か」という問いに集約される。

### 6.6 過度な売り込みやエバンジェリズムを避ける

**問題:**
エバンジェリストは良い部分が強調され、悪い部分が削られてしまう。

**対策:**

1. **シナリオ分析を活用**
   - 想定されるシナリオをモデル化
   - 特定のソリューションが実際にうまく機能するかを発見

2. **トレードオフを客観的に判断**
   - 何かを伝道する立場を避ける
   - 銀の弾丸を追い求めない

3. **適応度関数で保護**
   - 有害なアンチパターンを防ぐ
   - 偶発的な結合を防ぐ

**例（パブリッシュ/サブスクライブ vs ポイントツーポイント）:**

**シナリオ1: 既存トピックへの入札履歴の追加**
→ 問題: コントラクトの肥大化、セキュリティ、運用特性の結合

**シナリオ2: 個別キューを使用**
→ メリット: 各コンシューマーが独自のコントラクト、詳細なセキュリティ、独立した監視・拡張

**トレードオフ表:**

| ポイントツーポイント型 | パブリッシュ/サブスクライブ型 |
|---------------------|---------------------------|
| 異なるコントラクトに対応可能 | 拡張性（新しいコンシューマーの追加が容易） |
| より詳細なセキュリティアクセスとデータ制御 |  |
| コンシューマー毎の運用プロファイル |  |

**アーキテクトの立場:**
反対の立場をとるわけでも、汎用的なソリューションを押し付けるわけでもなく、**現実に即したトレードオフ分析を行う立場**をとる。

---

## 7. 実践ガイドライン

### 7.1 トレードオフ分析のチェックリスト

#### Phase 1: 準備
- [ ] 関係者を特定（開発者、アーキテクト、運用担当者）
- [ ] 既存のエコシステム全体とその機能・制約を理解
- [ ] ビジネス目的と推進要因を明確化

#### Phase 2: 結合点の発見
- [ ] 静的結合図を作成（依存関係を可視化）
- [ ] 動的結合の3次元を特定（通信、整合性、調整）
- [ ] 結合の定義を適用（「Xを変更した場合にYも変更する必要があるか？」）

#### Phase 3: 結合点の分析
- [ ] 可能な組み合わせのマトリクスを構築
- [ ] 各パターンを個別に分析
- [ ] 特性を比較（結合度、複雑さ、応答性/可用性、スケール/弾力性等）
- [ ] 相関関係を発見

#### Phase 4: トレードオフの評価
- [ ] 関連するドメインのシナリオをモデル化
- [ ] 各シナリオが関心のあるアーキテクチャ特性に与える影響を確認
- [ ] 本当の意味でのトレードオフを見極める
- [ ] 根拠を肝心なものに絞る

#### Phase 5: 文書化と検証
- [ ] ADRを作成（コンテキスト、決定、影響）
- [ ] 適応度関数を実装（重要な指針を自動化）
- [ ] トレードオフ表を作成（ステークホルダー向け）

### 7.2 避けるべきアンチパターン

| アンチパターン | 説明 | 対策 |
|-------------|------|------|
| **銀の弾丸探し** | 万能なソリューションを追い求める | トレードオフを受け入れる |
| **エバンジェリズム** | 特定のアプローチを過度に推奨 | 客観的な分析を行う |
| **情報過多** | 技術的詳細を示し過ぎる | 肝心なポイントに絞る |
| **コンテキスト外判断** | 汎用的な分析に頼りすぎる | 組織の状況を考慮 |
| **MECE違反** | 比較対象が不適切 | 互いに重複せず、全体として漏れがない |

### 7.3 成功のための原則

**1. イテレーティブな設計:**
- アーキテクチャソリューションのたたき台を図にまとめる
- 「もしある出来事が起こったらどうなる？」ゲームを繰り返す
- 適切なコンテキストを発見するまで繰り返す

**2. ビジネス価値につながる推進要因:**
- 何らかのビジネス価値につながる推進要因がない状態で決定を下さない
- ドメイン上の根拠を持つ推進要因で判断に用いる

**3. 客観的な指標:**
- 適応度関数で重要な指針を自動化
- 定性的な分析から定量的な分析へ
- テストによって客観的な結果を得る

**4. シンプルさの追求:**
- 意思決定のための正しい**狭い**コンテキストを見つける
- 選択肢を絞って考える
- デザインをシンプルにする

**5. トレードオフの受け入れ:**
> アーキテクトであるなら、何かを伝道する立場を避け、トレードオフを客観的に判断する立場をとろう。銀の弾丸を追い求めるのではなく、トレードオフを分析するスキルに磨きをかけることで、アーキテクトは組織に真の価値を提供できるのだ。

---

## 8. まとめ

### 8.1 トレードオフ分析の本質

**核心メッセージ（再掲）:**
> アーキテクトが行える最善のデザインとは、**少なくとも最悪でないトレードオフの集合**だ。

**3ステップのプロセス:**

```
Step 1: どの部分が互いに絡み合っているかを見つける
           ↓
Step 2: それらがどのように結合しているかを分析する
           ↓
Step 3: 変更時にその結合がどんな影響をもたらすかを見極め、
        トレードオフを評価する
```

### 8.2 独自のトレードオフ分析を構築する

**重要な認識:**
- アーキテクチャは他のものとは違いすぎるので、一般的なアドバイスに頼ることはできない
- トレードオフ分析という作業を常に行わなければならない
- これはデメリットではなく、メリットでもある

**価値:**
- 次元を分離してトレードオフ分析を行う方法を学べば、自分たちのアーキテクチャについて具体的なことが分かる
- 問題のトレードオフの数を、実際にモデル化してテストできる程度の数にまで減らせる
- エコシステムに関する貴重な知識が得られる

**推測からエンジニアリングへ:**
- ソフトウェアアーキテクチャには、他の分野のエンジニアが持っているような評価に使える数値はない
- しかし、ソリューションを段階的に構築してテストしていける
- 客観的な結果を得るためのテストを行うことで、トレードオフ分析が定性的なものから定量的なものへと変化
- 推測からエンジニアリングへと変化

### 8.3 継続的な実践

**規律の重要性:**
- すべての決定についてトレードオフの表を作成する習慣を続ける
- ADRによって決定を文書化して伝えることを続ける
- 他のチームと協力して問題や解決策を考えることを続ける

**アーキテクトの真の価値:**
> 銀の弾丸を追い求めるのではなく、トレードオフを分析するスキルに磨きをかけることで、アーキテクトは組織に真の価値を提供できる。

---

## 参照

- 1章: 「ベストプラクティス」がないとどうなる？
- 2章: ソフトウェアアーキテクチャにおける結合の見分け方
- 3章: アーキテクチャのモジュール化
- 4章: アーキテクチャの分解
- 15章: 独自のトレードオフ分析を構築する

**関連スキル:**
- [architecting-microservices](../architecting-microservices/SKILL.md): マイクロサービスの8つのサーガパターン、粒度決定、データ所有権
- [applying-domain-driven-design](../applying-domain-driven-design/SKILL.md): ドメイン境界、境界づけられたコンテキスト、データ分解
