---
name: mastering-go-internals
description: Deep Go internals covering type system memory layout, slice/map internals, interface representation, and reflection. Use when optimizing Go performance, debugging memory issues, implementing serialization, or working with unsafe/cgo. Complements developing-go (fundamentals) with advanced internals knowledge.
---

# Mastering Go Internals

Goの内部動作を深く理解するための上級スキルです。

## 🎯 使用タイミング

以下の場面でこのスキルを参照してください:

**パフォーマンス最適化**
- メモリ使用量を最小化したい
- スライスやマップのパフォーマンスを改善したい
- 構造体のメモリレイアウトを最適化したい
- キャッシュ効率を向上させたい

**デバッグとトラブルシューティング**
- メモリリークを調査している
- 予期しないメモリ使用量を診断している
- スライスの共有底層配列によるバグを追跡している
- interfaceの型アサーション失敗を解決している

**低レベルプログラミング**
- C言語との連携が必要（cgo使用）
- unsafeパッケージの使用を検討している
- カスタムメモリアロケータを実装したい
- ハードウェアと直接やり取りする必要がある

**シリアライゼーション・リフレクション**
- カスタムエンコーダ/デコーダを実装している
- 動的な型チェックが必要
- 構造体フィールドタグを活用したい
- ジェネリックなアルゴリズムを実装したい

## 📚 ドキュメント構成

このスキルは以下のサブファイルで構成されています:

### 1. [TYPE-SYSTEM.md](./TYPE-SYSTEM.md) - 型システムの深層
整数型のメモリ表現、浮動小数点の精度限界、オーバーフロー検出、任意精度演算、文字列の内部構造、定数の型システムを解説。数値計算の精度問題や金額計算、メモリサイズの最適化を行う際に参照してください。

### 2. [COMPOSITE-INTERNALS.md](./COMPOSITE-INTERNALS.md) - 複合型の内部構造
配列の値セマンティクス、スライスの三要素ヘッダ構造、成長戦略とメモリ再割当て、マップのハッシュテーブル実装、構造体のパディングとアラインメント、JSONエンコーディングの仕組みを詳述。スライス/マップのパフォーマンス問題やメモリリークの調査時に有用です。

### 3. [INTERFACE-INTERNALS.md](./INTERFACE-INTERNALS.md) - インターフェースの深層
interface値の二要素内部表現（型ディスクリプタ+データポインタ）、空interfaceの特殊構造、型アサーションと型スイッチの動作メカニズム、標準ライブラリ（sort.Interface、http.Handler）の設計哲学、最適なinterface設計指針を解説。interfaceを使った拡張可能な設計やパフォーマンス最適化に役立ちます。

### 4. [REFLECTION.md](./REFLECTION.md) - リフレクション
reflect.TypeとValueの基礎操作、構造体フィールドの動的走査、メソッドの動的呼び出し、deep copy実装、構造体フィールドタグ活用、リフレクションのパフォーマンスコストと5つのベストプラクティスを提供。カスタムシリアライザやジェネリックアルゴリズムの実装時に参照してください。

### 5. [LOW-LEVEL.md](./LOW-LEVEL.md) - 低レベルプログラミング
unsafe.Sizeof/Alignof/Offsetofによるメモリ検査、構造体パディング最適化、unsafe.Pointerの4つの合法変換パターン、ポインタ演算、reflect.DeepEqual、cgoによるC言語連携、GCとの相互作用、unsafeコードのカプセル化戦略を詳説。C連携やパフォーマンスクリティカルな実装で必要になります。

## 🔍 クイックリファレンステーブル

| 解決したい問題 | 参照先ファイル | 該当セクション |
|-------------|------------|-------------|
| 整数オーバーフロー検出 | TYPE-SYSTEM.md | 整数オーバーフロー、math/bits |
| 浮動小数点の精度問題（0.1+0.2≠0.3） | TYPE-SYSTEM.md | 浮動小数点の精度、epsilon比較 |
| 金額計算の正確性 | TYPE-SYSTEM.md | 浮動小数点の精度限界 |
| スライスのメモリリーク | COMPOSITE-INTERNALS.md | スライスのメモリ管理、共有底層配列 |
| スライスの成長でパフォーマンス低下 | COMPOSITE-INTERNALS.md | スライスの成長戦略 |
| マップのイテレーション順序が不定 | COMPOSITE-INTERNALS.md | マップの実装 |
| 構造体のメモリサイズが予想より大きい | COMPOSITE-INTERNALS.md | 構造体のメモリレイアウト、パディング |
| 型アサーション失敗のパニック回避 | INTERFACE-INTERNALS.md | 型アサーション、二値形式 |
| sort.Interface実装のベストプラクティス | INTERFACE-INTERNALS.md | sort.Interfaceの設計哲学 |
| http.Handlerミドルウェア合成 | INTERFACE-INTERNALS.md | http.Handlerの設計 |
| 構造体フィールドを動的に走査したい | REFLECTION.md | 構造体フィールドの動的走査 |
| JSONタグ以外のカスタムタグ活用 | REFLECTION.md | 構造体フィールドタグ |
| deep copy実装 | REFLECTION.md | Deep Copy実装 |
| リフレクションのパフォーマンスが心配 | REFLECTION.md | パフォーマンスとベストプラクティス |
| 構造体のメモリサイズを調べたい | LOW-LEVEL.md | unsafe.Sizeof/Alignof/Offsetof |
| 構造体フィールド順序でサイズ削減 | LOW-LEVEL.md | 構造体のパディング最適化 |
| C言語のライブラリを使いたい | LOW-LEVEL.md | cgoの基礎、cgoの応用 |
| unsafeを安全に使いたい | LOW-LEVEL.md | unsafe.Pointer、低レベルプログラミングのベストプラクティス |

## ⚠️ ユーザー確認の原則（AskUserQuestion）

### 確認が必要な場面

以下の場合は**必ずAskUserQuestionツールで確認**:

1. **unsafeパッケージの使用を提案する前**
   - unsafeには型安全性を失うリスクがある
   - 安全な代替手段（標準パッケージ）の存在を説明し、選択肢を提示

2. **cgoの導入を提案する前**
   - cgoはビルド時間増加、クロスコンパイル困難、GC停止などのトレードオフがある
   - 純粋なGoでの実装可能性を先に確認

3. **リフレクションの大規模使用を提案する前**
   - パフォーマンスコストが高い
   - 型安全性を失う
   - コードの複雑性が増す
   - まず型パラメータ（ジェネリクス）での解決可能性を検討

4. **構造体フィールド順序の変更を提案する前**
   - 既存のシリアライゼーション（JSON、バイナリ）に影響する可能性
   - 互換性への影響を確認

5. **メモリレイアウト最適化の適用範囲**
   - プロファイリング結果に基づいているか確認
   - 早すぎる最適化を避ける

### 確認不要な場面

以下は**確認なしで実行可能**:

- 既存コードのリファクタリング（既にunsafe/cgo/reflectionを使用している）
- ドキュメントやコメントの追加
- 型アサーションを二値形式に変更（安全性向上）
- スライス/マップの適切な初期容量設定（make使用）
- 構造体のパディング情報の表示（unsafe.Sizeofによる診断のみ）
- reflect.DeepEqualの使用（テストコード内）

## 🔗 関連スキル

### 前提知識
- **developing-go**: Go開発の基礎・クリーンコード実践（命名規則、エラーハンドリング、並行処理の基本、テスト戦略、関数設計、リファクタリング）

### 併用推奨
- **applying-go-design-patterns**: GoFパターン、並行処理パターン（本スキルで得た内部知識を設計に活用）
- **enforcing-type-safety**: 型安全性の強制（unsafeやreflectionを使う際の代替策を検討）
- **testing**: テストファースト開発（内部構造を理解したうえでのテスト設計）
- **writing-clean-code**: SOLID原則・クリーンコード原則（言語非依存の設計原則）

### 専門領域
- **developing-nextjs**: （Go以外）Goバックエンドと連携するフロントエンド実装
- **securing-code**: セキュアコーディング（unsafe使用時のセキュリティリスク評価）

## 🚀 次のステップ

### 初学者向け学習順序

1. **まずTYPE-SYSTEM.mdから開始**
   - 整数型のメモリ表現とオーバーフロー検出を理解
   - 浮動小数点の精度問題を把握
   - 文字列の内部構造（UTF-8、イミュータブル性）を学習

2. **次にCOMPOSITE-INTERNALS.mdへ**
   - スライスの三要素ヘッダを理解（これが最重要）
   - マップのイテレーション順序非決定性を認識
   - 構造体のパディングを可視化してみる

3. **INTERFACE-INTERNALS.mdで設計力向上**
   - interface値の二要素構造を理解
   - 型アサーションのパニック回避方法を実践
   - 標準ライブラリの設計から学ぶ

4. **REFLECTION.mdで動的プログラミング**
   - 基本操作（reflect.TypeOf、ValueOf）から開始
   - 構造体フィールド走査を実装
   - パフォーマンスコストを常に意識

5. **LOW-LEVEL.mdは必要に応じて**
   - まず安全な代替手段がないか確認
   - unsafeは最後の手段
   - cgoは外部ライブラリ連携時のみ

### 実践的な学習方法

**ハンズオン課題**
- スライスの共有底層配列を可視化するプログラムを作成
- 構造体のメモリレイアウトを表示するツールを実装
- カスタムdeep copy関数を実装（リフレクション使用）

**ベンチマーク比較**
- reflect.DeepEqual vs 手動比較
- スライス事前割当あり vs なし
- 構造体フィールド順序によるサイズ差

**コードレビュー練習**
- 標準ライブラリのソースコードを読む（特にencoding/json）
- unsafeを使用しているOSSプロジェクトを調査
- 自分のコードでメモリ最適化の余地を探す

## 🔴 重要な注意事項

1. **車輪の再発明禁止**: 実装前に必ず既存ライブラリ（特に標準ライブラリ）を調査
2. **早すぎる最適化を避ける**: プロファイリング結果に基づいてから最適化
3. **unsafeは最後の手段**: 安全な代替手段を優先
4. **ドキュメント必須**: unsafeやreflectionを使う箇所は理由を明記
5. **テスト徹底**: 内部構造に依存したコードは脆弱なため徹底的なテストが必要

## 📖 用語集

- **三要素ヘッダ**: スライスの内部構造（pointer, length, capacity）
- **型ディスクリプタ**: interface値が保持する型情報
- **パディング**: 構造体フィールド間に挿入される未使用領域（アラインメントのため）
- **アラインメント**: メモリアドレスの境界要件（CPUアーキテクチャ依存）
- **底層配列**: スライスが参照する実際のメモリ領域
- **成長戦略**: スライスの容量が不足した際の拡張アルゴリズム
- **型アサーション**: interface値から具体的な型への変換
- **型スイッチ**: 型アサーションを複数の型に対して行う構文
- **リフレクション**: 実行時に型情報を検査・操作する機能
- **unsafe.Pointer**: 型安全性を回避する特殊なポインタ型
- **cgo**: GoからC言語の関数やライブラリを呼び出す機能

---

**次のアクション**: 解決したい問題に応じて上記のクイックリファレンステーブルから適切なサブファイルを選択し、詳細な実装ガイドを参照してください。
