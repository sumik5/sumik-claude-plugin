# 構成パターン詳細

マイクロフロントエンドの統合方法は、システムのパフォーマンス、SEO、チーム独立性に大きな影響を与えます。このドキュメントでは、垂直分割・水平分割の各構成パターンを詳しく解説します。

---

## 垂直分割アーキテクチャ

垂直分割では、各マイクロフロントエンドが完全なページまたはルートを所有します。

### アプリケーションシェルの設計

**アプリケーションシェル**は、全マイクロフロントエンドに共通する機能を提供する基盤レイヤーです。

#### 責任範囲

| 機能 | 説明 | 実装場所 |
|------|------|---------|
| **ルーティング** | URLに基づいてマイクロフロントエンドを切り替え | アプリケーションシェル |
| **認証** | ユーザーセッション管理、トークン管理 | アプリケーションシェル |
| **共通UI** | ヘッダー、フッター、ナビゲーション | アプリケーションシェル |
| **エラーハンドリング** | グローバルエラー境界 | アプリケーションシェル |
| **ビジネスロジック** | ドメイン固有の機能 | 各マイクロフロントエンド |

### 垂直分割の課題と解決策

#### 1. 状態共有の課題

**問題**: 複数のマイクロフロントエンド間で状態を共有する必要がある（例: カート情報、ユーザープロファイル）。

**解決策**:

| 方法 | 用途 | 実装例 |
|------|------|-------|
| **Custom Events** | 疎結合な通信 | window.dispatchEvent() |
| **Shared State Library** | 軽量な状態管理 | Zustand, Jotai |
| **Web Storage** | 永続化 | LocalStorage, SessionStorage |
| **URL Parameters** | 軽量な状態伝達 | クエリパラメータ |

**アンチパターン**: グローバルな状態管理ライブラリ（Redux）を全マイクロフロントエンドで共有すると、密結合になり独立性が失われます。

#### 2. CSS分離の課題

**問題**: CSSのグローバルスコープにより、マイクロフロントエンド間でスタイルが衝突する。

**解決策**:

| 技術 | 説明 | メリット | デメリット |
|------|------|---------|----------|
| **CSS Modules** | ファイル単位でスコープ化 | ビルド時に自動生成、学習コスト低 | 動的クラス名生成が困難 |
| **CSS-in-JS** | JavaScript内でスタイル定義 | 動的スタイル、TypeScript対応 | ランタイムコスト、バンドルサイズ増 |
| **Shadow DOM** | Web標準の完全分離 | 完全な分離 | 外部スタイルの適用が困難 |
| **BEM命名規則** | プレフィックスで衝突回避 | 既存コードに適用容易 | 命名規則の徹底が必要 |

**推奨アプローチ**: CSS Modules + デザインシステムの組み合わせ。

#### 3. 認証の統合

**問題**: 各マイクロフロントエンドで認証状態を個別に管理すると、ユーザー体験が悪化する。

**解決策**: 認証をアプリケーションシェルで一元管理。

### デザインシステムの実装

**目的**: 一貫したUI/UXを提供しつつ、各マイクロフロントエンドが独立して開発できるようにする。

#### バージョン管理

- Semantic Versioning（semver）に従う
- Breaking changeは慎重に（全マイクロフロントエンドに影響）
- 移行期間を設けて段階的にアップグレード

#### 配布方法

| 方法 | メリット | デメリット |
|------|---------|----------|
| **npm package** | バージョン管理容易、ビルド時統合 | 更新に再デプロイ必要 |
| **Module Federation** | 動的共有、一箇所更新で全体反映 | ランタイム依存、複雑度増 |

**推奨**: 基本はnpm package、頻繁に更新されるコンポーネントのみModule Federationで共有。

### SEO対応

**課題**: クライアントサイドレンダリング（CSR）はSEOに不利。

**解決策**:

| アプローチ | 説明 | 適用シーン |
|-----------|------|---------|
| **Pre-rendering** | ビルド時に静的HTMLを生成 | 静的コンテンツ（About, FAQ） |
| **SSR (Server-Side Rendering)** | リクエスト時にサーバーでレンダリング | 動的コンテンツ（商品ページ） |
| **ISR (Incremental Static Regeneration)** | 定期的に静的ページを再生成 | 準静的コンテンツ（ブログ、ニュース） |

### パフォーマンス最適化

#### コード分割戦略

- **ルートベース分割**（推奨）: 各マイクロフロントエンドをルート単位で遅延ロード
- **コンポーネントベース分割**: 重いコンポーネントのみ遅延ロード

#### バンドルサイズ最適化

| 施策 | 効果 | 実装方法 |
|------|------|---------|
| **Tree Shaking** | 未使用コード削除 | ES Modules使用 |
| **Code Splitting** | 必要な時だけロード | Dynamic Import |
| **依存関係の見直し** | 軽量な代替ライブラリ | moment.js → day.js |
| **共有チャンク** | 重複排除 | webpack SplitChunksPlugin |

### 利用可能なフレームワーク

| フレームワーク | 言語 | 特徴 | 推奨用途 |
|-------------|------|------|---------|
| **Single-SPA** | JS | フレームワーク非依存 | 複数フレームワーク混在 |
| **Qiankun** | JS | Single-SPAベース、中国製 | エンタープライズ |
| **Piral** | TypeScript | Portal/Pilet構造 | プラグイン型アプリ |
| **Bit** | JS | コンポーネント共有プラットフォーム | コンポーネントライブラリ管理 |

---

## 水平分割アーキテクチャ

水平分割では、単一ページ内で複数のマイクロフロントエンドを統合します。

### クライアントサイド構成

#### 1. Module Federation（webpack 5）

**概要**: webpack 5の機能。JavaScriptモジュールを動的に共有・ロードします。

**アーキテクチャ**:
- **Host**: マイクロフロントエンドを統合するアプリケーション
- **Remote**: 公開されるマイクロフロントエンド
- **Shared**: 共有される依存関係（React等）

**メリット**:
- Reactのインスタンスを共有（singleton）
- 動的なバージョン解決
- TypeScript型サポート

**デメリット**:
- webpackに強く依存
- 学習コスト高
- デバッグが複雑

#### 2. iframe

**概要**: HTMLの標準機能。完全に分離された環境でマイクロフロントエンドを実行します。

**メリット**:
- 完全な分離（CSS、JavaScript、グローバル変数）
- セキュリティ（sandboxオプション）
- レガシーシステム統合に最適

**デメリット**:
- SEO非対応（iframe内コンテンツはクロール不可）
- レイアウト制約（レスポンシブ対応が困難）
- パフォーマンス（各iframeが独立したブラウザコンテキスト）

**適用シーン**:
- レガシーアプリケーション統合
- サードパーティコンテンツ埋め込み
- セキュリティ要件が高い領域

#### 3. Web Components

**概要**: ブラウザ標準のコンポーネント技術。Custom Elements、Shadow DOM、HTML Templatesで構成。

**Shadow DOM vs Light DOM**:

| 項目 | Shadow DOM | Light DOM |
|------|-----------|-----------|
| スタイル分離 | 完全分離 | グローバルスコープ |
| 外部スタイル適用 | 困難（CSS Variables経由） | 容易 |
| SEO | 対応 | 対応 |
| 適用シーン | 完全独立コンポーネント | テーマ統一が必要 |

**メリット**:
- ブラウザ標準（フレームワーク非依存）
- Shadow DOMで完全なスタイル分離
- SEO対応

**デメリット**:
- 学習コスト
- 既存フレームワークとの統合が複雑
- デザインシステムの適用が困難（Shadow DOM）

### サーバサイド構成

#### 1. SSI (Server Side Includes)

**概要**: Webサーバー（NGINX、Apache）レベルでHTMLフラグメントを統合。

**メリット**:
- シンプル、軽量
- SEO完全対応
- キャッシュ制御が容易

**デメリット**:
- 動的なインタラクションに制限
- エラーハンドリングが困難

#### 2. 主要フレームワーク

**Podium**:
- Node.js専用
- Layout（統合）とPodlet（フラグメント）の2層構造
- クライアントサイド通信サポート

**OpenComponents**:
- コンポーネントをDockerコンテナで配布
- HTMLとデータの両方を提供可能
- バージョン管理が容易

**Tailor.js / Mosaic**:
- Zalando製（Tailor.js）
- ストリーミングレンダリング対応
- フラグメント並列取得

### エッジサイド構成

#### 1. ESI (Edge Side Includes)

**概要**: CDNレベルでHTMLフラグメントを統合。W3C標準（2001年）。

**メリット**:
- 低レイテンシ（エッジで処理）
- キャッシュ戦略を細かく制御
- SEO完全対応

**デメリット**:
- CDNサポートが限定的（Akamai、Fastly等の一部）
- 動的コンテンツに制限

#### 2. Lambda@Edge / Cloudflare Workers

**メリット**:
- 高度なパーソナライゼーション
- 低レイテンシ
- 地理的分散

**デメリット**:
- 実行時間制限（Lambda@Edge: 5秒、Cloudflare Workers: 50ms）
- デバッグが困難
- コールドスタート

---

## 特徴比較テーブル

各パターンを5段階評価（★が多いほど優れる）で比較します。

| パターン | 独立性 | テスト容易性 | パフォーマンス | デプロイ独立性 | SEO対応 |
|---------|--------|------------|-------------|-------------|---------|
| **垂直分割（SPA）** | ★★★★★ | ★★★★★ | ★★★★ | ★★★★★ | ★★ |
| **Module Federation** | ★★★★ | ★★★ | ★★★★ | ★★★★★ | ★★ |
| **iframe** | ★★★★★ | ★★★★ | ★★★ | ★★★★★ | ★ |
| **Web Components** | ★★★★ | ★★★★ | ★★★★ | ★★★★★ | ★★★★ |
| **SSI** | ★★★ | ★★★★ | ★★★★★ | ★★★★ | ★★★★★ |
| **Podium/OpenComponents** | ★★★★ | ★★★★ | ★★★★ | ★★★★★ | ★★★★★ |
| **ESI** | ★★★★ | ★★★ | ★★★★★ | ★★★★ | ★★★★★ |
| **Lambda@Edge** | ★★★★ | ★★ | ★★★★★ | ★★★★ | ★★★★ |

---

## パターン選択ガイド

| 要件 | 推奨パターン | 理由 |
|------|------------|------|
| **SEOが最重要** | SSI、Podium、ESI | サーバサイドで完全なHTML生成 |
| **高度なインタラクション** | Module Federation、垂直分割 | クライアントサイドで柔軟な制御 |
| **レガシー統合** | iframe | 完全分離、既存システムそのまま統合 |
| **グローバル配信** | ESI、Lambda@Edge | エッジで低レイテンシ処理 |
| **フレームワーク非依存** | Web Components | ブラウザ標準、長期安定性 |
| **最速の初期表示** | ESI、SSI | エッジ/サーバーで統合済みHTML配信 |

---

## 次のステップ

1. **構成方法の決定**: プロジェクト要件に基づき上記テーブルから選択
2. **ビルド戦略の設計**: [BUILD-AND-DEPLOY.md](./BUILD-AND-DEPLOY.md) でCI/CD設計
3. **バックエンド統合**: [BACKEND-PATTERNS.md](./BACKEND-PATTERNS.md) でAPI統合パターン確認
