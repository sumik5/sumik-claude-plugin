# ワークフローとコントラクト設計

マイクロサービス間の**ワークフロー管理**と**コントラクト（契約）**は、分散アーキテクチャの成否を左右します。本ファイルでは、オーケストレーション vs コレオグラフィの選択、コントラクトの厳格性、スタンプ結合の戦略的活用を体系化します。

---

## 📋 目次

- [オーケストレーション vs コレオグラフィ](#オーケストレーション-vs-コレオグラフィ)
- [動的結合パターンの選択](#動的結合パターンの選択)
- [コントラクトの設計](#コントラクトの設計)
- [スタンプ結合](#スタンプ結合)
- [ワークフロー状態管理](#ワークフロー状態管理)
- [意思決定フレームワーク](#意思決定フレームワーク)

---

## オーケストレーション vs コレオグラフィ

### 定義

| 方式 | 定義 | 制御方法 |
|-----|------|---------|
| **オーケストレーション** | 中央のコーディネーターがワークフロー全体を管理 | 中央制御（オーケストレーター） |
| **コレオグラフィ** | 各サービスが独立判断、イベント駆動で連携 | 分散制御（イベント・メッセージ） |

### オーケストレーション

**アーキテクチャ**:

```
                  ┌──────────────────┐
                  │ Orchestrator     │
                  │ (中央コントローラ) │
                  └──────────────────┘
                    │    │    │    │
          ┌─────────┴┐ ┌─┴──┐ ┌┴────┐ ┌┴──────┐
          │ Service A│ │S-B │ │S-C  │ │S-D    │
          └──────────┘ └────┘ └─────┘ └───────┘
```

**適用場面**:

| 特性 | 推奨条件 |
|-----|---------|
| **ワークフロー複雑度** | 5ステップ以上、条件分岐多数 |
| **エラーハンドリング** | 複雑な補償トランザクション必要 |
| **可視性要求** | ワークフロー全体の追跡・監視が必須 |
| **変更頻度** | 低（ビジネスプロセスが安定） |

**メリット**:
- ワークフロー全体の可視化
- エラーハンドリングの集中管理
- デバッグ・トラブルシューティング容易
- ビジネスロジックの集約

**デメリット**:
- **SPOF（Single Point of Failure）**: オーケストレーター障害で全体停止
- **スケーラビリティ制約**: オーケストレーターがボトルネック
- **密結合**: 参加サービスへの依存度高
- **オーケストレーター肥大化**: ビジネスロジックが集中

---

### コレオグラフィ

**アーキテクチャ**:

```
┌──────────┐   event   ┌──────────┐   event   ┌──────────┐
│ Service A│─────────→│ Service B│─────────→│ Service C│
└──────────┘           └──────────┘           └──────────┘
     ↓ event                                        ↓ event
┌──────────┐                                  ┌──────────┐
│ Service D│                                  │ Service E│
└──────────┘                                  └──────────┘
```

**適用場面**:

| 特性 | 推奨条件 |
|-----|---------|
| **ワークフロー複雑度** | シンプル、直線的 |
| **スループット要求** | 高（秒間1000リクエスト以上） |
| **疎結合優先** | サービス独立性が最重要 |
| **スケーラビリティ** | 水平スケール必須 |

**メリット**:
- 高スループット・高スケーラビリティ
- 疎結合・独立デプロイ容易
- SPOFなし
- 弾力性（Resilience）高

**デメリット**:
- **ワークフロー可視性低**: 分散トレーシング必須
- **デバッグ困難**: イベントチェーン追跡が複雑
- **状態管理難**: 全体状態の把握が困難
- **変更影響範囲**: イベント変更が複数サービスに波及

---

## 動的結合パターンの選択

### 判断マトリクス

| 判断軸 | オーケストレーション | コレオグラフィ | ハイブリッド |
|-------|-------------------|--------------|------------|
| **ワークフロー複雑度** | 高（10ステップ以上） | 低（3〜5ステップ） | 中（5〜10ステップ） |
| **条件分岐** | 多数 | 少数 | 中程度 |
| **エラー種類** | 多様・複雑 | 単純 | 中程度 |
| **スループット要求** | 中（<100 req/sec） | 高（>1000 req/sec） | 中〜高 |
| **可視性要求** | 高 | 低 | 中 |
| **変更頻度** | 低 | 中〜高 | 中 |

### 定量的評価基準

```python
def recommend_coordination_pattern(workflow):
    score = 0

    # 複雑性評価
    if workflow.steps > 10: score += 3  # オーケストレーション有利
    elif workflow.steps < 5: score -= 3  # コレオグラフィ有利

    if workflow.conditional_branches > 5: score += 2
    elif workflow.conditional_branches < 2: score -= 2

    # 性能評価
    if workflow.throughput_req > 1000: score -= 3
    elif workflow.throughput_req < 100: score += 2

    # 運用評価
    if workflow.visibility_requirement == "high": score += 2
    if workflow.change_frequency == "low": score += 1
    elif workflow.change_frequency == "high": score -= 1

    # 判定
    if score > 5:
        return "Orchestration"
    elif score < -5:
        return "Choreography"
    else:
        return "Hybrid"
```

### ハイブリッドアプローチ

**実装例**: 重要パス → オーケストレーション、非同期処理 → コレオグラフィ

```
┌──────────────────┐
│ Orchestrator     │ ← 注文処理（重要パス）
│                  │
│ [Order Flow]     │
│  1. 在庫確認     │──→ Inventory Service
│  2. 決済処理     │──→ Payment Service
│  3. 出荷準備     │──→ Shipping Service
└──────────────────┘
      ↓ event（完了通知）
  ┌────────────────┐
  │ Event Bus      │ ← 非同期処理（並行実行可）
  └────────────────┘
    │       │       │
    ↓       ↓       ↓
 [通知]  [分析]  [レコメンド]
```

---

## コントラクトの設計

### コントラクトの定義

**コントラクト**: アーキテクチャの部品が情報や依存関係を伝えるために使用するフォーマット

### コントラクトスペクトラム

```
厳格 ←──────────────────────────────────────→ 緩い
  │                                             │
RMI/gRPC   SOAP   GraphQL   REST   JSON (name-value)
  │                                             │
型・順序   スキーマ   部分指定   リソース   最小メタデータ
厳格      検証        選択的    ベース       のみ
```

---

### 厳格なコントラクト

**定義**: 名前、型、順序、すべての詳細を順守

**実装例（gRPC）**:

```protobuf
service OrderService {
  rpc CreateOrder (OrderRequest) returns (OrderResponse);
}

message OrderRequest {
  string customer_id = 1;
  repeated OrderItem items = 2;
  PaymentInfo payment = 3;
}
```

**適用判断**:

| 適用場面 | 理由 |
|---------|------|
| 金融取引 | 型安全性・トランザクション保証必須 |
| 内部マイクロサービス間 | 同一チーム管理、頻繁な変更調整可能 |
| 高信頼性要求 | コントラクト忠実性が最優先 |

**メリット**:
- コントラクト忠実性保証
- ビルド時検証容易
- 優れたドキュメンテーション
- バージョニング戦略明確

**デメリット**:
- 密結合（変更が両サービスに波及）
- バージョン管理コスト
- 進化しにくい

---

### 緩いコントラクト

**定義**: 名前と値のペア、最小限のメタデータ

**実装例（JSON）**:

```json
{
  "customer_id": "12345",
  "status": "pending",
  "total": 9999
}
```

**適用判断**:

| 適用場面 | 理由 |
|---------|------|
| 外部API統合 | バージョン非互換リスク低減 |
| 異種システム連携 | 技術スタック非依存 |
| 頻繁な変更 | スキーマ進化容易 |

**メリット**:
- 高度な疎結合
- 進化しやすさ
- 実装独立性

**デメリット**:
- コントラクト管理難
- 実行時エラーリスク
- 適応度関数（CDC）必要

---

### コンシューマー駆動コントラクト（CDC）

**定義**: コンシューマーがプロバイダーから取得したい情報を指定し、プロバイダーがビルド時に検証

**実装フロー**:

```
1. コンシューマーがコントラクト作成
   ↓
   {
     "customer_id": "string",
     "name": "string"
   }
   ↓
2. プロバイダーに送信
   ↓
3. プロバイダーのCIパイプラインで検証
   ↓ パス
4. コントラクト保証
```

**ツール例**:
- Pact（JavaScript, Java, Go, Python等）
- Spring Cloud Contract

**メリット**:
- 緩い結合とコントラクト忠実性の両立
- 厳格さの選択的調整
- 進化可能

**デメリット**:
- 成熟したエンジニアリングプラクティス必要
- 2つの仕組み（ペア + CDC）
- CI/CD統合必須

---

## スタンプ結合

### 定義

**スタンプ結合**: 大きなデータ構造をサービス間で受け渡しするが、各サービスはデータ構造の一部のみ使用

### アンチパターンとしてのスタンプ結合

**過結合の例**:

```
ウィッシュリストサービス（必要: name のみ）
  ↓ コントラクト（全プロフィール情報）
┌──────────────────────┐
│ Profile {            │
│   id                 │
│   name      ← 使用   │
│   email              │
│   addr1              │
│   addr2              │
│   state     ← 不使用 │
│   zip                │
│   phone              │
│   ...                │
│ }                    │
└──────────────────────┘
```

**問題**:
- `state`等の不要フィールド変更でコントラクト破損
- 帯域幅無駄（500KB × 2000 req/sec = 1GB/sec）
- 不必要な脆弱性

**解決**:

```json
// 必要最小限のコントラクト
{
  "id": "12345",
  "name": "John Doe"
}
```

---

### 戦略的活用: ワークフロー状態管理

**適用場面**: コレオグラフィで複雑なワークフローを実現

**実装パターン**:

```json
{
  "workflow_id": "order-12345",
  "workflow_state": "PAYMENT_PENDING",
  "transaction_state": "COMPENSATING",
  "visited_services": ["InventoryService", "PaymentService"],
  "domain_data": {
    "order_id": "12345",
    "customer_id": "67890"
  }
}
```

**各サービスの処理**:

```
1. コントラクト受信
   ↓
2. domain_data で業務処理
   ↓
3. workflow_state / transaction_state 更新
   ↓
4. 次サービスに転送
```

**メリット**:
- オーケストレーターなしで複雑ワークフロー実現
- 高スループット・スケーラビリティ
- 状態の可視性

**デメリット**:
- 結合度増加（意味的結合は避けられない）
- 帯域幅コスト（状態情報のオーバーヘッド）
- スキーマ変更の影響範囲拡大

---

## ワークフロー状態管理

### 状態マシンの設計

**例: チケット完了ワークフロー**

```
START → CREATED → ASSIGNED → ACCEPTED → COMPLETED → CLOSED
          ↓                     ↓           ↓
        WAITING            REASSIGN    NO_SURVEY
                               ↓           ↓
                           ASSIGNED → CLOSED
```

**状態遷移テーブル**:

| 開始状態 | 遷移状態 | 遷移条件 | アクション |
|---------|---------|---------|-----------|
| START | CREATED | チケット作成成功 | エキスパート割り当て |
| CREATED | ASSIGNED | エキスパート割り当て成功 | チケット配信 |
| ASSIGNED | ACCEPTED | エキスパート受理 | 作業開始 |
| ACCEPTED | COMPLETED | 修理完了 | アンケート送信 |
| ACCEPTED | REASSIGN | 再割り当て要求 | 別エキスパート検索 |
| COMPLETED | CLOSED | アンケート送信成功 | ワークフロー完了 |
| COMPLETED | NO_SURVEY | アンケート送信失敗 | リトライ |

### 結果整合性アプローチ

**補償トランザクション vs 状態管理**

| アプローチ | エラー時の動作 | 応答性 | 適用場面 |
|----------|--------------|-------|---------|
| **補償トランザクション** | ロールバック実行 | 低（補償完了まで待機） | ACID必須 |
| **状態管理** | エラー状態記録、非同期修復 | 高（即座に応答） | 結果整合性許容 |

**状態管理の例**:

```
1. アンケートサービス障害検出
   ↓
2. 状態を NO_SURVEY に更新
   ↓
3. ユーザーに成功応答返却（チケットは完了）
   ↓
4. 裏で非同期リトライ
   ↓ 成功
5. 状態を CLOSED に更新
```

**トレードオフ**:

| メリット | デメリット |
|---------|----------|
| 優れた応答性 | エラー時に一時的なデータ不整合 |
| エンドユーザーへの影響最小 | 結果整合性まで時間がかかる可能性 |

詳細: [DISTRIBUTED-TRANSACTIONS.md](DISTRIBUTED-TRANSACTIONS.md) のSagaパターン参照

---

## 意思決定フレームワーク

### ステップ1: ワークフロー特性の評価

```python
class WorkflowCharacteristics:
    steps: int
    conditional_branches: int
    error_types: int
    throughput_req: int
    visibility_req: str  # "high" | "medium" | "low"
    change_frequency: str  # "high" | "medium" | "low"

    def complexity_score(self):
        return (
            self.steps * 1 +
            self.conditional_branches * 2 +
            self.error_types * 1.5
        )
```

### ステップ2: 調整パターン選択

```
複雑度スコア > 20 かつ 可視性要求 = high
    → オーケストレーション

スループット要求 > 1000 かつ 複雑度スコア < 10
    → コレオグラフィ

上記以外
    → ハイブリッド（重要パスはオーケストレーション）
```

### ステップ3: コントラクト設計

```
内部サービス間（同一チーム） かつ 変更頻度 = low
    → 厳格なコントラクト（gRPC）

外部API統合 または 異種システム
    → 緩いコントラクト（JSON + CDC）

コレオグラフィ採用 かつ 複雑ワークフロー
    → スタンプ結合（ワークフロー状態含む）
```

### ステップ4: トレードオフ分析

```
判断結果:
- 調整方式: [オーケストレーション/コレオグラフィ/ハイブリッド]
- コントラクト: [厳格/緩い/CDC]
- 状態管理: [補償トランザクション/状態管理/ハイブリッド]

トレードオフ評価:
  メリット:
    - [選択したパターンの利点]
  デメリット:
    - [選択したパターンの欠点]
  軽減策:
    - [デメリットへの対処]
```

---

## 実装ガイドライン

### 1. オーケストレーターの実装

```
推奨アプローチ: Saga Orchestration

実装:
- オーケストレーター専用サービス作成
- 状態マシンをコード化（enum + 遷移テーブル）
- タイムアウト・リトライ戦略定義
- 補償トランザクション or 状態管理選択

監視:
- ワークフロー全体のトレーシング
- 各ステップの成功率・レイテンシ
- エラー種別ごとの発生頻度
```

### 2. コレオグラフィの実装

```
推奨アプローチ: Event-Driven Architecture

実装:
- メッセージブローカー選定（Kafka, RabbitMQ等）
- イベントスキーマ定義（Avro, Protobuf推奨）
- 各サービスに必要イベントのみサブスクライブ
- スタンプ結合でワークフロー状態伝播（必要なら）

監視:
- 分散トレーシング必須（OpenTelemetry推奨）
- イベントフロー可視化ツール導入
- デッドレターキュー監視
```

### 3. CDC実装

```
ツール選定:
- Pact（多言語対応）
- Spring Cloud Contract（Spring Boot）

ワークフロー:
1. コンシューマーがコントラクトテスト作成
2. プロバイダーのCIで検証
3. 失敗時は自動ビルド停止

運用:
- コントラクトバージョニング戦略
- 破壊的変更の通知プロセス
- コントラクトレジストリ管理
```

---

## 関連ファイル

- **[GRANULARITY-DECISIONS.md](GRANULARITY-DECISIONS.md)**: サービス粒度とワークフロー複雑性
- **[DATA-OWNERSHIP.md](DATA-OWNERSHIP.md)**: データアクセスパターンとコントラクト
- **[DISTRIBUTED-TRANSACTIONS.md](DISTRIBUTED-TRANSACTIONS.md)**: Saga 8パターン（オーケストレーション vs コレオグラフィ詳細）
- **[MESSAGING-PATTERNS.md](MESSAGING-PATTERNS.md)**: 非同期メッセージング実装
- **[SERVICE-COMMUNICATION.md](SERVICE-COMMUNICATION.md)**: 同期通信パターン

---

**次のステップ**: ワークフロー方式とコントラクト戦略を決定したら、[DISTRIBUTED-TRANSACTIONS.md](DISTRIBUTED-TRANSACTIONS.md)で具体的なSagaパターンを、[MESSAGING-PATTERNS.md](MESSAGING-PATTERNS.md)でメッセージング実装を確認してください。
