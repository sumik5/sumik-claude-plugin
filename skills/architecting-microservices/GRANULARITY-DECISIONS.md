# サービス粒度とコンポーネント分解の意思決定

マイクロサービスアーキテクチャにおける最も重要な判断の一つが**サービスの粒度（granularity）**です。本ファイルでは、コンポーネント分解パターンと粒度決定の判断基準を体系的に整理します。

---

## 📋 目次

- [コンポーネント分解パターン](#コンポーネント分解パターン)
- [サービス粒度の決定](#サービス粒度の決定)
- [分解ドライバー](#分解ドライバー)
- [統合ドライバー](#統合ドライバー)
- [トレードオフ分析](#トレードオフ分析)
- [意思決定フレームワーク](#意思決定フレームワーク)

---

## コンポーネント分解パターン

マイクロサービスへの分解には6つの代表的なパターンがあります。

### 1. Identify and Size Components Pattern（コンポーネント特定・サイジング）

**目的**: 既存モノリスから適切なサイズのコンポーネントを特定

**手順**:
1. ドメイン分析: ビジネス機能・境界付けられたコンテキストを特定
2. 依存関係マッピング: コンポーネント間の結合度を可視化
3. サイズ評価: 各コンポーネントのコード行数・複雑度を測定
4. 初期分割: 粒度のバランスを取る

**適用場面**: モノリスからの初期分解

**アウトプット**: コンポーネント候補リストとサイズ推定

---

### 2. Gather Common Domain Components Pattern（共通ドメインコンポーネント集約）

**目的**: 複数サービスで共有される共通ドメインロジックを集約

**対象**:
- 共通エンティティ（User, Product, Order等）
- 共通ビジネスルール（価格計算、税金計算等）
- 共通ユーティリティ（日付処理、通貨変換等）

**実装選択肢**:

| アプローチ | メリット | デメリット | 適用場面 |
|----------|---------|----------|---------|
| **共有ライブラリ** | 簡単、低オーバーヘッド | バージョン地獄、密結合 | 単純なユーティリティ |
| **共有サービス** | 疎結合、独立デプロイ | ネットワークレイテンシ、SPOF | 重要ドメインロジック |
| **コード複製** | 完全独立 | 保守コスト増 | 頻繁に変更されないロジック |

**判断基準**: [DATA-OWNERSHIP.md](DATA-OWNERSHIP.md) の再利用パターンセクション参照

---

### 3. Flatten Components Pattern（コンポーネントのフラット化）

**目的**: 深い階層構造を持つコンポーネントをフラットに再構成

**問題**: 深い階層 → 連鎖的依存 → デプロイ困難・障害拡大

**変換例**:

```
【変換前】階層構造
OrderService
  └─ PaymentModule
       └─ CreditCardProcessor
            └─ FraudDetection

【変換後】フラット構造
OrderService ─┬─ PaymentService
              ├─ CreditCardService
              └─ FraudDetectionService
```

**効果**:
- 独立デプロイ可能性向上
- 障害の局所化
- スケーラビリティ向上

**トレードオフ**: サービス数増加 → 運用複雑性増加

---

### 4. Determine Component Dependencies Pattern（依存関係決定）

**目的**: コンポーネント間の依存関係を明確化し、循環依存を排除

**手順**:
1. **依存関係の可視化**: ツール（Structure101, JDepend等）で依存グラフ作成
2. **循環依存の検出**: 強連結成分（SCC）アルゴリズムで検出
3. **依存関係の評価**:
   - Afferent Coupling (Ca): 入力依存数
   - Efferent Coupling (Ce): 出力依存数
   - Instability (I) = Ce / (Ca + Ce)
4. **循環依存の解消**: 依存性逆転原則（DIP）、インターフェース抽出

**許容される依存パターン**:

```
✅ 良い: 一方向依存（非循環有向グラフ）
A → B → C

❌ 悪い: 循環依存
A → B → C → A
```

**解消テクニック**:
- インターフェース抽出: 共通インターフェースを別パッケージに移動
- イベント駆動化: 直接依存を非同期メッセージングに置き換え

---

### 5. Create Component Domains Pattern（コンポーネントドメイン作成）

**目的**: ビジネスドメインに沿ったコンポーネント境界を確立

**アプローチ**: DDD（Domain-Driven Design）の境界付けられたコンテキスト

**手順**:
1. **ドメインモデリング**: イベントストーミングでドメインイベント抽出
2. **境界の特定**: 集約（Aggregate）、エンティティ、値オブジェクトを整理
3. **コンテキストマップ作成**: コンテキスト間の関係を定義
   - Shared Kernel（共有カーネル）
   - Customer-Supplier（顧客・供給者）
   - Conformist（追従者）
   - Anticorruption Layer（腐敗防止層）

**ドメイン境界の判断基準**:

| 判断軸 | 同一コンテキスト | 別コンテキスト |
|-------|---------------|--------------|
| **言語** | 同じユビキタス言語 | 異なる用語体系 |
| **変更頻度** | 同期して変更 | 独立して変更 |
| **データ所有権** | 共有データモデル | 独立したデータモデル |
| **チーム** | 同一チームが管理 | 別チームが管理 |

**詳細**: [applying-domain-driven-design](../applying-domain-driven-design/) スキル参照

---

### 6. Create Domain Services Pattern（ドメインサービス作成）

**目的**: 境界付けられたコンテキストをマイクロサービスとして実装

**実装ガイドライン**:

| 設計要素 | 推奨アプローチ |
|---------|--------------|
| **API境界** | RESTful or gRPC、明確な契約定義 |
| **データベース** | サービスごとに独立したスキーマ/DB |
| **トランザクション** | ローカルトランザクション、必要ならSaga |
| **認証・認可** | JWT、API Gateway統合 |
| **監視** | 分散トレーシング、集約ログ |

**サービス公開の判断**:

```python
def should_expose_as_service(component):
    score = 0
    if component.has_independent_data: score += 3
    if component.has_distinct_business_capability: score += 3
    if component.requires_independent_scaling: score += 2
    if component.has_different_team_ownership: score += 2

    return score >= 5  # スコア5以上でサービス化推奨
```

---

## サービス粒度の決定

### 粒度スペクトラム

マイクロサービスの粒度は以下のスペクトラム上に位置します:

```
細粒度 ←――――――――――――――――――――――→ 粗粒度
  │                                   │
Function  Feature   Domain   Capability  Application
  │         │         │         │           │
 極小      小        中         大         極大
高頻度    中頻度    低頻度    極低      単一
デプロイ  デプロイ  デプロイ  デプロイ  デプロイ
```

### 推奨粒度: Domain（ドメイン境界）

**理由**:
- DDD境界付けられたコンテキストに対応
- チームの自律性が高い
- ビジネス変更がサービス境界を超えにくい
- デプロイ頻度とサービス数のバランスが良好

---

## 分解ドライバー

サービスを**より細かく分解**する動機となる要因:

### 1. Service Scope and Function（サービスのスコープと機能）

**判断基準**:

| 指標 | 分解推奨閾値 |
|-----|------------|
| コード行数 | 10,000行以上 |
| 機能数（エンドポイント数） | 20以上 |
| チーム人数 | 8人以上（Two-Pizza Team超過） |

**サイン**: 「このサービスは何をするの?」に一言で答えられない

---

### 2. Code Volatility（コード変動性）

**定義**: 異なる変更理由を持つコードは分離すべき

**測定**: Git履歴から変更頻度・変更理由を分析

```bash
# 変更頻度分析例
git log --format=format: --name-only | sort | uniq -c | sort -rn
```

**分解の判断**:

| 状況 | 推奨アクション |
|-----|--------------|
| ファイルAは毎週変更、ファイルBは年1回 | 分離 |
| 変更の80%が特定モジュールに集中 | そのモジュールを独立サービス化 |
| 複数チームが同一ファイルを頻繁に変更 | コンフリクト回避のため分離 |

---

### 3. Scalability and Throughput（スケーラビリティとスループット）

**分解が必要なシナリオ**:

| シナリオ | 症状 | 分解戦略 |
|---------|-----|---------|
| **読み書き比率の偏り** | 読取QPS 10K、書込QPS 100 | CQRS: 読取サービス分離 |
| **ホットパス** | 特定APIが全トラフィックの80% | そのAPIを専用サービス化 |
| **リソース要求の差** | 一部機能がCPU/メモリ大量消費 | リソース集約機能を分離 |

**スケーリング要求の定量化**:

```
スケーリング必要度 = (ピークQPS / 平均QPS) × リソース集約度
```

- スコア > 5: 独立サービス化を検討
- スコア > 10: 独立サービス化を強く推奨

---

### 4. Fault Tolerance（耐障害性）

**分離の判断**:

| 失敗の影響範囲 | 分解判断 |
|--------------|---------|
| 機能Aの障害が機能Bに波及 | 分離してBulkhead実装 |
| 外部API障害が全体に影響 | 外部連携部分を独立サービス化 |
| 高リスク実験機能 | 安定機能と分離 |

**障害分離パターン**:

```
【分離前】モノリス
┌──────────────────┐
│ 決済 + 通知 + 検索 │ ← 通知サービス障害で決済も停止
└──────────────────┘

【分離後】マイクロサービス
┌──────┐ ┌──────┐ ┌──────┐
│ 決済 │ │ 通知 │ │ 検索 │ ← 通知障害でも決済は稼働
└──────┘ └──────┘ └──────┘
```

---

### 5. Security（セキュリティ）

**分解が必要なケース**:

| セキュリティ要求 | 分解戦略 |
|---------------|---------|
| **データ機密性レベルの差** | PII（個人情報）を別サービスに隔離 |
| **監査要件** | 金融トランザクションを専用サービス化 |
| **アクセス制御の複雑性** | 管理者機能とユーザー機能を分離 |
| **コンプライアンス** | GDPR対象データを地理的に分離 |

**セキュリティゾーン分離**:

```
DMZ（非武装地帯）
  └─ 公開APIサービス（認証のみ）

Trust Zone（信頼ゾーン）
  └─ 内部ビジネスロジックサービス
  └─ データ管理サービス（PII含む）
```

詳細: [SECURITY-PATTERNS.md](SECURITY-PATTERNS.md)

---

## 統合ドライバー

サービスを**統合（より粗い粒度に）**する動機となる要因:

### 1. Database Transactions（データベーストランザクション）

**問題**: 分散トランザクションのコスト > 分離の利益

**統合を検討すべき状況**:

| 状況 | 理由 |
|-----|------|
| ACID保証が絶対必須（金融取引等） | Saga等の結果整合性では不十分 |
| トランザクション境界が頻繁に変更される | 分散トランザクション設計が不安定 |
| 補償トランザクションが困難 | 一部操作が取り消し不可能 |

**判断フロー**:

```
トランザクション必要?
  ├─ No → 分離OK
  └─ Yes
      ├─ 結果整合性で許容可能? → Saga採用、分離OK
      └─ ACID必須? → 統合を検討
```

---

### 2. Workflow and Choreography（ワークフローと連携）

**問題**: サービス間の連鎖呼び出しが多すぎる

**統合を検討すべきサイン**:

| サイン | 閾値 |
|-------|-----|
| サービス間呼び出し数 | 1リクエストで5回以上 |
| ネットワークレイテンシ | 全体レスポンスタイムの50%以上 |
| オーケストレーション複雑度 | Sagaステップ数10以上 |

**レイテンシ分析**:

```
総レイテンシ = Σ(サービス処理時間 + ネットワーク時間)

例:
A→B→C→D (4サービス連鎖)
= (10ms + 5ms) + (15ms + 5ms) + (20ms + 5ms) + (10ms + 5ms)
= 75ms

統合後 A+B+C+D (単一サービス)
= 55ms (ネットワーク時間削減)
```

**統合の判断**: ネットワーク時間が総レイテンシの30%以上なら統合検討

詳細: [WORKFLOW-CONTRACTS.md](WORKFLOW-CONTRACTS.md)

---

### 3. Shared Code（コード共有）

**問題**: 共有ライブラリのバージョン管理・依存地獄

**統合を検討すべき状況**:

| 状況 | 理由 |
|-----|------|
| 共有コードが頻繁に変更される | 全サービスの再デプロイ頻発 |
| 共有コード量が各サービスの50%以上 | 実質的に強結合 |
| バージョン互換性が保てない | デプロイ調整コスト高 |

**共有コード依存度の計算**:

```
依存度 = 共有コード行数 / サービス総コード行数

依存度 > 0.5 → 統合検討
依存度 > 0.7 → 統合を強く推奨
```

**代替手段**: 統合前に以下を検討
- コード複製（依存解消）
- 共有サービス化（呼び出しに変換）

詳細: [DATA-OWNERSHIP.md](DATA-OWNERSHIP.md) の再利用パターン参照

---

### 4. Data Relationships（データ関係）

**問題**: 頻繁な結合クエリ・データ整合性保証の困難さ

**統合を検討すべきデータパターン**:

| パターン | 統合判断 |
|---------|---------|
| **強い外部キー制約** | OrderとOrderItemが常にセットで必要 → 統合 |
| **頻繁なJOIN** | 全クエリの80%がサービス間JOIN → 統合 |
| **トランザクション境界** | 原子性が必須（決済+在庫引当） → 統合 |

**データ関係の評価**:

```
結合度 = (サービス間クエリ数 / 総クエリ数) × 100

結合度 > 50% → 統合検討
結合度 > 70% → 統合を強く推奨
```

**注意**: データ統合 ≠ サービス統合。[DATA-OWNERSHIP.md](DATA-OWNERSHIP.md)の分散データアクセスパターンも検討すること。

---

### 5. Architecture Quantum（アーキテクチャ量子）

**定義**: 独立してデプロイ可能な最小単位（高い機能的凝集性 + 静的結合を持つコンポーネント群）

**統合を推奨する状況**:

| 状況 | 理由 |
|-----|------|
| サービスA, Bが常に同時デプロイされる | 事実上単一量子 → 統合すべき |
| 変更が常に複数サービスにまたがる | 量子境界が誤っている |
| デプロイ調整コストが開発コストを超える | 過度な分解 |

**量子の評価**:

```
量子独立度 = 独立デプロイ回数 / 総デプロイ回数

量子独立度 < 0.3 → 統合検討（70%以上が協調デプロイ）
量子独立度 < 0.1 → 統合を強く推奨
```

---

## トレードオフ分析

### 分解 vs 統合の天秤

```
      分解方向 ←―――――――――→ 統合方向
           ↑                  ↑
           │                  │
    メリット:              メリット:
    - 独立デプロイ         - トランザクション簡単
    - 障害分離             - 低レイテンシ
    - スケール柔軟性        - コード共有容易
    - チーム自律性         - データ整合性保証
           │                  │
    デメリット:            デメリット:
    - 分散トランザクション  - デプロイ影響大
    - ネットワークレイテンシ - スケール制約
    - 運用複雑性           - 障害波及
    - データ整合性課題      - チーム依存
```

### 意思決定マトリクス

| 要因 | 重みづけ | 分解スコア | 統合スコア | 判定 |
|-----|---------|-----------|-----------|------|
| デプロイ独立性 | ⭐⭐⭐ | +3 | -3 | - |
| トランザクション要求 | ⭐⭐⭐ | -3 | +3 | - |
| レイテンシ要求 | ⭐⭐ | -2 | +2 | - |
| チーム構成 | ⭐⭐ | +2 | -2 | - |
| 変更頻度 | ⭐ | +1 | -1 | - |
| **合計** | - | **+1** | **-1** | **分解** |

**判定基準**:
- スコア差 > 5: 明確に判断可能
- スコア差 < 3: グレーゾーン、プロトタイプで検証

---

## 意思決定フレームワーク

### ステップ1: 初期分解（Identify and Size Components）

```
1. ドメイン分析 → 境界付けられたコンテキスト特定
2. コンポーネントサイジング → 適切な粒度評価
3. 依存関係マッピング → 循環依存検出・排除
```

### ステップ2: 分解ドライバー評価

各コンポーネントに対して5つの分解ドライバーをスコアリング:

```python
decomposition_score = (
    scope_score +
    volatility_score +
    scalability_score +
    fault_tolerance_score +
    security_score
) / 5

# スコア > 7: 分解推奨
# スコア < 4: 統合検討
```

### ステップ3: 統合ドライバー評価

分解候補に対して5つの統合ドライバーをチェック:

```python
integration_penalty = (
    transaction_penalty +
    workflow_penalty +
    shared_code_penalty +
    data_relationship_penalty +
    quantum_penalty
) / 5

# ペナルティ > 7: 統合推奨
# ペナルティ < 4: 分解OK
```

### ステップ4: 最終判断

```
最終スコア = decomposition_score - integration_penalty

最終スコア > 3: 分解実行
最終スコア < -3: 統合実行
-3 ≤ 最終スコア ≤ 3: プロトタイプで検証
```

---

## 実践ガイドライン

### 1. 段階的アプローチ

```
Phase 1: モジュラーモノリス
  └─ ドメイン境界を明確化、内部でモジュール分離

Phase 2: 一部分離
  └─ 高スコアコンポーネントから順次サービス化

Phase 3: 最適化
  └─ 実測データに基づき粒度調整
```

### 2. 継続的評価

四半期ごとに以下を測定:
- デプロイ頻度
- 変更リードタイム
- サービス間呼び出し数
- 障害率・復旧時間

**基準を下回る場合は粒度調整を検討**

### 3. リバーシビリティ確保

粒度判断は後で変更可能にする:
- サービス境界にAdapter層を設ける
- データマイグレーション戦略を計画
- 統合・分離のコスト見積もりを定期的に更新

---

## 関連ファイル

- **[DATA-OWNERSHIP.md](DATA-OWNERSHIP.md)**: データ所有権と再利用パターン
- **[DISTRIBUTED-TRANSACTIONS.md](DISTRIBUTED-TRANSACTIONS.md)**: トランザクション戦略
- **[WORKFLOW-CONTRACTS.md](WORKFLOW-CONTRACTS.md)**: サービス間連携とコントラクト
- **[SERVICE-COMMUNICATION.md](SERVICE-COMMUNICATION.md)**: 通信パターン
- **[RESILIENCE-PATTERNS.md](RESILIENCE-PATTERNS.md)**: 耐障害性パターン

---

**次のステップ**: 粒度を決定したら、[DATA-OWNERSHIP.md](DATA-OWNERSHIP.md)でデータ所有権モデルを、[WORKFLOW-CONTRACTS.md](WORKFLOW-CONTRACTS.md)でサービス間連携パターンを確認してください。
