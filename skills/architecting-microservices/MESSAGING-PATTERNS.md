# 分散メッセージングパターン

## 概要

マイクロサービスアーキテクチャにおける分散メッセージングは、サービス間の疎結合な通信を実現し、システム全体のレジリエンスと可用性を向上させる重要なパターンです。

メッセージングがなければ、すべてのアプリケーションは24時間365日稼働し続ける必要があり、ダウンタイムや障害を許容できません。しかし現実には、あらゆるソフトウェアはダウンタイムや障害を経験するため、それらを適切に処理する設計が必要です。

---

## 同期 vs 非同期通信の判断基準

| 評価軸 | 同期通信 | 非同期通信 |
|--------|---------|-----------|
| **結合度** | 高い（送信側と受信側が同時に稼働必須） | 低い（送信側と受信側が独立動作可能） |
| **レスポンス時間** | 即座（同期的な応答） | 遅延あり（eventual delivery） |
| **スレッド利用効率** | 低い（待機中スレッドがブロック） | 高い（スレッドを解放して再利用） |
| **障害時の振る舞い** | 呼び出し元にエラー伝播 | メッセージキュー経由で再試行可能 |
| **トランザクション境界** | 単一スレッド内で完結 | 複数ステップに分割（相関ID必須） |
| **適用シナリオ** | CRUD操作、クエリ応答 | イベント通知、バッチ処理、長時間処理 |
| **スケーラビリティ** | 接続数とスレッド数に制約あり | メッセージブローカー経由で高スケーラブル |

### 使い分けの原則

**同期通信を選択すべき場合:**
- 即座のレスポンスが必須（ユーザーインタラクション）
- トランザクションを単一スレッド内で完結させたい
- 依存サービスが高可用性を保証している

**非同期通信を選択すべき場合:**
- サービスの自律性・独立性を最優先
- 長時間かかる処理（バッチ、レポート生成）
- 障害発生時にメッセージを失いたくない
- 送信側と受信側のスケーリングを独立させたい

---

## メッセージ永続性とレジリエンス

### メッセージ永続性の必要性

メッセージブローカーは通常、メッセージをメモリ（RAM）内に保持して配信します。しかし、ブローカーが障害で停止すると、メモリ内のすべてのメッセージが失われます。

**メッセージ永続性（Message Persistence）** は、ブローカーが受信したメッセージをディスクベースの永続ストアにバックアップする仕組みです。これにより、ブローカーが再起動してもメッセージが失われず、確実に配信されます。

### メッセージ永続性戦略

| 戦略 | 説明 | トレードオフ |
|------|------|-------------|
| **インメモリのみ** | ブローカーのRAMにメッセージ保持 | 高速だが、障害時にメッセージ消失 |
| **永続キュー** | すべてのメッセージをディスクに書き込む | 低速だが、障害に強い |
| **永続化チャネル** | 重要メッセージのみ別チャネルで複製 | バランス型（重要なメッセージのみ保護） |
| **複製キュー** | 複数ブローカーノードに複製 | 高可用性、ネットワーク帯域消費 |

### Fast Consumer vs Slow Consumer

マイクロサービスにはメッセージ処理速度が異なる複数のコンシューマーが存在します。

- **Fast Consumer**: メッセージをほぼ即座に処理（同期通信に近いパフォーマンス）
- **Slow Consumer**: 処理に時間がかかる、または一時的に利用不可

メッセージストアは、Slow Consumerがメッセージを処理するまでメッセージを保持し続けます。この仕組みにより、すべてのサブスクライバーが確実にメッセージを受信できます。

---

## Pub/Sub vs Point-to-Point

### パターン比較

| 特性 | Pub/Sub（Publish-Subscribe） | Point-to-Point（Queue） |
|------|------------------------------|-------------------------|
| **配信先** | 複数のサブスクライバー | 単一のコンシューマー（競合） |
| **メッセージライフサイクル** | すべてのサブスクライバーが受信後削除 | 1つのコンシューマーが受信後削除 |
| **用途** | イベント通知、状態変更ブロードキャスト | タスク分散、ワークキュー |
| **スケーリング** | サブスクライバー数に依存しない | コンシューマーを増やして並列処理 |
| **メッセージ重複** | 各サブスクライバーが独立受信 | 1メッセージは1コンシューマーのみ |

### 使い分けガイドライン

**Pub/Sub を使用する場合:**
- イベントを複数のマイクロサービスにブロードキャスト（例: 注文完成イベント → 在庫・配送・通知サービス）
- 同じイベントから複数の異なる処理を実行
- サブスクライバーの追加が動的に行われる可能性がある

**Point-to-Point を使用する場合:**
- タスクを複数のワーカーに分散処理させたい
- メッセージは1度だけ処理されるべき（冪等性が保証されていない場合）
- ロードバランシングが必要

---

## メッセージ相関・追跡パターン

### 課題: 非同期通信での要求-応答の紐付け

非同期通信では、リクエストとレスポンスが異なるスレッド・異なるタイミングで処理されます。このため、「どのレスポンスがどのリクエストに対応するか」を追跡する仕組みが必要です。

### Correlation ID パターン

**Correlation ID（相関ID）** は、各メッセージに付与される一意の識別子で、リクエストとレスポンスを紐付けます。

```
Request Message:
{
  "correlationId": "abc-123-xyz",
  "payload": { ... }
}

Response Message:
{
  "correlationId": "abc-123-xyz",  // 同じIDを返す
  "result": { ... }
}
```

### Return Address パターン

**Return Address（返信アドレス）** は、メッセージ内に「応答先チャネル名」を埋め込むパターンです。

```
Request Message:
{
  "correlationId": "abc-123-xyz",
  "replyTo": "response-queue-A",  // 応答先キュー
  "payload": { ... }
}
```

応答側サービスは `replyTo` フィールドを読み取り、指定されたキューに応答メッセージを送信します。

### 実装上の推奨事項

- **Correlation IDとReturn Addressは両方使う**: Correlation IDで紐付け、Return Addressで送信先を動的制御
- **メッセージヘッダーに格納**: ペイロードではなくメッセージヘッダーに格納することで、ペイロード非依存に
- **UUID使用**: Correlation IDにはUUIDやタイムスタンプベースのユニークIDを使用
- **トレースIDとの統合**: 分散トレーシング（OpenTelemetry等）のTrace IDをCorrelation IDとして利用可能

---

## メッセージブローカークラスタリングと冗長性

### 単一障害点（Single Point of Failure）の回避

**「鎖は最も弱いリンクと同じ強度しか持たない」原則:**

分散システムでは、システム全体のレジリエンスは最も脆弱なコンポーネントによって決まります。メッセージブローカーが単一ノードで動作している場合、そのブローカーが単一障害点となります。

### ブローカークラスタリング戦略

| 戦略 | 説明 | メリット | デメリット |
|------|------|---------|-----------|
| **アクティブ-スタンバイ** | 1つのアクティブノード + 複数のスタンバイノード | シンプル、データ一貫性保証 | フェイルオーバー時に遅延 |
| **アクティブ-アクティブ** | 複数のアクティブノードが同時動作 | 高スループット、水平スケーリング | 複雑、メッセージ順序保証困難 |
| **ミラーリングキュー** | メッセージを複数ノードに複製 | データロス防止 | ネットワーク帯域消費 |
| **ネットワークブリッジ** | ブローカー間をネットワーク接続して動的ルーティング | 柔軟なトポロジー | 設定複雑 |

### クラスタリング実装のポイント

1. **最低限の動作ノード数を定義**: 例: 3ノードクラスタで最低2ノードが稼働していれば動作
2. **動的ルーティング**: マイクロサービスはクラスタ内のいずれかのノードに接続すれば良い
3. **ロードバランサー統合**: TCP/IPロードバランサー（Nginx、HAProxy等）経由でクラスタアクセス
4. **自己回復**: ノードが復帰したら自動的にクラスタに再参加

---

## Fire-and-Forgetパターンによる疎結合化

### Fire-and-Forgetとは

**Fire-and-Forget** は、送信側がメッセージを送った後、応答を待たずに次の処理に進むパターンです。

```
Synchronous (Wait for response):
Service A --> Service B --> Response --> Service A continues

Fire-and-Forget:
Service A --> Message Queue --> (immediately continues)
                  ↓
              Service B (processes later)
```

### 適用シナリオ

- **ログ収集**: ログメッセージを非同期で送信
- **通知送信**: メール・SMS送信を非同期で実行
- **イベント発行**: ドメインイベントを他のサービスにブロードキャスト
- **バックグラウンドタスク**: レポート生成、データエクスポート

### 実装上の注意点

- **冪等性の保証**: メッセージが重複配信される可能性を考慮
- **デッドレターキュー**: 処理失敗メッセージを別キューに移動
- **モニタリング**: メッセージキューの深さ（未処理メッセージ数）を監視

---

## メッセージストアの活用パターン

### Event Store パターン

**Event Store** は、メッセージ（イベント）を時系列順に永続化するストアです。Event Sourcingパターンの基盤技術でもあります。

```
Event Stream:
[OrderCreated] → [PaymentProcessed] → [OrderShipped] → [OrderDelivered]
```

### メッセージストアのユースケース

| ユースケース | 説明 |
|-------------|------|
| **監査ログ** | すべてのイベントを記録し、後から追跡可能に |
| **状態再構築** | イベントを再生することで任意時点の状態を復元 |
| **リプレイ** | 障害発生時にメッセージを再配信 |
| **時系列分析** | メッセージストリームを分析してビジネスインサイト抽出 |

### 実装技術例

- **RabbitMQ**: 永続化キューとミラーリング
- **Apache Kafka**: ログベースのメッセージストア（リテンション期間設定可能）
- **AWS SQS/SNS**: クラウドネイティブメッセージング
- **NATS Streaming**: 軽量イベントストリーミング

---

## まとめ

分散メッセージングパターンは、マイクロサービスアーキテクチャにおいて以下の価値を提供します:

1. **自律性の実現**: サービスが独立して動作可能
2. **レジリエンスの向上**: 障害時もメッセージを失わない
3. **スケーラビリティ**: 送信側と受信側を独立してスケール
4. **疎結合**: サービス間の直接依存を排除

適切なメッセージングパターンを選択し、永続性・クラスタリング・相関IDなどの技術を組み合わせることで、堅牢な分散システムを構築できます。
