# サービス間通信パターン

## 概要

マイクロサービスアーキテクチャでは、複数の独立したサービスが協調して動作します。サービス間通信パターンは、これらのサービスがどのように情報を交換し、互いを発見し、呼び出すかを定義する重要な設計要素です。

適切な通信パターンの選択は、システムのスケーラビリティ、レジリエンス、保守性に直接影響します。

---

## Service Registry / Discovery（サービスレジストリ / ディスカバリー）

### 概要

サービスディスカバリーは、動的に変化するマイクロサービスのネットワーク位置（ホスト、ポート）を自動的に検出・管理する仕組みです。

### なぜサービスレジストリが必要か？

マイクロサービス環境では:
- サービスインスタンスが動的に増減（Auto Scaling）
- コンテナがノード間を移動（Kubernetes等）
- サービスのIPアドレス・ポートがハードコードできない

従来のDNSベースのロードバランシングでは、以下の問題があります:
- **キャッシュ問題**: DNSキャッシュにより、停止したインスタンスへトラフィックが流れ続ける
- **更新遅延**: DNS更新にはTTL分の遅延がある
- **ヘルスチェック未対応**: 停止しているインスタンスを除外できない

### サービスディスカバリーパターン

| パターン | 説明 | 実装例 |
|---------|------|--------|
| **クライアントサイドディスカバリー** | クライアントがレジストリから直接サービス位置を取得 | Netflix Eureka, Consul |
| **サーバーサイドディスカバリー** | ロードバランサーがレジストリを参照して転送 | AWS ELB, Kubernetes Service |

### サービスレジストリの動作フロー

```
┌─────────────┐         ┌─────────────┐
│ Service A   │         │ Service B   │
│ (Instance 1)│         │ (Instance 1)│
└──────┬──────┘         └──────┬──────┘
       │ 1. Register          │ 1. Register
       │    (host:port)       │    (host:port)
       ↓                      ↓
┌────────────────────────────────┐
│   Service Registry (Eureka)    │
│  - ServiceA: [host1:8080]      │
│  - ServiceB: [host2:8081]      │
└────────────────┬───────────────┘
                 │ 2. Discover
                 │    "ServiceB"
┌────────────────↓───────────────┐
│   Service A (calling ServiceB) │
│ 3. Call http://host2:8081/api  │
└────────────────────────────────┘
```

### 主要サービスレジストリ実装

| 実装 | 特徴 | 適用環境 |
|------|------|---------|
| **Eureka** | Netflix製、Spring Cloud統合、AP（Availability優先） | Spring Boot環境 |
| **Consul** | HashiCorp製、ヘルスチェック・KV Store統合、CP（Consistency優先） | Polyglot環境 |
| **Kubernetes Service** | Kubernetesネイティブ、DNS/環境変数ベース | Kubernetes |
| **Zookeeper** | Apache製、強整合性、高信頼性 | Kafka等のミドルウェア |

### サービス登録のベストプラクティス

- **自己登録パターン**: サービスが起動時にレジストリに自動登録
- **ヘルスチェック**: 定期的にヘルスステータスをレジストリに送信
- **自動登録解除**: サービス停止時にレジストリから削除
- **メタデータ付加**: バージョン、リージョン等の情報を登録

---

## API Gateway（APIゲートウェイ）

### 概要

API Gatewayは、クライアントとマイクロサービス群の間に配置される単一エントリーポイントで、以下の役割を担います:
- **リクエストルーティング**: URLパスに応じて適切なサービスに転送
- **集約（Aggregation）**: 複数サービスの結果を統合して返却
- **変換（Transformation）**: プロトコル変換、データ形式変換
- **認証・認可**: トークン検証、APIキー管理
- **レート制限**: API呼び出し回数制限
- **ログ・監視**: 統一的なログ収集

### API Gatewayパターン

```
┌──────────┐
│ Client   │
└─────┬────┘
      │
      ↓
┌─────────────────────────────┐
│      API Gateway            │
│  - Route /users → UserSvc   │
│  - Route /orders → OrderSvc │
│  - Auth, Logging, Caching   │
└──┬──────────────────────┬───┘
   │                      │
   ↓                      ↓
┌──────────┐      ┌──────────┐
│User      │      │Order     │
│Service   │      │Service   │
└──────────┘      └──────────┘
```

### API Gatewayの主要機能

| 機能 | 説明 | 実装例 |
|------|------|--------|
| **ルーティング** | URLパス・ヘッダーに基づいて転送先決定 | `/api/users/*` → User Service |
| **集約** | 複数サービス呼び出しを1つのレスポンスに統合 | ユーザー情報 + 注文履歴 → 統合レスポンス |
| **変換** | REST → gRPC、JSON → XML | モバイルアプリ向けに軽量化 |
| **認証** | JWT検証、OAuth 2.0トークン検証 | Authorization: Bearer <token> |
| **レート制限** | 1秒あたり100リクエストまで許可 | Token Bucket Algorithm |
| **キャッシング** | 頻繁にアクセスされるデータをキャッシュ | Redis統合 |
| **Circuit Breaker統合** | バックエンド障害時のFallback | Resilience4j統合 |

### API Gateway実装技術

| 実装 | 特徴 | 適用環境 |
|------|------|---------|
| **Spring Cloud Gateway** | リアクティブ（WebFlux）、Spring Boot統合 | Spring Boot環境 |
| **Kong** | オープンソース、プラグイン豊富、Nginx/OpenResty | Polyglot、エンタープライズ |
| **Amazon API Gateway** | AWSマネージドサービス、サーバーレス統合 | AWS環境 |
| **Nginx / Envoy** | 高性能、軽量、サービスメッシュ統合 | Kubernetes、サービスメッシュ |
| **Apigee / MuleSoft** | エンタープライズAPI管理プラットフォーム | 大規模エンタープライズ |

### API Gatewayのトレードオフ

| メリット | デメリット |
|---------|-----------|
| 単一エントリーポイント（統一的なセキュリティ・ログ） | 単一障害点（SPOF）になりうる |
| クライアントロジック簡素化 | 追加のネットワークホップ（レイテンシー増加） |
| 横断的関心事の集中管理 | Gateway自体の運用・スケーリングが必要 |

### Backend for Frontend (BFF) パターン

**BFF** は、クライアントタイプ（Web、モバイル、IoT等）ごとに専用API Gatewayを配置するパターンです。

```
┌─────────┐     ┌──────────────┐     ┌──────────┐
│Web App  │────▶│Web BFF       │────▶│Services  │
└─────────┘     └──────────────┘     │(Backend) │
                                      │          │
┌─────────┐     ┌──────────────┐     │          │
│Mobile   │────▶│Mobile BFF    │────▶│          │
└─────────┘     └──────────────┘     └──────────┘
```

**メリット:**
- クライアント固有の最適化（データ形式、ペイロードサイズ）
- 並列開発（Webチーム・モバイルチーム独立）

---

## REST vs gRPC vs メッセージング選択基準

### 通信プロトコル比較

| 特性 | REST (HTTP/JSON) | gRPC (HTTP/2 + Protobuf) | メッセージング (AMQP/Kafka) |
|------|-----------------|--------------------------|----------------------------|
| **プロトコル** | HTTP/1.1, JSON | HTTP/2, Protocol Buffers | AMQP, Kafka Protocol |
| **パフォーマンス** | 中（JSON解析オーバーヘッド） | 高（バイナリ、ストリーミング） | 中〜高（非同期） |
| **可読性** | 高（人間が読める） | 低（バイナリ） | 中（メッセージ形式依存） |
| **言語サポート** | 全言語対応 | 主要言語対応（Code Generation必要） | 全言語対応（クライアントライブラリ必要） |
| **ストリーミング** | 不可（WebSocket別途） | 対応（双方向ストリーミング） | 対応（Pub/Sub） |
| **結合度** | 同期（強結合） | 同期（強結合） | 非同期（疎結合） |
| **適用シナリオ** | 外部API、ブラウザクライアント | 内部マイクロサービス間通信 | イベント駆動、非同期処理 |

### 選択基準テーブル

| シナリオ | 推奨プロトコル | 理由 |
|---------|--------------|------|
| 外部公開API（パートナー・モバイルアプリ） | REST | 標準化、広範な互換性 |
| 内部マイクロサービス間通信（低レイテンシー重視） | gRPC | 高性能、ストリーミング対応 |
| リアルタイムデータストリーム（IoT、ログ） | gRPC Streaming or Kafka | 双方向ストリーミング |
| イベント駆動アーキテクチャ | メッセージング（Kafka, RabbitMQ） | 疎結合、非同期処理 |
| ブラウザからの直接呼び出し | REST | ブラウザネイティブサポート |
| モバイルアプリ（帯域幅制約） | gRPC | バイナリ圧縮、効率的 |

### REST使用ガイドライン

- **CRUD操作**: GET/POST/PUT/DELETE で直感的
- **ステートレス**: 各リクエストが独立
- **キャッシング**: HTTP Cache-Controlヘッダー活用
- **バージョニング**: URLパス（`/v1/users`）またはヘッダー

### gRPC使用ガイドライン

- **Protocol Buffers定義**: `.proto`ファイルでスキーマ定義
- **双方向ストリーミング**: サーバー/クライアント双方向の連続データ送信
- **デッドライン/タイムアウト**: 必ず設定
- **エラーハンドリング**: gRPCステータスコード（OK, UNAVAILABLE等）

---

## ロードバランシング戦略

### クライアントサイド vs サーバーサイドロードバランシング

| 特性 | クライアントサイド | サーバーサイド |
|------|------------------|--------------|
| **実装場所** | クライアントアプリケーション内 | 専用ロードバランサー（HAProxy, Nginx等） |
| **サービスディスカバリー** | クライアントがレジストリから取得 | LBがレジストリ参照 |
| **複雑性** | クライアント実装が複雑 | クライアント実装シンプル |
| **ネットワークホップ** | 少ない（直接接続） | 多い（LB経由） |
| **適用例** | Spring Cloud LoadBalancer, Netflix Ribbon | AWS ELB, Nginx, HAProxy |

### ロードバランシングアルゴリズム

| アルゴリズム | 説明 | 適用シナリオ |
|-------------|------|-------------|
| **Round Robin** | リクエストを順番に各インスタンスに割り当て | 均等な処理能力のインスタンス |
| **Weighted Round Robin** | インスタンスごとに重み付け | 異なるスペックのインスタンス |
| **Least Connections** | 接続数が最も少ないインスタンスを選択 | 長時間接続（WebSocket等） |
| **Random** | ランダムに選択 | シンプル、大規模環境で有効 |
| **Consistent Hashing** | リクエストキー（User ID等）でインスタンス固定 | セッション維持、キャッシュ局所性 |

---

## 同期/非同期HTTPパターン

### 同期HTTP（Blocking）

従来のHTTP通信。リクエスト送信後、レスポンスが返るまでスレッドがブロックされます。

```
Client Thread:
  send_request() → BLOCKED → receive_response() → continue
```

### 非同期HTTP（Non-Blocking）

リクエスト送信後、スレッドをブロックせず、レスポンス到着時にコールバックで処理します。

#### CompletableFuture（Java）

```java
CompletableFuture<Response> future =
  httpClient.sendAsync(request);

future.thenApply(response -> {
  // レスポンス処理
  return processResponse(response);
});

// このスレッドは他の処理を続行可能
```

#### DeferredResult（Spring MVC）

```java
@GetMapping("/async")
public DeferredResult<String> asyncEndpoint() {
  DeferredResult<String> result = new DeferredResult<>();

  // バックグラウンドで処理
  executor.submit(() -> {
    String data = longRunningTask();
    result.setResult(data);
  });

  return result; // すぐに制御を返す
}
```

### 非同期HTTPのメリット

- **スレッド効率化**: 待機中のスレッドを他のリクエスト処理に再利用
- **高スループット**: 同じリソースでより多くのリクエストを処理
- **スケーラビリティ**: I/O待機が多い場合に有効

---

## サービスメッシュとインターセプター

### サービスメッシュ概要

サービスメッシュは、マイクロサービス間の通信を制御・可視化するインフラストラクチャ層です。各マイクロサービスに**サイドカープロキシ**を配置し、すべての通信を経由させます。

```
┌────────────────┐      ┌────────────────┐
│ Service A      │      │ Service B      │
│  ┌──────────┐  │      │  ┌──────────┐  │
│  │App Logic │  │      │  │App Logic │  │
│  └────┬─────┘  │      │  └────┬─────┘  │
│       │        │      │       │        │
│  ┌────▼─────┐  │      │  ┌────▼─────┐  │
│  │Envoy     │◀─┼──────┼─▶│Envoy     │  │
│  │Proxy     │  │      │  │Proxy     │  │
│  └──────────┘  │      │  └──────────┘  │
└────────────────┘      └────────────────┘
```

### サービスメッシュの機能

| 機能 | 説明 |
|------|------|
| **トラフィック制御** | リトライ、タイムアウト、Circuit Breaker |
| **可観測性** | 分散トレーシング、メトリクス収集 |
| **セキュリティ** | mTLS（相互TLS）による暗号化 |
| **ロードバランシング** | 高度なルーティング（Canary, A/B Testing） |

### 主要サービスメッシュ実装

| 実装 | 特徴 | 適用環境 |
|------|------|---------|
| **Istio** | 最も機能豊富、Kubernetes統合 | Kubernetes |
| **Linkerd** | 軽量、シンプル、CNCF卒業プロジェクト | Kubernetes |
| **Consul Connect** | HashiCorp製、マルチクラウド対応 | VM + Kubernetes |

---

## 外部アーキテクチャ vs 内部アーキテクチャの視点

### 外部アーキテクチャ（Outer Architecture）

**定義**: クライアント（外部システム、エンドユーザー）から見たサービスの境界と相互作用。

**関心事:**
- API Gateway
- 認証・認可
- レート制限
- 外部公開エンドポイント

### 内部アーキテクチャ（Inner Architecture）

**定義**: マイクロサービス内部の構造とマイクロサービス間の内部通信。

**関心事:**
- サービスディスカバリー
- マイクロサービス間通信プロトコル
- データ整合性（Saga, Event Sourcing）
- 内部ロードバランシング

### アーキテクチャ分離の重要性

外部と内部を明確に分離することで:
- **柔軟性**: 内部実装を変更しても外部APIに影響しない
- **セキュリティ**: 内部サービスを外部に露出しない
- **進化性**: 内部マイクロサービスを段階的に置き換え可能

---

## まとめ

サービス間通信パターンは、マイクロサービスアーキテクチャの成否を左右する重要な要素です:

1. **Service Discovery**: 動的なサービス配置に対応
2. **API Gateway**: 統一エントリーポイントで横断的関心事を管理
3. **プロトコル選択**: REST（外部）、gRPC（内部）、メッセージング（イベント駆動）
4. **ロードバランシング**: クライアントサイド/サーバーサイドを適切に選択
5. **非同期HTTP**: スレッド効率化でスループット向上
6. **サービスメッシュ**: インフラレベルでの通信制御・可観測性

適切なパターンの組み合わせにより、スケーラブルでレジリエントなマイクロサービスアーキテクチャを実現できます。
