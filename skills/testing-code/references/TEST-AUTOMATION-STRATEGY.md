# テスト自動化戦略リファレンス

テスト自動化の目的・価値・戦略を体系的にまとめる。
手動テストとの使い分け、テストピラミッド、CI/CDパイプラインへの統合、段階的導入まで、
自動テストを軸にプロダクトを継続的に改善するための実践ガイド。

## 目次

- [テスト自動化の目的と価値](#テスト自動化の目的と価値)
- [手動テストと自動テストの使い分け](#手動テストと自動テストの使い分け)
- [テスト自動化ピラミッド](#テスト自動化ピラミッド)
- [腐りやすいE2Eテストのアンチパターン](#腐りやすいe2eテストのアンチパターン)
- [テストレベル別の自動化戦略](#テストレベル別の自動化戦略)
- [CI/CDパイプラインへの統合](#cicdパイプラインへの統合)
- [テスト自動化の導入ステップ](#テスト自動化の導入ステップ)
- [メトリクスと振り返り](#メトリクスと振り返り)

---

## テスト自動化の目的と価値

### 自動テストの本質的な目的

> 安全にリリースできる状態を、持続可能なコストでキープし続ける

プロダクトが成長すると、テスト対象は増え続ける。機能追加のたびにシステム全体のリグレッションテストを手動で実行するコストは指数的に増加する。自動テストはこの不均衡を解消するためにある。

### 3つの価値

**1. リグレッション防止**

```
手動テストのみの場合:
  機能追加にかける労力 << 他の部分が壊れていないことを確認する労力

自動テストがある場合:
  機能追加にかける労力 ≈ テストコード更新にかける労力
```

**2. フィードバックの高速化**

開発サイクルの中でテストを実行できる。テスターの手動テスト結果を待つ必要がない。コードを変更した直後に「何も壊れていない」ことを確認できる。

**3. 開発者の自信**

- リファクタリングへの安心感: テストがGreenなら安全に変更できる
- 仕様のドキュメント化: テストコードが「どう動くのか」を具体的に説明する
- コラボレーション促進: テストがあればコードレビューの負担が減る

### テストがないとどうなるか

```
1. テスト量がプロダクト成長とともに爆発的に増加
   ↓
2. リリースプロセスが肥大化（テスト+バグ修正に時間を要する）
   ↓
3. 一度のリリースに多くの機能を詰め込む
   ↓
4. バグの原因箇所の特定が困難になる
   ↓
5. リリース延期、本番障害の長期化
```

---

## 手動テストと自動テストの使い分け

### 自動テストに向いているもの

| 種別 | 説明 |
|------|------|
| リグレッションテスト | 既存機能の動作保証、繰り返し実行が前提 |
| 仕様確認テスト | 期待値が明確で再現性が高い |
| 負荷・性能テスト | 大量リクエストや長時間動作は手動で困難 |
| セキュリティテスト | 排他制御、インジェクションなど |
| ビジュアルリグレッション | 画像比較によるレイアウト崩れ検出 |

### 手動テストに委ねるべきもの

| 種別 | 説明 |
|------|------|
| ユーザビリティ評価 | 使いやすさ、直感性は人間の判断が必要 |
| 探索的テスト | 未知の問題を発見する柔軟な調査 |
| UX/感性評価 | 面白さ、目新しさ、快適さの評価 |
| プロトタイプ検証 | 要件の方向性が正しいかの確認 |

### 「素朴なテスト自動化」に陥らない

手動テストのテストケースをそのまま自動化しただけでは、手動と自動の悪いところ取りになる。

```
素朴なテスト自動化の問題:
  - 手動テストにあった柔軟性・発見性を失う
  - 開発サイクルに組み込まれず、高速フィードバックが得られない
  - テストコードのメンテナンスが追加コストになるだけ
```

**正しいアプローチ**: 手動テストの観点を整理し、「何が自動化されるのか」を明確にしてからテストコードを設計する。

---

## テスト自動化ピラミッド

### 3つの戦略モデル

**テストピラミッド（推奨の基本形）**

```
        /  E2E  \         少数・高コスト
       /----------\
      /  結合テスト  \      中程度
     /----------------\
    /  ユニットテスト    \   大量・低コスト
   /--------------------\
```

下層のテストを充実させることで、安定かつ高速なテスト戦略を実現する。

**アイスクリームコーン型（アンチパターン）**

```
   /--------------------\
    \  ユニットテスト  /     少数
     \--------------/
      \  結合テスト /        少数
       \----------/
        \  E2E  /            大量・不安定
```

上層のテストに偏ると、実行時間が長く、不安定なテストスイートになる。

**テスティングトロフィー型（フロントエンド向け）**

```
        /  E2E  \         少数
       /----------\
      /  結合テスト  \      最も多い（重点配分）
     /----------------\
    /  ユニットテスト    \   適度
   /--------------------\
  /     静的解析          \  TypeScript / ESLint
```

フロントエンドでは、UIコンポーネント同士が連動する機能が多いため、結合テストに最も比重を置く。

### 比率の目安

| テストレベル | ピラミッド型 | トロフィー型 |
|------------|-----------|-----------|
| E2E | 5-10% | 5-10% |
| 結合テスト | 20-30% | 40-50% |
| ユニットテスト | 60-70% | 30-40% |
| 静的解析 | - | 基盤として常時 |

---

## 腐りやすいE2Eテストのアンチパターン

### 1. UIの変更に弱い（ロケーター依存）

```typescript
// ❌ CSSセレクタに強く依存 → UI変更で即壊れる
await page.click('.btn-primary.submit-form')

// ✅ ロールベースのロケーター → UI構造が変わっても安定
await page.getByRole('button', { name: '送信' }).click()
```

### 2. テストデータの外部依存

```typescript
// ❌ 本番DBや外部APIのデータに依存 → 環境でテスト結果が変わる
it('ユーザー一覧を表示する', async () => {
  // DBに特定のデータが存在する前提
  await page.goto('/users')
  await expect(page.getByText('田中太郎')).toBeVisible()
})

// ✅ テストごとにデータをセットアップ
it('ユーザー一覧を表示する', async () => {
  await seedUser({ name: '田中太郎' })
  await page.goto('/users')
  await expect(page.getByText('田中太郎')).toBeVisible()
})
```

### 3. テスト間の順序依存

```typescript
// ❌ テストAの結果に依存してテストBが動く
it('ユーザーを作成する', async () => { /* ... */ })
it('作成したユーザーを編集する', async () => { /* テストAで作ったデータ前提 */ })

// ✅ 各テストが独立して完結する
it('ユーザーを編集する', async () => {
  const user = await createTestUser() // 自分でセットアップ
  await page.goto(`/users/${user.id}/edit`)
  // ...
})
```

### 4. 環境依存（タイムアウト、非同期待ち）

```typescript
// ❌ 固定のsleepで待つ → CI環境の速度差で不安定
await page.click('#submit')
await new Promise(r => setTimeout(r, 3000))

// ✅ 要素の出現を待つ
await page.click('#submit')
await expect(page.getByText('保存しました')).toBeVisible()
```

### 5. 開発サイクルの外で実行される

リリースサイクルの中でしかE2Eテストを実行しないと、フィードバックが遅く手戻りが大きくなる。開発サイクルの中にE2Eテストの一部を組み込む工夫が必要。

---

## テストレベル別の自動化戦略

### ユニットテスト

高速・大量・リファクタリング耐性が高い。ビジネスロジックを純粋関数に分離してテスト。

```typescript
describe('calculateShippingFee', () => {
  it('合計金額が5000円以上なら送料無料', () => {
    expect(calculateShippingFee(5000)).toBe(0)
  })
  it('合計金額が5000円未満なら送料500円', () => {
    expect(calculateShippingFee(4999)).toBe(500)
  })
})
```

カバレッジ目標: ビジネスロジック100%、ユーティリティ100%

### 統合テスト

コンポーネント間の連携を検証。モックサーバー（MSW等）を活用。

```typescript
it('注文送信成功時にサンクスメッセージ表示', async () => {
  server.use(http.post('/api/orders', () => HttpResponse.json({ id: 'order-1' })))
  render(<OrderForm />)
  await userEvent.click(screen.getByRole('button', { name: '注文する' }))
  expect(await screen.findByText('ご注文ありがとうございます')).toBeInTheDocument()
})
```

### E2Eテスト

ユーザーシナリオのクリティカルパスを保証。対象は絞る（ログイン、購入、決済等）。

```typescript
test('商品を購入できる', async ({ page }) => {
  await page.goto('/login')
  await page.getByLabel('メールアドレス').fill('user@example.com')
  await page.getByLabel('パスワード').fill('password123')
  await page.getByRole('button', { name: 'ログイン' }).click()
  await page.goto('/products/1')
  await page.getByRole('button', { name: 'カートに追加' }).click()
  await page.goto('/cart')
  await page.getByRole('button', { name: '購入する' }).click()
  await expect(page.getByText('ご購入ありがとうございます')).toBeVisible()
})
```

---

## CI/CDパイプラインへの統合

### テスト実行タイミング

| タイミング | 実行するテスト |
|-----------|--------------|
| ローカル開発 | ユニットテスト（watchモード）、関連する結合テスト |
| プルリクエスト (CI) | 静的解析 + ユニット + 結合 + E2Eスモーク |
| メインブランチマージ後 | 全テスト（ユニット+結合+E2Eフル）+ ビジュアルリグレッション |
| ステージングデプロイ後 | E2E（本番相当環境）+ 性能テスト |

### 並列化と高速化

- テストレベルごとにCIジョブを分割（ユニット / 結合 / E2E を並列実行）
- E2Eテストは `--shard` オプションで分割並列実行（例: Playwright の `--shard=1/3`）
- 失敗時はPRコメントにレポート投稿、スクリーンショット/動画をアーティファクト保存
- Flaky Test を検出・追跡する仕組みを導入

---

## テスト自動化の導入ステップ

| フェーズ | やること |
|---------|--------|
| 1. 最小限のテスト | フレームワークセットアップ → スモークテスト1つ → CIに組み込む |
| 2. クリティカルパス | ビジネスプロセスのリストアップ → 重要シナリオのE2E化 → ユニットテスト追加 |
| 3. テストの日常化 | 開発+テスト同時コミットルール → 参考テストコードの蓄積 → PR=機能+テストのセット |
| 4. 戦略の最適化 | カバレッジで弱点特定 → ピラミッドバランス調整 → Flaky撲滅 → 実行時間最適化 |

---

## メトリクスと振り返り

### 継続的に計測すべきメトリクス

| メトリクス | 意味 | 改善方向 |
|----------|------|---------|
| カバレッジ | テスト対象コードの網羅率 | ビジネスロジック100%を目指す |
| Flaky Test数 | 不安定なテストの件数 | 0に近づける |
| テスト実行時間 | CI全体の待ち時間 | 並列化・テスト分割で短縮 |
| Four Keys | デプロイ頻度・リードタイム・復旧時間・変更失敗率 | 自動テストの効果を測る上位指標 |
| バグ発見率 | テストで発見 vs 本番で発見の比率 | テストでの発見率を上げる |

### 振り返りのポイント

- テストが開発速度を落としていないか
- テストの信頼性は十分か（Flaky Testがないか）
- テストが仕様のドキュメントとして機能しているか
- 適切なテストレベルでバグを検出できているか

---

## 関連ファイル

- **[INSTRUCTIONS.md](../INSTRUCTIONS.md)** - スキル概要
- **[TDD.md](./TDD.md)** - TDDサイクル詳細
- **[TESTABLE-DESIGN.md](./TESTABLE-DESIGN.md)** - テスタブルな設計
- **[DEVELOPER-TESTING.md](./DEVELOPER-TESTING.md)** - 開発者テスト技法
- **[TEST-MANAGEMENT.md](./TEST-MANAGEMENT.md)** - テスト工程・品質管理
- **[MOCK-PATTERNS.md](./MOCK-PATTERNS.md)** - モックパターン集
