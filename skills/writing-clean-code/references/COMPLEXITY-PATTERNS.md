# 複雑性のパターンと対処

ソフトウェアプロジェクトの長期的な成功を阻む複雑性の発生パターンと、それに対処する実践的な戦略を提示します。

---

## 変更の法則

> **プログラムが存在する時間が長いほど、たとえ一部でも、少なからず変更しなくてはならない確率が高くなる。**

時間が経つにつれてソフトウェアを囲む環境が変化することは確実です。変わらないものなどありません。無限大の未来に行くにしたがって、プログラムのすべての部分が変更される確率が100%に近づいていきます。

**何が、どうして変更されるか**を予言するのは困難です。しかし、物事は変わって**いく**ことを知っていれば十分です。ソフトウェアを書く際には、合理的に可能な範囲で、できるだけ柔軟性を持たせることが重要です。

### 実際のプログラムから読み取れる変更の実態

あるプロジェクトで追跡したファイルのデータから、以下の傾向が明確に現れました：

- **変更率の大きさ**: 元のファイルにかかった作業より、変更する作業が圧倒的に多い（1.6倍〜36倍）
- **変更されていない行の少なさ**: 元の行数より小さく、現在の行数よりさらに小さい
- **サイズ増加と変更量の非相関**: ファイルサイズが大幅に増えていなくとも、時間が経つにつれて多くの変更が起こる
- **変更の累積性**: ファイルが古くなってくると、行を**入れる**ことよりも行を**変更する**ことが多くなる

---

## 3つの間違い

ソフトウェアデザインを行う者が、変更の法則に対処しようとしてやってしまう3つの大きな間違いがあります。

### 1. 要らないコードを書く

> **本当に必要になるまでコードは書かず、未使用のコードはすべて削除しよう。**

YAGNI（You Ain't Gonna Need It）は「あなたにそれは不要だ」という人気の高いルールです。しかし、このルールは拡大解釈すべきです。

#### 問題点

| 問題 | 詳細 |
|------|------|
| **デザインのやり直しが必要** | 将来必要になったとしても、実際のニーズに合わせてデザインし直す必要がある |
| **ビット崩壊** | 未使用のコードは一度も実行されないため、システムの他の部分と少しずつ同調しなくなりバグが発生する |
| **デバッグコスト** | 使用する段になって、信用してチェックしなかったためにユーザー側でバグが発生する |

#### 検出シグナル

- 「将来必要になるかもしれない」という理由だけで機能を実装している
- データベーススキーマに使用されていないフィールドがある
- 「アクティブ」「有効」などのフラグが存在するが、実際の処理で無視されている
- 顧客からの依頼がないのに汎用的な機能を追加している

#### 対処法

- 本当に必要になるまで待つ
- すでに不要になったコードは削除する（バージョン管理システムがあれば、必要になったらいつでも戻せる）
- 機能要求が実際に来てから実装する

### 2. 変更しやすいコードを書かない（厳格なデザイン）

> **将来起きると予測されている事柄ではなく、現在判明している事柄に基づいてコードをデザインすべきだ。**

変更が困難なコードをプログラマーがデザインした場合、ソフトウェアプロジェクトを崩壊させる可能性が最も高くなります。

#### 問題点

厳格なデザインを作ってしまう要因：

1. **未来についての仮定を盛り込みすぎる**
2. **デザインが不十分なままコードを書く**

#### 検出シグナル

| パターン | シグナル |
|---------|---------|
| **過度な事前計画** | システム全体の詳細を定めた文書を作成し、それに従って実装している |
| **長い実装期間** | 最初のリリースまでに数年かかる計画になっている |
| **硬直したコード** | 一部を変更すると同じような変更を何か所にも行わなければならない |
| **説明のない散在** | 説明も論理的な仕組みもなく、コード中にパーツが散らばっている |

#### 対処法

- 現時点でシステムがすべきことが「X」のみであれば、いますぐその「X」ができるようにデザインする
- 未来には「X」でないことがあるかもしれないことを念頭に置く
- 個別の変更を小さく保つ
- 計画も、過ぎた量でなければ価値が高いが、詳細すぎる計画は避ける

### 3. 一般的すぎるコードを書く（オーバーエンジニアリング）

> **いま必要なぶんだけ一般的であればよい。**

将来起こりうるすべての可能性に対処するために一般的すぎるソリューションをデザインすることで問題解決を図ろうとする開発者がいます。

#### 問題点

| 問題 | 詳細 |
|------|------|
| **未来予測の限界** | どれだけ一般的にしても、実際に発生する未来の要件を満たすほどの一般性は見出せない |
| **特定処理の力不足** | コードが一般的すぎると、**特定の事柄**をうまく処理できていないようにユーザーには見える |
| **不要なコード** | あまりに一般的すぎると、不要なコードをたくさん書かねばならない（第一の間違いに戻る） |

#### 検出シグナル

- 蟻塚を退治するために軌道レーザーを作っている
- デザインによって物事が単純化される代わりに複雑化している
- 顧客からの依頼がないのに「プラグイン」機構を追加している
- エラーメッセージが「不正なバイトが送信されました」のように一般的すぎて、ユーザーに的確に伝えられない

#### 対処法

- 適切な項目に対し、適切な方法を通して一般的になる
- 一般的**すぎる**場合は、隠蔽された複雑さ、混乱、管理作業の原因になることを認識する
- いま必要なぶんだけ一般的にする

---

## インクリメンタルな開発とデザイン

本質的に3つの誤りを回避する手法があります。それは、システムの設計と構築を、部分ごとに順番に行うことです。

### 基本ステップ

加減乗除ができる電卓プログラムを例にすると：

1. 足し算だけを行うシステムを計画する
2. 上記のシステムを実装する
3. 引き算機能を追加しやすいように作ったシステムのデザインを修正する
4. 引き算機能をシステムに実装する（足し算と引き算しかできないシステムが出来た）
5. かけ算機能を追加しやすいようにシステムのデザインをさらに修正する
6. かけ算機能をシステムに実装する（足し算、引き算、かけ算だけできるシステムが出来た）
7. 割り算機能を追加しやすくするためにシステムのデザインをさらに修正する
8. 割り算機能をシステムに実装する

### 実装順序の決定

それぞれの段階に到達したところで、**最も単純な作業**を選ぶべきです。

- 足し算が最初にきたのは、4つの操作の中で最も単純だったから
- 引き算は、足し算を元に論理的に組み立てられるため、2番目になった
- かけ算は足し算を何回も行う作業だから、かけ算を2番目に選んでもよかった
- 唯一、2番目に選ぶことが**なかった**のは割り算（足し算から割り算に一足飛びに行くのは論理的に飛躍しすぎ）

ときには、1つの機能をさらに何個もの小さくて単純な論理のステップに分解して、実装しやすくする必要も出てきます。

### 2つの手法の組み合わせ

- **インクリメンタルな開発**: 小さな部分に分けて作業することでシステム全体を構築する
- **インクリメンタルなデザイン**: 小さな単位に分けてシステムの**デザイン**を作ったり改善したりする

---

## 複雑性を増す7つの要因

以下の要因は、すぐに破滅をもたらすわけではありませんが、**ゆっくりと少しずつ**製品の害となっていきます。

| 要因 | 判断基準 | 対処法 |
|------|---------|--------|
| **1. ソフトウェアの役割拡大** | 元の役割から外れた機能を追加しようとしている | できるだけ大きな声で反対する。元の役割から外れないようにする |
| **2. 開発者の増員** | チームサイズを増やすことで問題解決しようとしている | 素人の開発者をたくさん集めるより、ベテランの開発者の小さなグループのほうが成功する可能性が高い |
| **3. 不要な変更** | 要件、デザイン、コードを思いつきで変更している | 変更するたびに複雑性を加え、バグが発生する可能性を増やしていることを自覚する |
| **4. 間違った技術へのロックイン** | ある技術に過度に依存するあまり長期にわたって、それしか使えていない | 生き残る確率、相互運用性、品質へのこだわりで判断する（後述） |
| **5. 誤解** | 自分の仕事を完全には理解していない | 携わっているシステムや使うツールを十分に理解する |
| **6. 劣悪なデザイン** | 変更計画の失敗、開始時のデザイン不足 | システムが拡大するにつれて良質のデザインを続ける |
| **7. 車輪の再発明** | まったく問題がないプロトコルが存在するのに自分の手でわざわざ作り出す | 後述の条件を満たす場合のみ許可する |

### 車輪の再発明が許される条件

以下の条件のいずれかが満たされた場合だけ許可されます：

- a. まだ存在しないものを必要としている
- b. 既存の「車輪」すべてが、そこにロックインされてしまう類の間違った技術である
- c. 既存の「車輪」では根本的なニーズに対応しきれない
- d. 既存の「車輪」が適切に管理されておらず、持続的な管理ができない状態である（たとえばソースコードがない、など）

---

## 技術選定の3基準

ある技術が「間違っている」かどうかを判断する指標が3つあります。

### 1. 生き残る確率

技術が生き残る確率は、メンテナンスが続くかどうかにかかっています。

#### チェックリスト

- [ ] 直近のリリース履歴があるか？
- [ ] ユーザーが実際に問題に感じている部分を修正した新バージョンを頻繁に出しているか？
- [ ] バグレポートへの開発者の返答率は高いか？
- [ ] 積極的に活動するメーリングリストやサポート体制があるか？
- [ ] インターネット上で多くの人が話題にしているか？
- [ ] たった1社のベンダーではなく、広く受け入れられてさまざまな開発者によって使われているか？

**注意**: 本当に人気がある技術と、ある種の独占状態にあることでユーザー数が多い技術とは区別しなければなりません。

### 2. 相互運用性

相互運用性とは、「必要に応じて、ある技術からどれほど容易に切り替えができるか」という指標です。

#### 確認方法

「標準的な方法でこの技術とやりとりができるだろうか。そうすれば同じ標準を使った別のシステムに乗り換えやすいはずだ」と自問する。

- 基準に準拠するシステムを選択していれば、他のシステムに移ってもプログラムをマイナーチェンジするだけで済む
- 基準に準拠しないシステムを選択していると、そこに囲い込まれるため、簡単には他のシステムに乗り換えができなくなる

### 3. 品質へのこだわり

主観的な指標ですが、直近のリリースで製品が改善されているかどうかを見ます。

#### チェックリスト

- [ ] 開発者がリファクタリングやコードベースの整理をしているか？
- [ ] 使いやすくなっているか？
- [ ] 複雑になっていないか？
- [ ] 実際に製品の品質に気を遣っているか？
- [ ] 最近、劣悪なプログラミングによると思われる深刻なセキュリティ上の脆弱性が多く見つかっていないか？

### その他の考慮点

技術を選択する際に、ほかにも考慮すべき点があります：

- 技術の簡潔性
- 自分の目的にどれほど適切か
- 個人的な意見（実際的な検討がすべて済んでから）

---

## 複雑性への対処法

### 段階的リデザイン

システムの一部が複雑すぎた場合、上手な修正方法は、**個別の部分を少しずつデザインし直すこと**です。

#### 基本原則

- 少しずつ修正していけば、さらなる複雑性を増やすことなく安全に修正できる
- 多くの再デザインや描き直しが失敗するのは、修正する**よりも多くの**複雑性を増やしてしまうか、元のシステムと同じくらい複雑になってしまうから

#### 具体的なステップ

| ステップ | 内容 |
|---------|------|
| **変数名の付け直し** | たった1つの変数の名前を付け直す |
| **コメント追加** | 読んでいて混乱するコードにコメントを少し追加する |
| **ファイル分割** | 大きなファイルを小さな部分に切り分け、それぞれのデザインを改善する |
| **継続的改善** | いまあるシステム**よりも良い**ものを目指し続ける |

#### 継続的改善のサイクル

1. 最初に、どんなに些細な違いでもよいので、いまあるものよりも**簡潔な**システムを思い浮かべる
2. その簡潔なシステムを目指して、一歩ずつ作業する
3. より簡潔なシステムが出来たら、さらに簡潔なシステムを想定し、それに向かって作業する
4. 「完璧な」システムなど存在しないことを認識する

### 機能追加と再デザインの両立

機能の追加をやめて再デザインに多くの時間を割く、というのはできません。プログラムをめぐる環境は常に変わり続けているため、プログラムの機能性もそれに適応しなければなりません。

#### 両立の方法

**特定の機能を実装しやすくすることだけに注目してデザインをし直し、その機能を実装する**

- デザインと機能の間をいつでも切り替えながら作業できる
- 実際の使用を想定しながら機能を作成するため、デザインとニーズを合致させやすくなる
- システムは時間の経過とともに複雑性が少なくなるが、ユーザーのニーズへの対応もそれに遅れずに済む

この方法を、バグの修正に応用することもできます。バグを修正する前にデザインを変えたほうがよいと思うのなら、コードのデザインを直してから修正します。

### 修正できない複雑性のラッパー化

基盤となるハードウェアに含まれるものなど、どうしても避けられない複雑性がある場合には、**複雑性を隠すことが目標**となります。

他の開発者にも使いやすくわかりやすい、簡潔なラッパーで包囲してしまいましょう。

---

## 書き直しの5条件

イチからシステムを書き直すのは、デザイナーとして失敗を認めたことになります。「管理できるシステムのデザインに失敗したので、最初からやり直します」と宣言しているようなものです。

### 書き直しが許される条件

次の条件が**すべて真**でなければ、書き直しをしてはなりません：

1. **正確な見積り**: 既存システムのデザインを直すよりもシステムを書き直したほうが時間を効率的に使える、とわかっている（予測値ではなく実測値）
2. **時間の余裕**: 新システムを作成することに浪費できるほど大量に時間がある
3. **デザイナーの能力**: 元のシステムデザイナーより、何らかの理由で読者のほうがデザイナーとして優れている
4. **ユーザーフィードバック**: 新システムのデザインについて、段階に応じたごくシンプルな作業をしているだけといった具合に淡々と、段階を進むごとにフィードバックをくれるユーザーがいる
5. **リソースの並行確保**: 既存システムの管理と、新システムのデザインに、同時にリソースを割くことができる

上記の項目がすべて真であれば、システムの書き直しが許される状況と言えるかもしれません。いずれにも該当しない場合には書き直しは**せず**に、段階に応じて淡々と改善を続けていくかたちで、既存のシステムの複雑性に対処します。

---

## 複雑性対処の判断フローチャート

```
複雑性に直面
    ↓
「解決したい問題は何か？」と自問
    ↓
問題の本質を理解
    ↓
┌──────────────────────┐
│ 修正可能な複雑性か？     │
└──────────────────────┘
    ↓          ↓
   Yes         No
    ↓          ↓
段階的      簡潔な
リデザイン   ラッパー
    ↓       で包囲
個別の部分を
少しずつ改善
    ↓
継続的に
いまあるシステム
よりも良いものを
目指す
    ↓
機能追加と
再デザインを
両立
    ↓
┌──────────────────────┐
│ 書き直しの5条件を     │
│ すべて満たすか？      │
└──────────────────────┘
    ↓          ↓
   Yes         No
    ↓          ↓
書き直し    段階的改善
を検討      を継続
```

### 複雑性の根本原因を探る

何かが非常に複雑になりかけている場合、しばしば、その複雑性が現れるレベルよりはるかに下層のどこかにデザインの間違いがあります。

「解決できない複雑性」がプログラムに出来てしまったら、それはデザインに関して根本的に何かが間違っていることを示します。あるレベルで解決できそうになければ、レベルを1つ引き返して、何があるかを理解してみましょう。

---

## 複雑な問題への対処

本質的にきわめて複雑な問題の解決を任されることがあります（スペルチェック機能、コンピュータにチェスをさせる方法など）。

### 重要な原則

> **問題が複雑だからといって、解決方法も複雑である必要はない。**

複雑な問題に手を焼いたら、それを普通の言葉で紙に書いてみたり、表や図にしてみるとよいでしょう。

> **多くの難しいデザイン上の問題は、紙に図として描いたり、平易な言葉で書き出してみることで解決できることがある。**

最高のプログラミングは、ときに紙上で行われることがあります。コンピュータに入力するのはそれほど重要でなく、たんに通過点にすぎません。

### 簡潔性を確かめる質問

「どうしたら容易に対処できるか、もしくはわかりやすくできるか？」

これが、簡潔にする作業すべてに共通する質問です。これに対する真なる答えはすべて、コードを簡潔にする有効な手段です。
