# ソフトウェアデザインの法則と簡潔性

## 概要

ソフトウェア開発において、複雑性は最大の敵である。優れた開発者は、複雑性を削ぎ落として簡潔性に導く作業に注力する。本ドキュメントでは、ソフトウェアデザインの普遍的な法則と、それらを実践に活かすための指針を提供する。

---

## ソフトウェアの目的

すべてのソフトウェア開発において、最も根本的な原則は次のとおり:

> **ソフトウェアは人を助けるためにある。**

この目的を念頭において作業できない開発者は、劣悪なソフトウェアを書くことになる。優良なソフトウェアを開発できる潜在的能力は、開発者がどれだけ他者を助けようと思うことができるかという度合いによって決まる。

### 実践での活用

開発において決断を行う場合、指針は「どのような助けとなれるか」とすればよい。機能追加のリクエストも、この判断基準に従って優先順位を決める。

| 判断場面 | 問いかけ | 判断基準 |
|---------|---------|---------|
| 機能追加 | この機能はユーザーをどのように助けるか？ | 役に立たないなら削除、役立つなら理由を明文化 |
| バグ修正 | このバグはどのようにユーザーの邪魔をしているか？ | 実害の大きさで優先度決定 |
| デザイン判断 | どちらがより多くの人をより大きく助けるか？ | 助けの範囲と深さで評価 |

---

## デザインの方程式

ソフトウェアデザインにおける決断は、次の方程式で解決できる:

```
D = (Vn + Vf) / (Ei + Em)
```

- **D** (Desirability): 変更への欲求度 — その変更が必要とされる度合い
- **Vn** (Value Now): 現在の価値 — いまユーザーを助ける度合い
- **Vf** (Future Value): 将来の価値 — 未来のユーザーを助ける度合い
- **Ei** (Effort of Implementation): 実装にかかる作業量
- **Em** (Effort of Maintenance): 管理にかかる作業量

> **あらゆる変更の欲求度は、変更の価値に比例し、変更するのにかかる作業量に反比例する。**

### 価値の評価

価値とは、変更が誰に対しても、どこであっても、どれだけ助けとなるかの度合いである。価値には2つの要素がある:

- **確率**: その変更がユーザーの助けとなる可能性（何人が、どれほど頻繁に価値を感じるか）
- **潜在性**: ユーザーの助けとなる場面で、その変更がどれだけ役に立つか

### 作業量の評価

作業量は「実装」と「管理」に分かれる。実装は一度きりだが、管理は時間とともに継続する:

| 作業量の種類 | 内容 | 重要性 |
|------------|------|--------|
| 実装 (Ei) | プログラミング、調査、連絡、思考にかかる時間 | 低 |
| 管理 (Em) | テスト、バグ修正、更新、将来の変更対応 | **高** |

### 方程式の省略形

長期間使用されるソフトウェアでは、時間の経過とともに実装コストと現在の価値は相対的に無視できるようになる。方程式は次のように省略される:

```
D ≈ Vf / Em
```

> **実装にかかる作業量よりも管理にかかる作業量を減らすほうがより重要だ。**

### 判断基準テーブル

| 変更のパターン | 評価 | 判断 |
|--------------|------|------|
| Em減少、Vf増大 | ★★★ | 最優先で実装 |
| Em減少、Vf安定 | ★★☆ | 積極的に実装 |
| Em安定、Vf増大 | ★☆☆ | 価値次第で実装 |
| Em増大、Vf増大（Em < Vf） | △ | 慎重に判断 |
| Em増大、Vf安定 | × | 実装すべきでない |

---

## 不具合発生率の法則

プログラマーとしての腕の良し悪しに関わらず、コードを書けば書くほど不具合を増やすことになる:

> **プログラムに不具合を作ってしまう確率は、そのプログラムに加える変更の大きさに比例する。**

砕けた言葉で表せば「コードを追加したり修正したりしなければ、新しいバグを作ることもない」となる。

### 実践での活用

- **小さな変更を優先**: 小さな変更 = 不具合が少ない = 管理の負担が減る
- **証拠に基づく修正**: 問題が真に存在することを示す証拠がない限り、何も「修正」してはならない
- **早すぎる最適化の回避**: 実際にパフォーマンス問題が発生している箇所だけを最適化する

### 問題修正の判断基準

| 状況 | 対応 |
|-----|------|
| ユーザー報告 + 再現可能 | 証拠あり → 修正実施 |
| ユーザー報告のみ（再現不可） | 機能の使い方説明で解決できないか確認 |
| 予測される問題 | 証拠なし → 修正しない |
| 推測によるパフォーマンス懸念 | 実測データなし → 最適化しない |

---

## DRY原則（Don't Repeat Yourself）

> **システムにおいて、理想上は特定の情報はたった一度だけ存在すればよい。**

情報の一元化は不具合発生率を減らし、デザインの柔軟性を保つ。

### 実践での活用

- **コピー&ペースト禁止**: 同じコードの塊を複製せず、関数化・モジュール化する
- **設定値の一元管理**: UI文言、設定値、ビジネスルールは一箇所にまとめる
- **既存コードの再利用**: 新機能追加時、既存のコードを使い回せないか検討する

---

## 検証の法則

> **ソフトウェアがどのように動作するかは、それをどれほど正確に検証したか、その度合いによる。**

試してみなければ、動くかどうかはわからない。検証の「度合い」とは:

- どれだけの側面をテストしたか
- どれほど最近にテストしたか
- どれほど異なる環境でテストしたか

### 実践での活用

- **自動化されたテスト**: 小さな変更のたびに手動テストするのは非現実的 → テスト自動化が必須
- **変更後の再検証**: ソフトウェアを変更したら、その時点で動作保証が失われる → 再検証必須
- **具体的な期待値**: テストでは非常に的確な質問をし、具体的な回答を得る

---

## 最高のデザインの定義

不具合発生率の法則と変更の法則は矛盾する。ソフトウェアは変更を余儀なくされるが、不具合はまさにその変更によって生じる。この矛盾のバランスを取ることが、ソフトウェア設計者の知性が問われる場面である:

> **最高のデザインとは、環境の変化に最大限に対応しながらもソフトウェア自体の変更は最小にするものである。**

今日、ソフトウェアデザインについて知られていることのほとんどすべてが、上記に要約される。

### デザイン品質の決定要因

> **デザインの品質は、作成したシステムが人の役に立ち続けると考えられる、将来の期間に比例したレベルでなければならない。**

| 使用期間 | デザイン作業量 | アプローチ |
|---------|--------------|----------|
| 数時間〜数日 | 低 | 最小限の設計で実装 |
| 数週間〜数ヶ月 | 中 | 基本的な柔軟性を確保 |
| 数年以上 | 高 | 深い注意を払い、柔軟性と変更可能性を最大化 |

見通しがはっきりしない場合は、かなり長期間にわたって使われるソフトウェアだと考えてデザインするとよい。

---

## 未来との向き合い方

> **未来については、いまはわからないことがある。**

最も起こりがちで破滅的な間違いは、開発者が実際には何もわからないのに未来のことについて予言してしまうことだ。

### 予言と準備の違い

- **❌ 予言**: 「ユーザーはフロッピーディスクを永遠に使い続ける」と決めつけてデザインする
- **✅ 準備**: 将来変更できるようにデザインし、管理にかかる作業量を減らす

未来を良くする（管理にかかる作業量を減らし、価値を上げる）ために、いま持っている情報を元にできる決定がいくつかある。そのために、未来に何が起こるかを具体的に予言する必要はない。

---

## 6つの法則クイックリファレンス

| 法則 | 内容 | 実践ポイント |
|-----|------|------------|
| **ソフトウェアの目的** | ソフトウェアは人を助けるためにある | 「どのような助けとなれるか」で判断 |
| **デザインの方程式** | D = (Vn + Vf) / (Ei + Em) | Em削減を最優先、Vfを最大化 |
| **変更の法則** | プログラムが存在する時間が長いほど変更確率が高まる | 柔軟性を確保、変更可能性を設計 |
| **不具合発生率の法則** | 不具合確率は変更の大きさに比例 | 小さな変更を優先、証拠に基づく修正 |
| **簡潔性の法則** | 管理しやすさは個々の部分の簡潔性に比例 | 複雑性を削ぎ落とす、DRY原則 |
| **検証の法則** | 動作はどれほど検証したかで決まる | テスト自動化、変更後の再検証 |

### 最重要の2文

- **実装にかかる作業量よりも管理にかかる作業量を減らすほうが重要だ。**
- **管理にかかる作業量はシステムの複雑性に比例する。**

この2つの文と、ソフトウェアの目的の理解、そしてシステムの複雑性は個々の部分の複雑性に由来することを承知していれば、すべてのデザイン判断を導き出せる。
