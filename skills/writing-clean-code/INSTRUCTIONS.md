# クリーンコード実践レシピ

## 概要

このスキルは、言語非依存のクリーンコードレシピ集です。25のコードスメルカテゴリをカバーし、実践的なリファクタリングパターンを提供します。

### MAPPER原則（唯一のソフトウェア設計公理）

すべてのクリーンコード実践は、以下の単一の原則から導き出されます：

**Model: Abstract, Partial, and Programmable Explaining Reality（モデル：抽象的、部分的、かつプログラム可能な現実の説明）**

この原則を略して**MAPPER**と呼びます。

#### MAPPER の構成要素

- **Model（モデル）**: 現実の特定の側面を特定の視点で見た結果。究極的な真理ではなく、現在の知識に基づく最も正確な理解
- **Abstract（抽象的）**: 契約と振る舞いに基づき、実装の詳細ではなく「何をするか」に焦点を当てる
- **Partial（部分的）**: 現実全体ではなく、関心のある振る舞いだけをモデル化する（過度な設計を避ける）
- **Programmable（プログラム可能）**: チューリングモデルや量子コンピュータなどのシミュレータで実行可能
- **Explaining（説明可能）**: なぜそう動くかを説明できる（ブラックボックスではない）
- **Reality（現実）**: 観測可能な環境の条件を再現し、現実世界の予測を可能にする

#### 全単射（Bijection）の原則

**現実世界のエンティティとコードオブジェクトは1対1で対応しなければならない。**

全単射が破られると以下の問題が発生します：

1. **1つのオブジェクトが複数の現実世界エンティティを表す**: 10メートルと10インチが両方とも数値10で表現され、単位なしで加算できてしまう（マーズ・クライメイト・オービターの事故原因）
2. **1つの現実世界エンティティを複数オブジェクトで表す**: 同一人物が「競技者」と「審判」の2つのオブジェクトとして存在し、一方への変更が他方に反映されない
3. **貧血オブジェクトとビジネスロジックの分離**: ビットコインウォレットが「データのみのオブジェクト」と「振る舞いのみのサービス」に分裂する
4. **無効なデータの自動補正**: 存在しない日付（2023年11月31日）を自動的に有効な日付に変換し、エラーを隠蔽する（フェイルファスト原則違反）

---

## 使用タイミング

### コードレビュー時
- Pull Request のコードスメル検出
- リファクタリング優先順位の判断
- 設計品質の客観的評価

### リファクタリング実施時
- レガシーコード改善
- 技術的負債の返済
- パフォーマンスと可読性のバランス調整

### 新規コード設計時
- 設計初期段階での品質確保
- アーキテクチャレビュー
- API設計の妥当性検証

### 学習・教育時
- コーディング規約の策定
- チーム内の品質基準統一
- 新規メンバーへのベストプラクティス教育

---

## コードスメル早見表

以下の25カテゴリのコードスメルを検出・対処するレシピを提供します。

| # | カテゴリ | 検出シグナル | 対処方針 | 詳細 |
|---|---------|------------|---------|------|
| 3 | 貧血モデル | ゲッター/セッターだけのクラス、public属性 | リッチオブジェクトに変換、振る舞いを追加 | [OBJECT-DESIGN.md](./references/OBJECT-DESIGN.md) |
| 4 | プリミティブ執着 | String/int多用、型システムの未活用 | 小さなオブジェクトに具象化（値オブジェクト） | [OBJECT-DESIGN.md](./references/OBJECT-DESIGN.md) |
| 5 | 変更可能性 | 変更可能なオブジェクト、セッター多用 | イミュータブルオブジェクト化 | [OBJECT-DESIGN.md](./references/OBJECT-DESIGN.md) |
| 6 | 宣言的でないコード | how（方法）にフォーカス、実装詳細の露出 | what（目的）を表現、宣言的スタイルに変換 | [CODE-READABILITY.md](./references/CODE-READABILITY.md) |
| 7 | 不適切な命名 | 曖昧な変数名、略語乱用、意図不明 | 意図を表す名前、ドメイン用語の活用 | [CODE-READABILITY.md](./references/CODE-READABILITY.md) |
| 8 | 不要なコメント | コードの内容を繰り返すコメント | 自己文書化コード、必要最小限のコメント | [CODE-READABILITY.md](./references/CODE-READABILITY.md) |
| 9 | 規約不統一 | チーム内でスタイルがバラバラ | linter/formatter導入、規約の明文化 | [CODE-READABILITY.md](./references/CODE-READABILITY.md) |
| 10 | 過度な複雑さ | 循環的複雑度が高い、ネストが深い | 関数分割、早期リターン、ガード節 | [COMPLEXITY-MANAGEMENT.md](./references/COMPLEXITY-MANAGEMENT.md) |
| 11 | 肥大化 | God Class、長すぎる関数/パラメータリスト | 責務の分離、メソッドオブジェクト | [COMPLEXITY-MANAGEMENT.md](./references/COMPLEXITY-MANAGEMENT.md) |
| 12 | YAGNI違反 | 将来必要「かもしれない」機能の実装 | 現在必要なものだけを実装 | [COMPLEXITY-MANAGEMENT.md](./references/COMPLEXITY-MANAGEMENT.md) |
| 13 | フェイルファスト欠如 | エラーの遅延検出、silent failure | 早期バリデーション、明示的な例外 | [COMPLEXITY-MANAGEMENT.md](./references/COMPLEXITY-MANAGEMENT.md) |
| 14 | 偶発的なif文 | ビジネスルールとフロー制御の混在 | ポリモーフィズム、ステートパターン | [CONTROL-FLOW.md](./references/CONTROL-FLOW.md) |
| 15 | Null乱用 | null チェックの氾濫、NullPointerException | Nullオブジェクトパターン、Optional型 | [CONTROL-FLOW.md](./references/CONTROL-FLOW.md) |
| 16 | 早すぎる最適化 | 根拠のないパフォーマンス改善 | 可読性優先、計測に基づく最適化 | [CONTROL-FLOW.md](./references/CONTROL-FLOW.md) |
| 17 | 高結合 | シングルトン乱用、グローバル依存 | 依存性注入、インターフェース分離 | [ARCHITECTURE.md](./references/ARCHITECTURE.md) |
| 18 | グローバル状態 | グローバル変数、静的可変状態 | コンテキストオブジェクト、依存性注入 | [ARCHITECTURE.md](./references/ARCHITECTURE.md) |
| 19 | 深い継承 | 継承階層が深すぎる、振る舞いの重複 | コンポジション優先、フラット化 | [ARCHITECTURE.md](./references/ARCHITECTURE.md) |
| 20 | テスト不足 | カバレッジ不足、テスタビリティ欠如 | TDD、AAAパターン、テストダブル | [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) |
| 21 | 技術的負債放置 | TODO放置、リファクタリング先送り | 負債の可視化、定期的な返済 | [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) |
| 22 | 例外処理不備 | 例外の握りつぶし、エラー情報の欠如 | 適切な例外設計、エンドユーザー向けエラー | [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) |
| 23 | メタプログラミング乱用 | 過度なリフレクション、eval多用 | 明示的コード優先、最小限の使用 | [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) |
| 24 | 型の誤用 | any/Any乱用、型安全性の欠如 | 厳密な型定義、ジェネリクス活用 | [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) |
| 25 | セキュリティ脆弱性 | 入力検証不足、SQLインジェクション | セキュリティファースト設計 | [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) |

---

---

## SOLID原則の概要

すべてのコード実装で必須の5つの原則:

### S - Single Responsibility Principle（単一責任の原則）
**「変更する理由」は1つだけ**
- 各クラス・関数は単一の責任のみを持つ
- 例: UserServiceはユーザー管理のみ、EmailServiceはメール送信のみ

### O - Open/Closed Principle（開放閉鎖の原則）
**拡張に開いており、修正に閉じている**
- 新機能追加時は既存コードを変更せず、拡張で対応
- インターフェースや抽象クラスを活用

### L - Liskov Substitution Principle（リスコフの置換原則）
**派生クラスは基底クラスと置換可能**
- サブクラスは親クラスの契約を破らない
- 継承よりコンポジションを優先

### I - Interface Segregation Principle（インターフェース分離の原則）
**クライアントが使用しないメソッドへの依存を強制しない**
- 大きなインターフェースより小さな特化したインターフェース
- 必要なメソッドのみを実装

### D - Dependency Inversion Principle（依存関係逆転の原則）
**上位モジュールは下位モジュールに依存しない**
- 両者は抽象に依存する
- 依存性注入（DI）を積極的に活用

**詳細は [SOLID-PRINCIPLES.md](./references/SOLID-PRINCIPLES.md) を参照してください。**

---

## サブファイルナビゲーション

レシピは以下の6つのサブファイルに分類されています。

### [SOLID-PRINCIPLES.md](./references/SOLID-PRINCIPLES.md) - SOLID原則の詳細解説
**カバー内容**: 単一責任、開放閉鎖、リスコフ置換、インターフェース分離、依存関係逆転

- 各原則の詳細な解説
- 悪い例と良い例の対比
- TypeScript/Go/Pythonのコード例
- 依存性注入（DI）の実践パターン

**主要原則**: SOLID全5原則（SRP, OCP, LSP, ISP, DIP）、DRY、KISS、YAGNI

---

### [OBJECT-DESIGN.md](./references/OBJECT-DESIGN.md) - オブジェクト設計（Ch.3-5）
**カバー内容**: 貧血モデル、プリミティブ執着、変更可能性

- リッチオブジェクトへの変換
- 値オブジェクトの作成
- イミュータビリティの実現
- カプセル化の強化
- ゲッター/セッターの排除

**主要レシピ**: 貧血オブジェクトのリッチ化、プリミティブの具象化、イミュータブル設計

---

### [CODE-READABILITY.md](./references/CODE-READABILITY.md) - 可読性・命名・規約（Ch.6-9）
**カバー内容**: 宣言的なコード、命名、コメント、コーディング規約

- 宣言的スタイルへの変換
- 意図を表す命名
- 自己文書化コード
- コメントの適切な使用
- チーム規約の統一

**主要レシピ**: 実装詳細の隠蔽、命名パターン、コメント削減、linter導入

---

### [COMPLEXITY-MANAGEMENT.md](./references/COMPLEXITY-MANAGEMENT.md) - 複雑さ管理（Ch.10-13）
**カバー内容**: 複雑さ、肥大化、YAGNI、フェイルファスト

- 循環的複雑度の削減
- God Classの分割
- 不要な機能の削除
- 早期バリデーション
- 重複コードの除去

**主要レシピ**: 関数分割、責務の分離、YAGNI原則、フェイルファスト実装

---

### [CONTROL-FLOW.md](./references/CONTROL-FLOW.md) - 制御フロー改善（Ch.14-16）
**カバー内容**: if文、Null、早すぎる最適化

- 条件分岐の削減
- ポリモーフィズムの活用
- Null安全な設計
- 可読性優先の最適化
- ガード節の使用

**主要レシピ**: if文のポリモーフィズム化、Nullオブジェクトパターン、計測に基づく最適化

---

### [ARCHITECTURE.md](./references/ARCHITECTURE.md) - アーキテクチャ品質（Ch.17-19）
**カバー内容**: 結合、グローバル状態、階層構造

- 結合度の低減
- シングルトンの排除
- グローバル変数の削除
- 継承からコンポジションへ
- 依存性注入

**主要レシピ**: 依存性逆転、グローバル状態の排除、継承階層のフラット化

---

### [DESIGN-SIMPLICITY.md](./references/DESIGN-SIMPLICITY.md) - ソフトウェアデザインの法則と簡潔性
**カバー内容**: ソフトウェアの目的、デザインの方程式、不具合発生率の法則、検証の法則

- 6つの普遍的な法則の解説
- デザインの方程式 D = (Vn + Vf) / (Ei + Em)
- 「管理にかかる作業量を減らすことが最重要」の原則
- 最高のデザインの定義

**主要原則**: デザインの方程式、不具合発生率の法則、検証の法則、DRY原則

---

### [SIMPLICITY-PRACTICE.md](./references/SIMPLICITY-PRACTICE.md) - 簡潔性の実践
**カバー内容**: 簡潔性の法則、一貫性、読みやすさ、命名、コメント、DRY

- 簡潔性の相対性と文脈依存性
- 一貫性による管理容易性の向上
- スペースの取り方によるコード構造の可視化
- 命名の長さと明確さのバランス
- コメントの「なぜ」の説明

**主要原則**: 簡潔性の法則、一貫性、読みやすさ、DRY原則

---

### [COMPLEXITY-PATTERNS.md](./references/COMPLEXITY-PATTERNS.md) - 複雑性のパターンと対処
**カバー内容**: 変更の法則、3つの間違い、複雑性の7要因、技術選定、書き直し判断

- 変更の法則と時間経過による変更確率の増大
- YAGNI拡張版、硬直設計、オーバーエンジニアリングの検出と対処
- インクリメンタルな開発とデザイン
- 技術選定の3基準（生き残る確率、相互運用性、品質へのこだわり）
- 書き直しの5条件と判断フローチャート

**主要原則**: 変更の法則、インクリメンタルデザイン、段階的リデザイン

---

### [REFACTORING-CATALOG.md](./references/REFACTORING-CATALOG.md) - リファクタリングカタログ
**カバー内容**: 体系的リファクタリングの10ルール、13パターン、コンパイラ協調

- 関数を5行以内に保つルール体系
- 13の機械的リファクタリングパターン
- コンパイラの強み/弱みを活用した安全な変更
- コード削除の哲学

**主要パターン**: Extract Method, Replace Type Code with Classes, Introduce Strategy Pattern

---

### [CODE-CONTRACTS.md](./references/CODE-CONTRACTS.md) - 抽象化レイヤーとコードコントラクト
**カバー内容**: 抽象化レイヤー設計、明示的・暗黙的コントラクト、Small Print の危険性、ランタイム強制

- 抽象化レイヤーが達成する4つの品質の柱（可読性・モジュール性・再利用性・テスタビリティ）
- 明示的契約 vs 暗黙的契約の比較表（信頼性の違い）
- Small Print を排除する3つの方法（型システム・可視性制限・戻り値設計）
- 他のエンジニアがコードを理解する手段（信頼性順）
- 事前条件・事後条件・不変条件の実装とチェック vs アサーションの使い分け

**主要パターン**: ファクトリメソッドパターン、コードコントラクトの明示化、型による契約伝達

---

### [ERROR-SIGNALING.md](./references/ERROR-SIGNALING.md) - エラーシグナリング戦略
**カバー内容**: 回復可能性の判断、Fail Fast/Loud 原則、8つのシグナリング方式の比較

- エラー回復可能性の判断フロー（「呼び出し側のみが回復可能性を判断できる」）
- Fail Fast / Fail Loud 原則と回復可能性のスコープ
- 8方式の詳細比較表（Checked/Unchecked例外, Nullable, Result型, Outcome型, Promise, マジック値, 何もしない）
- @CheckReturnValue アノテーションと コンパイラ警告の活用
- エラーを隠す4つのアンチパターン（デフォルト値・Nullオブジェクト誤用・何もしない・握りつぶし）

**主要パターン**: Result型, Checked例外, Nullable戻り値, @CheckReturnValue

---

### [SURPRISE-PREVENTION.md](./references/SURPRISE-PREVENTION.md) - サプライズ防止：予期しない動作の排除
**カバー内容**: マジック値、Nullオブジェクトパターン、副作用、入力パラメータ変更、Enum処理

- マジック値の問題（型システムが検出できない理由・代替パターン）
- Nullオブジェクトパターンの判断基準（空コレクション[良] vs ID文字列[悪] vs 複雑オブジェクト[危険]）
- 予期しない副作用の3つの問題（コスト・仮定違反・マルチスレッドバグ）と命名による解決
- 入力パラメータ変更禁止（コピーしてから変更するパターン）
- 誤解を招く関数の回避（クリティカルパラメータを必須化）
- 網羅的 switch 文 + 全 Enum 値テスト（default ケースの罠）

**主要パターン**: コピーオンライト防御、exhaustive switch、@CheckReturnValue

---

### [MISUSE-PREVENTION.md](./references/MISUSE-PREVENTION.md) - 誤用防止：物理的に間違いにくいコードの設計
**カバー内容**: 不変性（浅い・深い）、汎用型の危険性、時間の扱い、単一真実源

- 浅い不変性: final + setter 削除、Builderパターン、コピーオンライトパターン
- 深い不変性: 防御的コピー vs ImmutableList（参照による深い変更可能性の解決）
- 汎用型の誤用: List<List<Double>> / Pair の問題と専用型定義（LatLong等）
- 時間の型安全: 整数表現の3つの問題（瞬間vs期間混同・単位不一致・タイムゾーン混乱）と Duration/Instant
- データの単一真実源: 派生データは計算で求める（遅延計算＋キャッシュ）
- ロジックの単一真実源: serialize/deserialize を1クラスに集約

**主要パターン**: Builderパターン、コピーオンライトパターン、ImmutableList、専用型定義

---

### [QUALITY-ASSURANCE.md](./references/QUALITY-ASSURANCE.md) - 品質保証（Ch.20-25）
**カバー内容**: テスト、技術的負債、例外、メタプログラミング、型、セキュリティ

- テスト戦略
- 技術的負債の管理
- 例外処理設計
- メタプログラミングの適切な使用
- 型安全性の確保
- セキュリティベストプラクティス

**主要レシピ**: TDD、負債の可視化、例外設計パターン、型システム活用、セキュリティ対策

---

### [CLEAN-CODE-BASICS.md](./references/CLEAN-CODE-BASICS.md) - クリーンコードの基礎
**カバー内容**: 日常的なコーディングで適用すべき基本原則

- 意図を明確にする命名規則
- 小さく単一責任の関数設計
- 早期リターンによるネスト削減
- マジックナンバーの排除

---

### [QUALITY-CHECKLIST.md](./references/QUALITY-CHECKLIST.md) - 品質チェックリスト
**カバー内容**: 実装完了前の確認項目

- 設計原則の遵守チェック
- コードスメルの検出
- リファクタリングの判断基準

---

### [QUICK-REFERENCE.md](./references/QUICK-REFERENCE.md) - クイックリファレンス
**カバー内容**: 素早く参照できる簡潔な情報

- SOLID原則の1行まとめ
- よくある間違いと修正方法
- コードレビューポイント

---

## MAPPER原則クイックリファレンス

### 全単射チェックリスト

コード設計時に以下を自問してください：

- [ ] **1つのオブジェクト = 1つの現実世界エンティティか？**
  - 数値型が複数の物理量（メートル、インチ、秒等）を表していないか？
  - 汎用的な辞書やタプルで異なる概念を表現していないか？

- [ ] **1つの現実世界エンティティ = 1つのオブジェクトか？**
  - 同一人物が複数のオブジェクト（CustomerとUser等）に分裂していないか？
  - データオブジェクトとビジネスロジックが分離していないか？

- [ ] **オブジェクトは振る舞いを持つか？**
  - 単なるデータ構造（貧血オブジェクト）になっていないか？
  - ゲッター/セッターだけのクラスになっていないか？

- [ ] **エラーは早期に検出されるか？**
  - 無効なデータを自動補正していないか？
  - エラーを隠蔽せず明示的に失敗するか？

### 抽象化レベルチェックリスト

- [ ] **契約と振る舞いに基づいているか？**
  - インターフェースが実装詳細を露出していないか？
  - 「何をするか」が明確で、「どうするか」が隠蔽されているか？

- [ ] **部分的にモデル化しているか？**
  - 関心のある振る舞いだけに焦点を当てているか？
  - 将来必要かもしれない機能（YAGNI違反）を含んでいないか？

- [ ] **説明可能か？**
  - なぜそう動くのか説明できるか？
  - ブラックボックス化していないか？

---

## AskUserQuestion 使用ガイド

### 確認が必要な場面

以下の状況では、AskUserQuestion ツールでユーザーに確認してください：

#### 1. リファクタリング優先順位の判断

複数のコードスメルが検出された場合：

```
質問: 「以下のコードスメルが検出されました。どの順序で対処しますか？」
選択肢:
- 高結合の解消（依存性注入導入）
- 貧血オブジェクトのリッチ化
- テストカバレッジの向上
- 命名の改善
```

#### 2. パフォーマンスと可読性のトレードオフ

早すぎる最適化が疑われる場合：

```
質問: 「パフォーマンス最適化を検討していますが、可読性が低下します。どちらを優先しますか？」
選択肢:
- 可読性優先（MAPPER原則に従う）
- パフォーマンス優先（計測データがある場合）
- 一旦可読性優先で実装し、ボトルネック特定後に最適化
```

#### 3. 破壊的リファクタリングの実施可否

意味を変えるリファクタリングの場合：

```
質問: 「このリファクタリングはシステムの振る舞いを変更する可能性があります。実施しますか？」
選択肢:
- 包括的なテストスイートがあるため実施
- テストを先に作成してから実施
- 実施しない
```

#### 4. アーキテクチャ変更の影響範囲

シングルトン排除やグローバル状態の削除時：

```
質問: 「グローバル状態の排除には複数ファイルの変更が必要です。スコープをどうしますか？」
選択肢:
- 全箇所を一度に変更
- 段階的に変更（新規コードから）
- 最も影響が大きい箇所のみ
```

---

### 確認が不要な場面

以下のケースは明確なアンチパターンであり、ユーザー確認なしで修正できます：

#### 1. 明確なアンチパターン
- Null 乱用（Nullオブジェクトパターンで置換）
- God Class（責務の分離）
- マジックナンバー（名前付き定数化）
- 重複コード（DRY原則適用）

#### 2. コーディング規約違反
- 命名規約違反
- インデント不統一
- 不要なコメント削除
- linter警告の修正

#### 3. 安全なリファクタリング
- 変数名の変更（IDEの自動リファクタリング）
- メソッド抽出
- プライベート関数の内部実装変更
- 型定義の追加（動作は変わらない）

---

## 可読性 vs パフォーマンスの原則

本スキルは**可読性優先**の立場を取ります。

### 基本方針

1. **可読性を優先**: MAPPER原則に従い、現実世界を正確にモデル化
2. **クリーンコードを書く**: まず動作し、理解しやすいコードを作成
3. **テストでカバー**: 振る舞いを保護するテストを作成
4. **ボトルネックを特定**: プロファイラで計測し、パレートの法則を適用
5. **20%を改善**: 重要なボトルネック20%に対処して80%の改善を達成

### パレートの法則（80/20ルール）

ソフトウェアパフォーマンスにおいて：
- ボトルネックの20%に対処することで、パフォーマンスの80%が向上する
- 早すぎる最適化はわずかな改善しかもたらさず、クリーンコードを損なう

### 最適化の判断基準

✅ **最適化すべき場合**:
- プロファイラで計測済みのボトルネック
- ミッションクリティカルなシステム
- 明確なパフォーマンス要件がある

❌ **最適化すべきでない場合**:
- 根拠のない推測
- 「なんとなく遅そう」という感覚
- クリーンコードを犠牲にする場合

---

## 既存スキルとの使い分け

### enforcing-type-safety との関係

**enforcing-type-safety**: 型安全性に特化
**writing-clean-code**: 型の誤用（Ch.24）を含む包括的品質

### testing との関係

**testing**: テスト戦略全般
**writing-clean-code**: テスト不足（Ch.20）の検出とリファクタリング

---

## レシピの適用原則

### 1. ガイドラインであって厳格なルールではない

コードスメルは「改善の機会を示す指標」であり、盲目的に適用してはいけません。

### 2. コストと利益を評価

レシピを適用する前に：
- 問題を理解する
- 設計への影響を評価する
- 実用的・状況的な考慮事項を検討する

### 3. テストスイートが安全網

意味を変えるリファクタリングを含むレシピは、包括的なテストスイートが必要です。

### 4. リファクタリングと機能開発を分離

以下を同時に行わないこと：
- バグ修正 + リファクタリング
- 新機能開発 + リファクタリング

### 5. 自分の言語に翻訳

レシピは擬似コードとして読み、使用している言語の慣用句に翻訳してください。

---

## プログラミングパラダイムとの関係

本スキルのレシピは以下のパラダイムに応用可能です：

- **オブジェクト指向**: MAPPER原則、リッチオブジェクト、カプセル化
- **関数型**: イミュータビリティ、宣言的スタイル、副作用の排除
- **構造化**: 複雑さの管理、早期リターン、ガード節

---

## 用語の使い方

本スキルでは以下の用語を同義で使用します：

- **メソッド / 関数 / 手続き**
- **属性 / インスタンス変数 / プロパティ**
- **プロトコル / 振る舞い / インターフェース**
- **引数 / コラボレータ / パラメータ**
- **匿名関数 / クロージャ / ラムダ**
- **欠陥 / バグ**（「欠陥」を推奨）

---

## 変更容易性の重要性

クリーンコードの最終目標は**変更容易性**です：

- ソフトウェアは常に進化する
- 学び続け、適応し続ける必要がある
- 迅速に更新できないシステム（組み込み、宇宙探査機、スマートコントラクト等）では特に重要

本スキルは、保守性と進化性を重視した設計を支援します。

---

## 機械生成コードとの共存

AI コーディング支援ツール（GitHub Copilot、ChatGPT等）の時代においても、クリーンコードは必要です：

- AI は「副操縦士」であり、設計判断は人間が行う
- AI 生成コードはレビューと改善が必要
- 本スキルのレシピで AI 生成コードを評価・改善できる
- 技術的ケンタウロス（人間+AI）として機能する

---

## まとめ

このスキルは、MAPPER原則という単一の公理から導き出された実践的なクリーンコードレシピ集です。25のコードスメルカテゴリをカバーし、言語非依存の普遍的な品質向上手法を提供します。

**コードレビュー、リファクタリング、新規設計のすべての場面で、本スキルと6つのサブファイルを参照してください。**
