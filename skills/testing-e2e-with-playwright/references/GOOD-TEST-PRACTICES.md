# 良いE2Eテストの書き方

E2Eテストの設計原則・ツール選定・テスト技法・保守性パターンを体系的にまとめます。
具体的なAPI操作（ロケーター・アサーション・モッキング）は他のreferencesファイルを参照してください。

---

## ソフトウェアテストの7原則

E2Eテスト設計の根拠となる普遍的な原則です。

| 原則 | 内容 |
|------|------|
| **1. テストは欠陥の存在を示す** | テストで「問題なし」は証明できない。欠陥がある可能性を減らすだけ |
| **2. 全数テストは不可能** | すべての組み合わせをテストする時間も予算もない。テスト技法で絞り込む |
| **3. 早期テスト** | 欠陥は発見が遅れるほど修正コストが増加する |
| **4. 欠陥の偏在** | バグは特定のモジュールに集中する傾向がある |
| **5. テストの弱化** | 同じテストを繰り返すと欠陥発見率が下がる |
| **6. テストはコンテキスト次第** | 適切なテスト手法はシステムの特性によって異なる |
| **7. 「欠陥ゼロ」の落とし穴** | テストを全部パスしても、仕様が間違っていれば品質は上がらない |

**E2Eテストへの適用**: 原則2から、すべてのバリデーションパターンをE2Eでテストしようとしない。ユニットテストとの役割分担が必須。

---

## テスト設計の考え方

### テストピラミッドとテスティングトロフィー

```
テストピラミッド（サーバサイド中心）   テスティングトロフィー（フロントエンド中心）

        ┌──────┐                            ┌────────┐
        │ E2E  │ ← 少数・高コスト            │  E2E   │
        ├──────┤                        ┌───┴────────┴───┐
        │統合  │                        │  Integration   │
        ├──────┤                    ┌───┴────────────────┴───┐
        │Unit  │ ← 多数・低コスト    │       Unit             │
        └──────┘                    └───────────────────────-┘
                                    ┌───────────────────────-┐
                                    │    Static Analysis      │
                                    └───────────────────────-┘
```

**どちらを選ぶか**: Reactのような宣言的フレームワークはサーバ通信がライブラリに隠蔽されるため、インテグレーションテストが自然に多くなる（トロフィー型）。Vueのようにライフサイクルメソッドで処理が明示される場合はピラミッド型に近づく。

**アンチパターン: アイスクリームコーン型**

```
        ┌──────────────────────────────────┐
        │         手動テスト（多）           │ ← 属人化・コスト大
        ├──────────────────┐               │
        │    E2E（中）      │               │
        ├────────┐         │               │
        │Unit（少）│        │               │
        └────────┴─────────┴───────────────┘
```

手動テストが多くユニットテストが少ない逆ピラミッド。CIに組み込めず、リリースのたびに人手が必要になる。

---

### E2EとユニットテストのROI最適化

```
❌ すべてをE2Eでテスト（非効率）

ログイン → ファイルアップロード → バリデーション100ケース
= 1ケースあたり数十秒 × 100 = 数時間

✅ ユニットテスト + E2Eの組み合わせ

ユニットテスト: バリデーションロジック100ケース（秒単位）
E2Eテスト:
  1. ログイン
  2. ファイルアップロード
  3. 必須項目1つを除いて入力
  4. エラー発生を確認
  5. 残りの項目も入力して正常終了を確認
= 代表的な1ケースのみ
```

**判断基準**: ユニットテストでロジックをカバー済みであれば、E2Eは「正しく統合されているか」の確認に絞る。

---

## テスト技法（ブラックボックステスト）

全数テストが不可能なため、少ないケースで効率よく品質を担保する技法を使う。

### 同値分割法・境界値分析

挙動が同じになる入力の「区画」を見つけ、区画ごとに代表値をテストする。

```
例：商品購入数（1〜1000個、10個以上で送料無料）

区画分割:
  ┌─────────┬──────────────────────┬─────────────────────┬─────────┐
  │ 負の数   │ 1〜9（送料あり）      │ 10〜1000（送料無料）  │ 1001以上 │
  │ → エラー │ → 送料発生           │ → 送料無料           │ → エラー │
  └─────────┴──────────────────────┴─────────────────────┴─────────┘

テストケース（同値分割）: -1, 5, 50, 1001 の4ケース
境界値テスト:           0, 1, 9, 10, 1000, 1001 の6ケース
```

**E2Eでの適用**: 複雑な条件のテストは結果（エラー/正常/特別ケース）の数だけに絞る。詳細な境界値はユニットテストに任せる。

### デシジョンテーブルテスト

複数の条件が絡む場合に、条件の組み合わせを表で整理する。

```
例：VIP会員割引あり + 購入数 + 配送先 の組み合わせ

エラー条件（-1以下 or 1001以上）を最初に処理し、
VIP会員なら数量に関係なく送料無料、
一般会員は数量によって判定、
という順で整理するとケース数が激減する。
```

**E2Eでの適用**: デシジョンテーブルで整理した後、「エラー・有料・無料」の3種の結果パターンだけをE2Eでテストすれば十分。

### 状態遷移テスト

現在の状態・発生イベント・遷移先を「状態遷移図」または「状態遷移表」で整理する。

```
例：ログインフローの状態遷移
  状態: 未ログイン / ログイン中 / セッション期限切れ
  イベント: ログイン成功 / ログイン失敗 / タイムアウト / ログアウト

  状態遷移表:
  ┌──────────────┬─────────────┬─────────────┬──────────────┐
  │ 現状態       │ イベント     │ 次状態       │ テストすべきか│
  ├──────────────┼─────────────┼─────────────┼──────────────┤
  │ 未ログイン   │ ログイン成功 │ ログイン中   │ ✅ E2Eで確認 │
  │ 未ログイン   │ ログイン失敗 │ 未ログイン   │ ✅ E2Eで確認 │
  │ ログイン中   │ タイムアウト │ セッション切│ ✅ E2Eで確認 │
  │ ログイン中   │ ログアウト   │ 未ログイン   │ ✅ E2Eで確認 │
  └──────────────┴─────────────┴─────────────┴──────────────┘
```

**メリット**: 仕様の抜け漏れ発見に有効。「ログアウト直後に戻るボタンを押したら？」などのエッジケースが整理される。
**E2Eでの適用**: 遷移の組み合わせが多い場合でも、「認証あり→なし」「期限切れ→リダイレクト」など結果パターンに絞ってテストする。

---

### ユースケーステスト（シナリオテスト）

ユーザーがシステムを使う一連のシナリオをテストとして記述する。E2Eテストの主戦場。

```typescript
// ユーザーシナリオ: 商品を検索して購入する
test("商品検索から購入完了まで", async ({ page }) => {
  // Given: ログイン済みユーザー
  // When: 商品を検索 → カートに追加 → 決済
  // Then: 注文確認メールが届く
});
```

**一筆書きテストの適切な使い所**:
- ログイン → 機能操作 → 確認 の一連フローは1テストにまとめても良い
- ただしテストが長くなり過ぎると「正しい動き」が見えにくくなる
- **判断基準**: 独立して意味をなすシナリオなら分割、連続したユーザー操作ならまとめる

---

## E2Eテストツールの選定

### Cypress vs Playwright vs Puppeteer の比較

| 特性 | Cypress | Playwright | Puppeteer |
|------|---------|------------|-----------|
| **種別** | テストフレームワーク | テストフレームワーク | ブラウザ操作ライブラリ |
| **ブラウザ** | Chrome系中心 | Chromium/WebKit/Firefox | Chrome/Chromium のみ |
| **実行方式** | ブラウザ内でテストランナーを動作 | ブラウザとは別プロセス | CDP経由でブラウザ操作 |
| **複数タブ** | 制限あり | ✅ サポート | ✅ サポート |
| **複数言語** | JavaScript/TypeScript | JS/TS/Python/.NET/Java | JavaScript/TypeScript |
| **テストランナー** | ✅ 内蔵 | ✅ 内蔵 | ❌ 別途必要（Jest等） |
| **アサーション** | ✅ 内蔵 | ✅ 内蔵 | ❌ 別途必要 |
| **Cypressとの差** | - | 複数言語、複数タブ対応 | テストに特化していない |

**Puppeteerを選ぶ場面**: E2Eテストより「ブラウザ自動化」や「スクレイピング」、または非機能テスト（パフォーマンス計測、カバレッジ）が主目的の場合。

**Cypressを選ぶ場面**: すでにCypressで安定運用中、またはチームがCypressに習熟している場合。新規プロジェクトであればPlaywrightが現時点で優位。

### フレームワーク別のE2Eテスト統合パターン

| フレームワーク | 推奨ツール | 統合方法 |
|--------------|-----------|---------|
| **Svelte/SvelteKit** | Playwright（公式推奨） | `npm create svelte@latest` でPlaywright選択肢あり |
| **Vue.js** | Cypress（公式推奨）またはPlaywright | `npm create vue@latest` でCypress/Playwright選択肢あり |
| **React (Next.js)** | PlaywrightまたはCypress | 公式ドキュメントで両方紹介。Next.jsもPlaywright/Cypress両対応 |
| **Angular** | PlaywrightまたはCypress | Angular v15でProtractor廃止、移行先として推奨 |
| **Electron** | Playwright（試験的） | CDP経由でElectronをテスト可能 |

**注意**: Reactは特定のE2EツールをReact自体は推奨していない。チームの習熟度やエコシステムで選択する。

---

## テストレベルとPlaywrightのポジション

ISTQBが定めるテストレベルは5段階。Playwrightはどのレベルにも対応できる。

| テストレベル | 目的 | Playwrightでの対応 |
|-------------|------|-------------------|
| **コンポーネントテスト（UT）** | 単一モジュールの検証 | `@playwright/experimental-ct-*` で可能（推奨はVitest/Jest） |
| **コンポーネント統合テスト** | 複数モジュール連携の検証 | API モック + UIフローで対応可能 |
| **システムテスト（E2E）** | システム全体のシナリオ確認 | ✅ Playwrightの主戦場 |
| **システム統合テスト** | 外部システムとの連携確認 | `context.route()` でモック化して対応 |
| **受け入れテスト** | ユーザー視点での最終確認 | ✅ 発注者側がPlaywrightで自動化する場合も |

**アジャイル開発での扱い**: ウォーターフォールと違い、UT・統合・システムテストを1イテレーション内で同時に行う。テストレベルは「工程」ではなく「確認の目的」として理解する。

**炭鉱のカナリア戦略**: テストが一切ない状態からなら、システムテスト（E2E）を最初に導入するのが有効。「システムとして成り立つか」を確認する最小限の自動化から始める。

---

## 良いE2Eテストの設計原則

### 原則1: テストは単独で実行できること

前のテストの結果を前提としたテストを書かない。

```typescript
// ❌ 前のテストに依存（順番が変わると壊れる）
test("注文を作成する", async ({ page }) => { /* ... */ });
test("作成した注文を更新する", async ({ page }) => {
  // "注文を作成する" が先に成功している前提
});

// ✅ 各テストが独立したデータを持つ
test("注文を更新する", async ({ page, seedOrder }) => {
  // fixtureで専用の注文データを用意
  await orderPage.updateOrder(seedOrder.id, newData);
});
```

**なぜ重要か**: `--grep` で特定テストのみ実行したとき、または並列実行時に、テストの結果が順番依存で変わると原因特定が困難になる。

### 原則2: テストは単独で読めること（DAMP原則）

テストコードはアプリケーションコードより**DRY（繰り返し禁止）より DAMP（説明的かつ意味のある繰り返し）**を優先する。

```typescript
// ❌ 過度な共通化（テスト単体では何をしているかわからない）
test("注文フロー", async () => {
  await runOrderFlow({ type: "yamato", count: 2 });
  await verifyShipment({ carrier: "yamato" });
});

// ✅ テストコードを読むだけでシナリオが理解できる
test("ヤマト宅急便で2個注文した場合、配送スリップが生成される", async ({ page }) => {
  await page.getByRole("button", { name: "注文追加" }).click();
  await page.getByLabel("配送業者").selectOption("ヤマト");
  await page.getByLabel("個数").fill("2");
  await page.getByRole("button", { name: "確定" }).click();

  await expect(page.getByText("配送スリップ生成済み")).toBeVisible();
});
```

**例外として共通化が妥当なもの**:
- ログイン処理（`auth.setup.ts` + `storageState`）
- `beforeEach` での共通前処理
- Page Objectへの高レベル操作の抽象化

---

## フレークテスト（不安定なテスト）の根本原因

`ASSERTIONS-AND-RELIABILITY.md` で対策（waitForTimeout禁止等）を扱っているが、
ここでは**なぜフレークが発生するか**の根本原因を整理する。

### 原因1: CSS/DOM構造への依存

```
CSSクラス名の変更 → ロケーターが要素を見つけられない → テスト失敗

例: .btn-primary → .button-primary へリネーム
   または同じクラスを持つ別コンポーネントが追加されて複数マッチ
```

**本質**: テストが「実装の詳細（内部構造）」に結びついている。ドメインエキスパート（利用者側の専門家）が読んでも意味がわかるロケーターにする。

### 原因2: タイミング依存

```
ローカル（高速）: テストが成功
CI サーバー（低速）: 同じテストが失敗

原因:
- 固定待機時間がCIでは不十分
- ネットワーク遅延の差
- データ量増加でDBクエリが遅くなる
```

**本質**: 環境によって変動する「絶対時間」に依存している。条件ベースの待機（要素が表示されるまで、URL が変わるまで等）に置き換える。

### 原因3: テストデータの共有

```
並列実行中:
  テスト1 → 注文#1001を処理中
  テスト2 → 注文#1001を処理中（競合！）
  → 両方が不安定な結果に
```

**本質**: 複数テストが同じデータを操作することで干渉が発生。各テストは専用のシードデータを使う。

### 原因4: テスト順序への依存

```
テストA が作ったデータをテストBが使う
→ テストAが失敗 or スキップされるとテストBも壊れる
```

**本質**: 原則1（独立実行可能性）の違反。前のテストの副作用を前提としない。

---

## テストの保守性を高めるパターン

### 確認テストとリグレッションテスト

| 種別 | 目的 | タイミング |
|------|------|-----------|
| **確認テスト** | 特定の不具合が修正されたことを確認 | バグ修正のたびに追加 |
| **リグレッションテスト** | 既存機能が壊れていないことを確認 | CI でのすべてのビルド |

**パターン**: バグ報告 → **再現するE2Eテストを書く** → 修正 → テストをCIに追加（リグレッション防止）

### テスト自動化の8原則

テスト自動化の投資対効果を維持するために意識する原則:

1. **手動テストはなくならない**: 探索的テスト・UXテストは人間が担う
2. **手動でも効果のないテストを自動化しても無駄**: まず手動で欠陥を発見してから自動化
3. **自動テストは書いたことしかテストしない**: 仕様外の動作は検知できない
4. **効用はコスト削減だけではない**: 開発速度・信頼性・ドキュメントとしての価値もある
5. **継続的に開発するもの**: 機能追加に合わせてテストも進化させる
6. **プロジェクト初期から検討**: 後からテストを追加するのは困難
7. **新種のバグが見つかることは稀**: リグレッション防止が主目的
8. **テスト結果分析という新タスクが生まれる**: 失敗の原因調査工数を見込む

---

## アンチパターン集

| アンチパターン | 問題 | 対策 |
|--------------|------|------|
| **CSSクラスでロケーター** | リファクタリングで即座に壊れる | `getByRole()` > `getByLabel()` > `getByTestId()` |
| **FixedTimeWait** | CI環境の速度差でフレーク | Web-First Assertions の条件ベース待機 |
| **共有テストデータ** | 並列実行で競合が発生 | テストごとに専用シードデータを用意 |
| **テスト順序依存** | テストを単独実行すると失敗する | 各テストが独立したデータを持つ |
| **テストコードのDRY化過剰** | テストが読めない・修正影響が広い | DAMP原則を優先（適切なコピー&ペーストは許容） |
| **E2Eで全バリデーションをカバー** | テスト実行時間が数時間になる | ユニットテストにロジックを任せ、E2Eは代表1ケースのみ |
| **test.skip() の放置** | 実質的にテストが機能していない | テストが通るようにシードデータ・モック・コードを修正 |
| **アイスクリームコーン型** | CIに組み込めず手動テストに依存 | ユニットテストを増やしてピラミッド型に近づける |
| **モックの低水準化** | ヘッダ順序変更などで偽陽性が増える | Web APIレベルの高水準モック（`context.route()`）を使う |
| **Puppeteerをテストフレームワークとして使う** | テストランナー・アサーションを別途整備する必要 | E2Eテストが主目的ならPlaywrightを選ぶ |

---

## モック（テストダブル）の種類と選択

| 種別 | 特徴 | 使い所 |
|------|------|-------|
| **スタブ** | 機械的にOKを返す | 外部APIが不要なシナリオ確認 |
| **モック** | 条件付きでレスポンスをプログラミング | 複数パターンのレスポンス検証 |
| **スパイ** | モジュール間の通信を記録 | 呼び出し回数・順序の検証 |
| **フェイク** | 互換のある代替実装 | LocalのPostgreSQLでAurora代替など |

**推奨**: なるべく**フェイク**（互換代替実装）を使い、モックは「代替実装がない場合」や「エラーを意図的に再現したい場合」に限定する。モックの粒度は Web API レベル（高水準）に留める。

---

## プロジェクト導入のアプローチ

テストゼロのプロジェクトに E2E テストを導入する際の3つの戦略。

### パターン1: 人力テストからE2Eテストへ移行

手動で行っている動作確認をそのままテストコードに変換する最もとっつきやすい方法。

- 「この機能が動かないとシステムとして成り立たない」ケースを最初にテスト化
- 動作確認として行う「ログイン→操作→確認」の手順をそのまま記述
- **注意**: 思いついた順に書くと不均衡になりやすい。環境整備が難しいテストが放置される傾向がある

### パターン2: テストシナリオを洗い出してから実装

ユースケースベースでシナリオをリストアップしてからテストを書く。抜け漏れを防ぎやすい。

**洗い出しのチェックリスト**:

| 観点 | 確認内容 |
|------|---------|
| **正常系** | 各機能がユーザーマニュアル通りに動くか |
| **ページ遷移** | 未訪問ページがないか、遷移先URLが正しいか、権限制御が効いているか |
| **操作可能な要素** | ボタン・リンク・フォーム・チェックボックス・セレクトが機能するか |
| **エラー箇所** | 入力バリデーション・APIタイムアウト・セッション期限切れが適切に処理されるか |
| **ブラウザ操作** | 戻る・進む・更新でアプリが正常に機能するか、ログアウト後の戻るボタンがリダイレクトするか |

**重要**: バリデーションのエッジケースはユニットテストに任せ、E2E では「正常ケースと異常ケースでユーザーへの表示がどう変わるか」に集中する。

### パターン3: ユニットテストから始める

小スコープのユニットテストを積み上げ、E2Eは後から追加していく。

- **推奨場面**: 開発初期でUIとバックエンドがまだ繋がっていないフェーズ
- ユニットテストで検知できない不具合が見えてきたタイミングで E2E を追加
- E2E は「壊れやすい」特性があるため、スコープを狭くして修正コストを下げることを意識する

---

## E2Eテストのリポジトリ配置

| 配置方式 | メリット | デメリット | 推奨場面 |
|---------|---------|----------|---------|
| **専用リポジトリ** | 依存ライブラリ・CI を分離できる。マイクロフロントエンドでも置き場が一か所 | アプリの変更とテストの実行タイミングが乖離しやすい。定期バッチ等の工夫が必要 | マイクロサービス・複数フロントエンドリポジトリがある場合 |
| **フロントエンドリポジトリに相乗り** | PRのたびにCIでE2Eを実行できる。ローカルからも実行しやすい | 依存ライブラリ・ESLint設定が混在するリスクがある | 単一リポジトリ・モノレポ構成 |

**相乗り時の推奨構成**: E2E 専用ディレクトリを作り、`package.json` をアプリと分離する。`eslint.config.js` も E2E 用を別途用意すると干渉を防げる。
