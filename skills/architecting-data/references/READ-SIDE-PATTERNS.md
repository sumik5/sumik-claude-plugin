# Read-Side Optimization Patterns

Read-Sideの最適化パターン詳細リファレンス。トランザクショナルシステムにおけるRead負荷のスケーリング戦略を体系化します。

---

## 1. Read Replicas

### 概要

Read Replicasは、プライマリデータベースのコピーを作成し、Read専用トラフィックを分散させる最もシンプルなスケーリング手法です。

### レプリケーション方式

| 方式 | 説明 | 特徴 |
|------|------|------|
| **Statement-based** | SQLステートメントをログに記録し、レプリカで再実行 | シンプルだが非決定的関数（NOW()等）で問題発生 |
| **Row-based** | 実際の行変更をレプリケート | より安全だがログサイズ増加 |

### レプリケーションモード

| モード | 説明 | ユースケース |
|--------|------|------------|
| **非同期** | プライマリは即座にACK、レプリカは後で適用 | 高スループット必要。staleness許容可能 |
| **同期** | 少なくとも1つのレプリカが適用確認後にACK | 強い整合性必要。レイテンシ増加許容可能 |

### トポロジー

#### Single-Primary with Multiple Read Replicas

**構成**: 1つのプライマリ + 複数のReadレプリカ

**適用場面**:
- Read負荷がWrite負荷を大幅に上回る
- 商品検索、注文履歴照会等

**制約**:
- Write負荷はスケールしない
- プライマリがボトルネックになる可能性

#### Primary-Replica Cascading

**構成**: レプリカが他のレプリカの親になる

**適用場面**:
- 地理的分散
- リージョン間レプリケーション負荷軽減

**制約**:
- レプリケーションラグ増加
- 下流レプリカほどstaleになりやすい

#### Multi-Primary Replication

**構成**: 複数のプライマリノードが書込みを受け付け、相互同期

**適用場面**:
- マルチリージョンでローカル書込み必要
- 地域ごとの在庫管理システム

**制約**:
- コンフリクト解決が複雑
- データ不整合リスク

#### Geo-Replicated Read Replicas

**構成**: 複数リージョンにレプリカ配置

**適用場面**:
- グローバルユーザーベース
- 低レイテンシ必須

**制約**:
- リージョン間レプリケーションラグ
- リアルタイム価格、プロモーションには不適

### 課題と緩和策

| 課題 | 問題と影響 | 緩和策 |
|------|-----------|--------|
| **Replication Lag** | レプリカがstaleになり、古いデータを返す | レプリカラグ監視。クエリルーティング戦略で新鮮なレプリカに誘導 |
| **Query Routing** | レプリカとプライマリのどちらにクエリを送るか判断が複雑 | クエリルーティングルール定義。DB aware load balancer使用 |
| **Failover** | プライマリ障害時の自動昇格なし | 自動フェイルオーバー検出実装。Delayed Replicaで誤削除対策 |
| **Operational Costs** | レプリカ追加でインフラコスト増加 | クエリ最適化優先。Auto-scaling活用 |

---

## 2. Materialized Views

### 概要

Materialized Viewsは、高コストなクエリ結果を物理テーブルとして事前計算・保存します。通常のViewと異なり、クエリ実行時ではなく、定期的にリフレッシュされます。

### ライフサイクル

| 戦略 | 説明 | 適用場面 |
|------|------|----------|
| **Manual Refresh** | 管理者またはアプリケーションが明示的にトリガー | 安定データ、バッチウィンドウに合わせた更新 |
| **Scheduled Refresh** | 固定間隔（毎時、毎日等）で更新 | ダッシュボード、意思決定支援クエリ |
| **Incremental Refresh** | 新規・変更データのみ適用 | リアルタイムに近い鮮度必要。システム負荷軽減 |

### 適用判断基準

| 質問 | 理由 | 適用例 |
|------|------|--------|
| **高コストな計算を含むか？** | 集計、フィルタリング、JOIN繰返し実行を回避 | 月次売上トレンド、カテゴリ別売上、在庫回転率 |
| **元データの変更頻度は？** | 低頻度変更ならリフレッシュオーバーヘッド小 | 日次・時間単位更新の売上レポート。リアルタイム在庫には不適 |
| **高負荷下でも高速クエリ必要？** | 事前計算結果を提供し、ピーク時も安定パフォーマンス | マーケティングダッシュボード、経営レポートツール |
| **キャッシュで代替可能か？** | Materialized Viewsは定期再計算向き。キャッシュは繰返しルックアップ向き | パーソナライズドレコメンドはキャッシュ。カテゴリ別売上はMV |

### 課題と緩和策

| 課題 | 問題と影響 | 緩和策 |
|------|-----------|--------|
| **Data Freshness** | 最終リフレッシュ状態のみ反映。staleデータ返す可能性 | 適切なリフレッシュ戦略選択。Incremental refresh活用 |
| **Blocking Behavior** | リフレッシュ中にロックされ、クエリ遅延・失敗 | Incremental refresh使用。Swap-based update（可能な場合） |
| **Storage Overhead** | 物理ストレージ消費増加 | MVを本当に必要なクエリに限定。Indexed MVで削減 |
| **Refresh Performance** | 頻繁なリフレッシュでCPU/I/Oリソース消費 | 低トラフィック期間にスケジュール。Distributed MVで大規模データセット対応 |
| **Query Consistency** | リフレッシュ中に部分更新・不整合結果返す可能性 | Swap-based updateで完全リフレッシュ版のみアクセス |

---

## 3. CQRS (Command Query Responsibility Segregation)

### 概要

CQRSは、ReadとWriteを明示的に分離するアーキテクチャパターンです。単一モデルで両方を扱わず、Commandパス（Write）とQueryパス（Read）を別々に設計します。

### アーキテクチャコンポーネント

```
Customer → Command Handler → Command DB (Write)
                                  ↓
                            Model Updater
                                  ↓
                          ┌──────────────────┐
                          ↓                  ↓
                    Query Handler 1    Query Handler 2
                          ↓                  ↓
                    Read Model 1       Read Model 2
                    (Customer UI)      (Ops Dashboard)
```

| コンポーネント | 役割 |
|--------------|------|
| **Command Handler** | ビジネスルール適用、検証、トランザクション保証 |
| **Command DB** | トランザクショナルデータストア（正規化、ACID保証） |
| **Model Updater** | 変更をReadモデルに投影（Batch/CDC/Event Stream） |
| **Query Handler** | 消費者別に最適化されたクエリAPI |
| **Read Model** | 非正規化、検索最適化、消費者ニーズに合わせた構造 |

### 適用判断基準

| 質問 | 理由 | 適用例 |
|------|------|--------|
| **ReadとWriteのアクセスパターンが乖離？** | 異なるデータ形状・アクセスパスが必要 | 商品カタログ：検索向け非正規化Read、在庫更新向け正規化Write |
| **複数の消費者がいるか？** | 消費者ごとに異なる表現が必要 | 運用チームは集計メトリクス、顧客は詳細商品・注文ビュー |
| **Writeモデルが複雑化？** | ドメインロジックを専用Commandモデルで管理 | プロモーション、返品、不正検知、カスタム価格ロジック |
| **システムが活発に進化中？** | 各サイドを独立して進化・スケール可能 | 顧客向けアプリと運用ポータルを別チームが異なるリリースサイクルで開発 |
| **Eventual Consistency許容可能？** | Readは通常Writeから少し遅れる | 注文確認画面、商品一覧は遅延許容。決済処理は同期保証必要 |

### 課題と緩和策

| 課題 | 問題と影響 | 緩和策 |
|------|-----------|--------|
| **複雑性増加** | コンポーネント、モデル、データフロー増加 | CQRS境界を必要なドメインに限定。明確な所有権。自動検証でモデルdrift防止 |
| **Model Updater信頼性** | バグ・障害でstale/不整合Readビュー | 耐久性のある配信機構（メッセージキュー、CDC）。Dead-letter queue、リトライポリシー |
| **Eventual Consistency** | Readモデルが最新コミット遅延反映 | クリティカルワークフローはCommandパスで直接処理。整合性期待値を明示 |
| **テスト・検証** | E2Eテストが非同期データ伝播で困難 | Contract testing。Integration test。Drift check |
| **運用オーバーヘッド** | コンポーネント増加で監視・デプロイ・トラブルシュート複雑化 | ログ・トレース・メトリクス一元化。イベント相関タグ |

---

## 4. Change Data Capture (CDC)

### 概要

CDCは、データベースのトランザクションログを監視し、変更をイベントとして公開します。レガシーシステムに後付けでReadモデルを構築する実用的手法です。

### CDCとCQRSの関係

```
Customer → Application → Command DB
                              ↓ (Transaction Log)
                          CDC Connector
                              ↓
                      Read Model Updater
                              ↓
                          Read DB
```

| 特徴 | 説明 |
|------|------|
| **非侵襲的** | Writeパス変更不要。既存システムに後付け可能 |
| **リアルタイム性** | トランザクションログベースで低レイテンシ |
| **意味的制約** | State変更のみキャプチャ。ビジネス意図欠如 |

### 適用場面

- レガシーシステムへのCQRS導入
- Writeパス変更が実務的に困難
- 既存トランザクションシステムからReadモデル派生

### CDCツール例

- Debezium
- Oracle LogMiner
- AWS DMS
- Maxwell's Daemon

---

## 5. Event Sourcing

### 概要

Event Sourcingは、State-basedモデルを捨て、すべての変更をイミュータブルなドメインイベントとして記録します。現在のStateは、イベントストリームをリプレイして再構築します。

### State-basedモデルの限界

| 課題 | 影響 |
|------|------|
| **履歴喪失** | 更新で前の状態が上書きされ、「いつ変更されたか」不明 |
| **監査・コンプライアンス** | 詳細監査証跡維持に別途Auditテーブル必要 |
| **Readモデル生成困難** | 新しい分析クエリ追加時、過去データ利用不可 |
| **Undo操作複雑** | ロールバック・補償アクション実装がエラーを起こしやすい |

### Event Sourcingライフサイクル

```
User Action → Order Service → Event Store (Append-Only)
                                   ↓
                        ┌──────────┴──────────┐
                        ↓                     ↓
              Real-Time Updater        Replay Updater
                        ↓                     ↓
            ┌──────────────────┐      Loyalty Summary
            ↓                  ↓      (Retroactive)
    Customer Dashboard  Ops Dashboard
```

### リアルタイムモデル更新 vs リプレイモデル更新

| モード | 説明 | ユースケース |
|--------|------|------------|
| **Real-Time** | 新規イベントを継続的に処理してReadモデル更新 | 顧客ダッシュボード、運用ダッシュボード |
| **Replay** | 履歴イベントを再処理して新Readモデル生成 | ロイヤリティサマリー作成、バグ修正後の再処理 |

### 課題と緩和策

| 課題 | 問題と影響 | 緩和策 |
|------|-----------|--------|
| **Eventual Consistency** | イベント記録とReadモデル反映にラグ | リアルタイムストリーム処理（Kafka、Kinesis）。クリティカルワークフローは同期Read-after-Write |
| **イベントバージョニング** | ビジネス要件変更でイベント構造変更。下流コンシューマーが破損 | 明示的バージョニング導入。スキーマレジストリ。変換パイプライン |
| **冪等性** | 履歴イベントリプレイで重複レコード・副作用 | イベントハンドラーを冪等に設計。イベント重複排除 |
| **ストレージ増加** | すべてのイベント永続化でログ肥大化 | ログコンパクション、スナップショット戦略。コンプライアンス必要期間のみ保持 |
| **デバッグ困難** | 非同期・分散イベント処理で障害追跡困難 | ログ・トレース・メトリクス一元化。イベントライフサイクル相関 |
| **順序・並行制御** | 並列イベント処理で順序不整合 | パーティション化イベントストリームで順序保証 |
| **再処理コスト** | 新Readモデル構築時のリプレイ計算負荷 | バッチ処理・並列化最適化。チェックポイントスナップショット |
| **複数Readモデル管理** | 投影増加で同期・ガバナンス複雑化 | イベントパイプライン・オーケストレーションフレームワーク使用 |

---

## 6. Domain-Based Decomposition & Polyglot Persistence

### 概要

ビジネスドメイン境界に沿ってシステムを分割し、各ドメインに最適なデータモデルとストレージを選択します。

### ドメイン分解の原則

1. **ビジネス境界に沿う**: 注文管理、商品カタログ、プロモーション、顧客分析等
2. **独立した所有権**: 各ドメインが自身のデータ、ロジック、責務をカプセル化
3. **独立した進化**: ドメインごとに異なるスケーリング、技術選択、リリースサイクル

### Strangler Figパターンによる段階的移行

```
Phase 1: Product Catalog抽出
  Monolith → Catalog Service (Document Store)
  Read traffic徐々に新サービスにルーティング

Phase 2: Promotions Service構築
  実験・ルール変更容易化

Phase 3: Order Service分離
  トランザクション複雑性のため後回し
  イベントソーシングモデル導入

Phase 4: Analytics Service独立
  ドメインイベント消費、投影構築
```

### ドメイン別ストレージ選択

| ドメイン | ストレージ | 理由 |
|---------|----------|------|
| **Order Management** | Relational DB | トランザクション整合性、ACID保証 |
| **Product Catalog** | Document Store | スキーマレス、検索・フィルタリング最適化 |
| **Promotions** | Key-Value Store | 高速ルックアップ、低レイテンシ |
| **Customer Analytics** | Time-Series DB | トレンド分析、イベントデータ集計 |

---

## パターン比較総合テーブル

| パターン | 最適化対象 | 複雑性 | 整合性 | 適用タイミング |
|---------|-----------|--------|--------|--------------|
| **Read Replicas** | スケーラビリティ | 低 | Eventual | Read >> Write、staleness許容 |
| **Materialized Views** | 集計クエリ | 低〜中 | Eventual | 事前計算可能、定期更新許容 |
| **CQRS** | 関心分離 | 中 | Eventual | Read/Write要件乖離 |
| **CDC** | 非侵襲的更新 | 中 | Eventual | レガシーシステム後付け |
| **Event Sourcing** | 監査証跡・再現性 | 高 | Eventual | 履歴・動的ビュー必要 |
| **Domain Decomposition** | チーム自律性 | 高 | ドメインごと | ビジネスサブドメイン一致 |
| **Polyglot Persistence** | ワークロード特化 | 高 | ドメインごと | データ特性が大きく異なる |

---

## Related Skills

- **architecting-microservices**: CQRS実装、Saga、データ所有権
- **applying-domain-driven-design**: ドメイン境界定義、戦略的DDD
- **understanding-database-internals**: レプリケーション内部、トランザクション分離レベル
- **designing-relational-databases**: 正規化、非正規化トレードオフ
