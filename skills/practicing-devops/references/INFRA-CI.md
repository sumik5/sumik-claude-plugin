# インフラCI（Infrastructure Continuous Integration）

インフラ固有のCIサイクルとテスト戦略を扱います。アプリケーションCI/CDの一般的なパイプライン設計は [CICD-PIPELINE.md](./CICD-PIPELINE.md) を参照してください。本ドキュメントは**インフラ（IaC）特有のテスト体系・サイクル設計・前提条件**に焦点を当てます。

---

## 1. インフラCIとは

### 従来の改善サイクルの問題

従来のインフラ運用には2つの根本的な問題がある:

1. **「人の不完全性」の蓄積**: 手順書のレビュー・本番作業のいずれも人間が行うため、コマンドミス・解釈違い・確認漏れが積み重なり、本番環境が「再現不可能な状態」へと変貌する
2. **「時間の凍結」という前提**: 「一度作ったら変えたくない」という思想がシステムの陳腐化・脆弱化を招く（WannaCry等のセキュリティ事故の遠因）

結果として、**サイクルを回すほどシステムが硬直化する「負のサイクル」**に陥る:
- 本番環境への変更が積み重なり、手順書との乖離が拡大
- 再現できない環境への作業は準備コストが増大し続ける
- ノウハウが個人に属人化し、組織全体の効率が低下する

### インフラCIが解決するアプローチ

インフラCIは対症療法ではなく**原因療法**：

| 従来アプローチ | インフラCIアプローチ |
|-------------|------------------|
| 人が環境を直接操作 | プログラムが環境を操作（人は触れない） |
| 手順書 = ドキュメント | 構成定義ファイル = 実行可能なドキュメント |
| 変更ごとに準備工数が増大 | 毎回使い捨て環境でゼロから再現 |
| ノウハウが人に蓄積（属人化） | ノウハウがコードに蓄積（共有化） |
| 一斉大規模変更 | 小刻みな変更の継続 |

**定義**: インフラCIとは「VCSを中心に、構成定義ファイルの変更を自動テストし、本番利用可能な成果物を継続的に作成するPDCAサイクルをシステム化すること」

---

## 2. インフラCIに必要な前提条件

### 条件1: プログラムから操作可能であること

インフラCIではプログラムが環境を操作するため、**操作対象がAPIやCLIで制御できること**が必須:

- ✅ クラウドリソース（AWS/GCP/Azure）: APIが整備され、ほぼ全リソースをプログラム操作可能
- ✅ 仮想化環境（Vagrant、Docker）: プログラム制御向けに設計
- ✅ 構成管理ツール対応機器: Ansible/Chef/Puppet等が対象とするサーバー/ネットワーク機器
- ⚠️ GUIのみの装置: CI適用困難（ラップアッパーが必要）
- ❌ プログラム操作インターフェイスを持たない物理装置: CI適用不可

**重要**: 操作だけでなく**状態の取得**もプログラムから可能でなければならない。操作できても確認できなければ自動テストが成立しない。

### 条件2: 環境の使い捨てが可能であること

CIサイクルでは毎回ゼロから環境を構築してテストする。これにより:
- 試行錯誤の蓄積（ズレ）が持ち込まれない
- 検証環境と本番環境の差異が発生しない
- 意図せず持ち込まれたズレをリセットできる

```
使い捨て環境のサイクル:
  変更 → 新規環境構築 → テスト → 環境破棄 → 次の変更へ
  ↕（蓄積がリセットされるため常にクリーンな状態）
```

**使い捨てが困難なケース**: 物理装置が組み込まれた大規模システム（コスト・スペースの問題）。この場合でも部分的なCIは可能。

### 条件3: IaCの基本プラクティスの適用

インフラCIはIaC（Infrastructure as Code）のプラクティスを前提とする:

| プラクティス | 説明 |
|-----------|------|
| **構成定義ファイル** | インフラの手順・構成をテキストファイルで記述（Ansible Playbook、Terraform HCL等） |
| **自己記述システム** | 構成定義ファイルがドキュメントとしても機能し、実態とドキュメントの乖離を排除 |
| **バージョン管理（VCS）** | 構成定義ファイルをGit等で管理。変更追跡・レビュー・承認フローを含む |
| **継続的テストシステム** | VCS変更を検知して自動テストを実行（パイプライン） |
| **小刻みな変更** | 大規模一斉変更を避け、意味のある単位で小さく変更を繰り返す |

---

## 3. インフラCIの仕組み

### VCSを中心としたサイクル

```
①要求発生（チケット/Issue起票）
    ↓
②構成定義ファイルの変更・VCSへ登録
    ↓
③継続的テストシステムがVCS変更を検知 → パイプライン自動実行
    ↓
④テスト通過後、人によるコードレビュー（ポリシー準拠・テスト網羅性確認）
    ↓
⑤VCSの本番ブランチへ取り込み → 本番環境で利用可能な成果物が完成
    ↓（インフラCDへ連結する場合）
⑥本番環境へ自動デプロイ（CD）
```

**キーポイント**: インフラエンジニアのインターフェイスが「コンソール（直接操作）」から「VCS（コードを登録してテスト結果を確認）」へと変わる。

### 構成管理ツールの役割

| ツール | 役割 | 特徴 |
|--------|------|------|
| **Ansible** | エージェントレスな構成管理（SSH経由） | YAMLベース、冪等性、Playbookで手順定義 |
| **Chef** | エージェントベースの構成管理 | Rubyベース、Cookbook/Recipe |
| **Puppet** | 宣言型構成管理 | あるべき状態を宣言 |
| **Terraform** | インフラプロビジョニング | クラウドリソースの作成・変更・削除 |

**ダイナミックインフラストラクチャ**: API経由でサーバー・ネットワーク・ストレージをプログラム制御できる基盤（AWS/GCP/Azure、またはOpenStack等のオンプレ）。使い捨て環境の実現に不可欠。

### パイプラインの構成

インフラCI特有のパイプライン構成:

```
┌─────────────┐   ┌─────────────┐   ┌──────────────┐   ┌─────────────┐
│ Lint        │ → │ 構文チェック  │ → │ ユニットテスト │ → │ 統合テスト   │
│（規約準拠）  │   │（Playbook整合)│   │（個別手順検証）│   │（環境全体確認）│
└─────────────┘   └─────────────┘   └──────────────┘   └─────────────┘
```

各ステージの失敗は次のステージへ進まない。早い段階で検出されるほど修正コストが低い。

---

## 4. インフラテストの体系（V字モデル適用）

インフラのテストはソフトウェア開発のV字モデルに対応する:

```
開発工程               テスト工程
─────────               ─────────
方針・設計       ←→    コードレビュー（Lint/構文チェック）
詳細設計         ←→    ユニットテスト（個別手順検証）
実装（Playbook） ←→    統合テスト（環境全体の機能確認）
本番環境                システムテスト（性能・可用性）
```

### 4.1 コードレビュー自動化（Lint）

**目的**: 人がレビューせずとも、コーディング規約への準拠を機械的に検出する

**何をチェックするか**:
- **コーディング規約の準拠**: タスク名の記載、推奨外の書き方の検出
- **構文チェック**: YAMLのパース可能性、ロール名の整合性（コンパイル相当）
- **禁止コマンドの検出**: プロジェクト固有の危険な操作を事前ブロック

**主要ツール**:
| ツール | 対象 | 用途 |
|--------|------|------|
| `ansible-lint` | Ansible Playbook | コーディング規約・禁止パターンのチェック |
| `yamllint` | YAML全般 | YAML構文・スタイルチェック |
| `tflint` | Terraform HCL | Terraform固有のベストプラクティス |
| `terraform validate` | Terraform HCL | 構文チェック・型検証 |
| `puppet-lint` | Puppet manifests | Puppet規約チェック |

**ベストプラクティス**:
- デフォルトルールを起点に、プロジェクト固有の禁止パターンをカスタムルールとして追加
- 例外（除外ルール）は最小限にとどめ、コードベース側を修正することを優先
- Lintをパイプラインの最初のステージに配置し、即座にフィードバック

### 4.2 ユニットテスト（構成定義ファイルの検証）

**目的**: 個々の手順・設定が確実に実行されたことをプログラムで検証する。人が「コマンドを実行して結果を目で確認する」という暗黙のテストを自動化する。

**何をテストするか**:
- ファイルの存在・内容・パーミッション
- サービスの起動状態
- パッケージのインストール状態
- 設定値の正確性（想定した値が設定されているか）
- リソース（ポート、プロセス等）の状態

**Ansibleにおけるユニットテストの実装**:
```yaml
# Ansible Playbookによるユニットテスト例
- name: ユニットテスト - Webサーバーの状態確認
  hosts: webservers
  tasks:
    - name: Nginxが起動していることを確認
      command: systemctl is-active nginx
      changed_when: false

    - name: 設定ファイルが存在することを確認
      stat:
        path: /etc/nginx/nginx.conf
      register: nginx_conf

    - name: 設定ファイルの存在を検証
      assert:
        that:
          - nginx_conf.stat.exists
          - nginx_conf.stat.mode == '0644'
```

**役割の分担**:
- **ロール単位のテスト**: 個々のRoleが期待どおり動作するかを単独でテスト
- **Playbook単位のテスト**: 複数ロールを組み合わせた際の整合性を確認

### 4.3 統合テスト（プロビジョニング後の検証）

**目的**: 実際に構成定義ファイルで構築した環境に対して、システム全体の機能・要件を検証する。構成要素を結合した状態での動作確認。

**従来との違い**: テスト項目自体は手動テストと変わらないが、**使い捨て環境**で実施することで、常にクリーンな状態での検証が可能。

**主要ツール**:
| ツール | 言語 | 特徴 |
|--------|------|------|
| **Serverspec** | Ruby | サーバーの期待状態をRSpecで記述。SSH経由でリモート実行可能 |
| **InSpec** | Ruby（Chef社） | Serverspecの後継。よりリッチなリソースタイプ対応、コンプライアンス向け |
| **Goss** | YAML/Go | YAML定義でシンプルな検証。高速実行 |
| **Testinfra** | Python | pytest統合。Ansible/Dockerとの親和性高い |

**Serverspecによる統合テスト例**:
```ruby
# spec/webserver_spec.rb
require 'spec_helper'

describe package('nginx') do
  it { should be_installed }
end

describe service('nginx') do
  it { should be_enabled }
  it { should be_running }
end

describe port(80) do
  it { should be_listening }
end

describe file('/etc/nginx/nginx.conf') do
  it { should be_file }
  its(:content) { should match /worker_processes auto/ }
end
```

**InSpecによる統合テスト例**:
```ruby
# controls/webserver.rb
control 'webserver-1.0' do
  impact 1.0
  title 'Nginx Webserver設定'
  desc 'Nginxが正しく設定・起動されていることを確認'

  describe package('nginx') do
    it { should be_installed }
  end

  describe service('nginx') do
    it { should be_running }
    it { should be_enabled }
  end

  describe port(80) do
    it { should be_listening }
  end
end
```

### 4.4 セキュリティテスト

インフラのセキュリティ検証をパイプラインに組み込む:

| テスト種別 | ツール例 | 検証内容 |
|-----------|---------|---------|
| **IaC静的解析** | Checkov、tfsec | TerraformやAnsibleのセキュリティベストプラクティス違反を検出 |
| **OSセキュリティ** | InSpec（CIS Benchmark） | CISベンチマーク準拠の設定確認 |
| **脆弱性スキャン** | Trivy、Grype | コンテナイメージ・OSパッケージの既知脆弱性検出 |
| **コンプライアンス** | InSpec Profilesライブラリ | PCI-DSS、SOC2等のコンプライアンス要件確認 |

**InSpecによるCISベンチマーク実装例**:
```ruby
# CIS Level 1 - SSH設定の検証
control 'ssh-1.0' do
  impact 1.0
  title 'SSH設定のセキュリティ確認'

  describe sshd_config do
    its('PermitRootLogin') { should eq 'no' }
    its('PasswordAuthentication') { should eq 'no' }
    its('Protocol') { should eq '2' }
  end
end
```

---

## 5. テスト自動化のベストプラクティス

### 5.1 テストの責務分離

各テスト層は責務を分離し、重複を避ける:

| テスト層 | 責務 | やらないこと |
|---------|------|------------|
| Lint/構文チェック | 規約準拠・構文エラー | 実際の環境への影響確認 |
| ユニットテスト | 個別手順の確実な実行 | システム全体の機能確認 |
| 統合テスト | システム全体の要件確認 | 細かい設定値の網羅的確認 |
| セキュリティテスト | セキュリティポリシーへの準拠 | 機能要件の確認 |

### 5.2 早期発見の原則（Shift-Left）

軽微なエラーを早いステージで検出するほど修正コストが低い:

```
コスト
 高 │                              △ 本番でのインシデント
    │                         △ 統合テスト失敗
    │                   △ ユニットテスト失敗
    │             △ Lint失敗
 低 │       △ ローカルでの事前確認
    └──────────────────────────────────→ 発見タイミング（遅い）
         早い発見                  遅い発見
```

Lintがパイプラインの最初に実行されるべき理由: 軽微な規約違反でパイプライン全体を無駄に実行するコストを避ける。

### 5.3 使い捨て環境の設計

| 考慮点 | ベストプラクティス |
|-------|----------------|
| **環境の再現性** | 構成定義ファイルから常に同一の環境が再現できることを担保 |
| **並列実行** | 複数のPR/変更に対して独立した環境でテストを並列実行 |
| **クリーンアップ** | テスト後は確実に環境を破棄（コスト・セキュリティ） |
| **本番との同等性** | テスト環境と本番環境の差異を最小化（ダイナミックインフラ活用） |

### 5.4 小刻みな変更の実践

インフラCIのサイクルを速く回すための設計:

- **チケット管理との連携**: 変更要求をチケット/Issueとして管理し、コミットと紐付け（変更追跡）
- **ブランチ単位のCI**: feature branchへのコミットごとにCIを実行
- **変更単位の分割**: 1つのチケット・PRで影響範囲を最小化
- **回帰テストの自動化**: 変更が既存機能に影響しないことをパイプラインで継続的に確認

### 5.5 ノウハウのコード化

属人化を防ぐための設計原則:

1. **禁止パターンをlintルールへ**: 「やってはいけないこと」をコードとして明示化
2. **テスト項目をコードへ**: 暗黙的な確認作業を明示的なテストコードへ変換
3. **コメント・ドキュメントは構成定義ファイルに内包**: `site.yml` 自体がドキュメントとして機能するように記述

---

## 6. CICD-PIPELINE.mdとの差別化

| 観点 | [CICD-PIPELINE.md](./CICD-PIPELINE.md) | 本ドキュメント（INFRA-CI.md） |
|-----|--------------------------------------|---------------------------|
| **対象** | アプリケーション（コード）のCI/CD | インフラ（構成定義ファイル）のCI |
| **テスト** | ユニット/統合/E2Eテスト（ソフトウェアテスト） | Lint/Serverspec/InSpec（インフラテスト） |
| **成果物** | ビルド済みアーティファクト（コンテナイメージ等） | 本番利用可能な構成定義ファイル一式 |
| **デプロイ** | Blue-Green/Canary/Rolling等のアプリデプロイ戦略 | 使い捨て環境での再構築・入れ替え |
| **ツール** | GitHub Actions、Jenkins、GitLab CI | Ansible、Terraform + 上記CIツール |
| **テスト環境** | コンテナ/ステージング環境（共有が多い） | ダイナミックインフラで毎回新規作成 |

---

## 7. 導入パス（段階的なインフラCI化）

前提が整わない既存環境への段階的アプローチ:

### ステップ1: 自動化から始める
- 現状環境のまま、手順書をAnsible Playbookに置き換える
- Lintによる構文チェックを導入（人のレビューを補完）
- 効果: コスト削減・スピードアップ（CIの一部を活用）

### ステップ2: テストを追加する
- 既存のPlaybookにServerspec/InSpecでのユニットテストを追加
- パイプライン（GitLab CI/GitHub Actions）でテストを自動実行
- 効果: デグレード検出・品質均一化

### ステップ3: 完全なインフラCIサイクルを回す
- 使い捨て環境（Vagrant/Docker/クラウド）での統合テスト
- チケット管理・ブランチ・パイプラインを連携したフルサイクル
- 効果: 本番環境の再現性確保・継続的改善サイクルの確立

> **重要**: 全部やらなければCIではない、ということはない。小さなサイクルでの成功体験と経験が、組織全体への展開を加速する。
