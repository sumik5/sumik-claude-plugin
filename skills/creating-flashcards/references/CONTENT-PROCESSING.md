# コンテンツ処理・フォーマットルール詳細

フラッシュカード作成時のコンテンツ自動分析ヒューリスティクスとフォーマット変換ルールの詳細リファレンス。

---

## pandocアーティファクトのクリーニング

pandocはEPUBをMarkdown変換する際に以下のアーティファクトを生成する。すべて除去すること。

| アーティファクト | 例 | 除去パターン |
|----------------|-----|------------|
| CSSクラスマーカー | `{.class_s74W}`, `{.heading_s3M-0}` | `\{[.#][^}]*\}` |
| インラインスパン | `[text]{.class_sXXX}` | テキストのみ抽出 |
| ページマーカー | `[]{#c3W.xhtml}` | 完全除去 |
| divマーカー | `::: heading_s6MV` | 行ごと除去 |
| ゼロ幅スペース付きリストマーカー | `[​- ​]`, `[​1. ​]` | 通常のリストマーカーに変換 |
| Google URL リダイレクト | `[text](https://www.google.com/url?q=...)` | テキストのみ抽出 |
| コードブロックdiv | `::: class_sBD ... :::` | base64退避→パース後復元（後述） |
| エスケープ文字 | `\``, `\*`, `\#`, `\'`, `\~`, `\<`, `\>`, `\--\>` | エスケープ除去（順序注意） |
| 空ブラケット | `[]` | 除去 |
| 誤記ヘッダー | `### 解説 {.heading_s6S}`（正解用クラスなのにテキストが解説） | CSSクラスベースで`正解`に修正 |

### `<pre>`ブロック保護

`\{[^}]*\}`パターンでpandocクラスを除去する際、**`<pre><code>`ブロック内の`{`や`}`も誤ってマッチする**危険がある（`[^}]`は改行にもマッチするため、遠くの`}`まで横断マッチする）。

**対策**: クリーニング処理の前に`<pre>...</pre>`ブロックをプレースホルダーに退避し、処理後に復元する:

```python
pre_blocks = {}
counter = [0]
def save_pre(m):
    key = f'\x00PRE{counter[0]}\x00'
    pre_blocks[key] = m.group(0)
    counter[0] += 1
    return key
text = re.sub(r'<pre[^>]*>.*?</pre>', save_pre, text, flags=re.DOTALL)
# ... クリーニング処理 ...
for key, value in pre_blocks.items():
    text = text.replace(key, value)
```

### 誤記ヘッダーの自動修正

EPUBソースでセクションヘッダーのテキストが誤っていることがある（例: 「正解」セクションのヘッダーテキストが「解説」になっている）。pandocのCSSクラスで本来の意図を推定できる:

```python
# heading_s6S = 正解用クラス、heading_s6V = 解説用クラス
block = re.sub(
    r'^(#{2,4})\s*解説\s*(\{\.heading_s6S\})',
    r'\1 正解 \2',
    block,
    flags=re.MULTILINE,
)
```

### エスケープ文字の除去順序

pandocのエスケープ文字を除去する際、**複合エスケープを先に処理する**こと。順序を誤ると部分置換が発生する:

```python
# ⚠️ 順序が重要: 複合エスケープ → 単純エスケープ
text = text.replace(r'\--\>', '-->')   # 複合を先に
text = text.replace(r'\>', '>')         # 単純を後に
text = text.replace(r'\<', '<')
text = text.replace(r'\~', '~')
text = text.replace(r'\#', '#')
text = text.replace(r'\*', '*')
text = text.replace("\\'", "'")         # アポストロフィ
text = text.replace('\\-->', '-->')     # フォールバック（部分置換の残骸対策）
```

**失敗例**: `\>` → `>` を先に実行すると、`\--\>` が `\-->` になり、その後の `\--\>` → `-->` 置換がマッチしなくなる。

---

## pandoc div形式コードブロック（`::: class_sBD`）

pandocはEPUBの一部のコードブロックを `::: class_sBD ... :::` のdiv形式で出力する。この形式はスパン注釈形式とは異なり、コード全体がdivブロックで囲まれる。

### 構造

```
::: class_sBD
resource "aws_instance" "example" {
  ami           = "ami-12345"
  instance_type = "t2.micro"
}
:::
```

### base64退避パターン

divブロック内のコードは問題テキスト・選択肢テキストの一部として解析する必要があるが、行ベースのパーサーを混乱させる。**パース前にbase64エンコードでプレースホルダーに退避**し、パース後に復元する:

```python
import base64, re

def preprocess_code_blocks(text):
    def replace_block(m):
        code = m.group(1).strip()
        code = re.sub(r'\\\s*$', '', code, flags=re.MULTILINE)  # pandoc行継続除去
        encoded = base64.b64encode(code.encode('utf-8')).decode('ascii')
        return f'{{CODE:{encoded}}}'
    return re.sub(r'::: class_sBD\n(.*?)\n:::', replace_block, text, flags=re.DOTALL)

def decode_code_block(marker):
    m = re.match(r'\{CODE:([A-Za-z0-9+/=]+)\}', marker)
    return base64.b64decode(m.group(1)).decode('utf-8') if m else marker
```

**重要**: この退避処理は`clean_pandoc()`よりも**前に**実行すること。`clean_pandoc`の`:::`行除去がコードブロックの内容を破壊するのを防ぐ。

---

## pandocスパン注釈コードブロック

pandocはEPUBのコード部分を`[text]{.class_sXXX}`形式のスパン注釈に変換する。このパターンはプレーンテキストのコードブロックとは異なる処理が必要。

### スパン注釈の構造

```
[variable]{.class_s3CW}[ ]{.class_s3C5}["instance_type"]{.class_s3CX}[
{]{.class_s3C5}
```

| クラス種別 | 役割 | 例 |
|-----------|------|-----|
| `class_s3CW` | キーワード | `variable`, `resource` |
| `class_s3C5` | 通常コード | `{`, `}`, スペース |
| `class_s3CX` | 文字列リテラル | `"instance_type"` |
| `class_s3E0` | 空白 | スペース、改行 |
| `class_s3CF` | 演算子 | `=` |
| `class_s3C9-0` | ハイパーリンク（コードではない） | URL |

### 処理上の3つの罠

#### 罠1: スパンの行分割

pandocはスパンを行をまたいで分割する。ブラケット数を数えてバランスが取れるまで行を結合する:

```python
def join_split_spans(text):
    lines = text.split('\n')
    result = []
    i = 0
    while i < len(lines):
        line = lines[i]
        temp = line.replace('\\[', '').replace('\\]', '')
        while temp.count('[') > temp.count(']') and i + 1 < len(lines):
            i += 1
            line = line + ' ' + lines[i].strip()
            temp = line.replace('\\[', '').replace('\\]', '')
        result.append(line)
        i += 1
    return '\n'.join(result)
```

#### 罠2: エスケープされたブラケット

コード内容に`\[`、`\]`、`\"`が含まれる場合、スパンのブラケットと混同される。プレースホルダーで保護する:

```python
def extract_code_text(text):
    text = re.sub(r'\{\.class_s[\w-]+\}', '', text)  # クラス除去
    text = text.replace('\\[', '\x00LB\x00')          # 保護
    text = text.replace('\\]', '\x00RB\x00')
    text = text.replace('\\"', '\x00DQ\x00')
    text = text.replace('[', '').replace(']', '')      # スパンブラケット除去
    text = text.replace('\x00LB\x00', '[')             # 復元
    text = text.replace('\x00RB\x00', ']')
    text = text.replace('\x00DQ\x00', '"')
    return text
```

#### 罠3: コード行間の空行

pandocはコード行間に空行を挿入する。次の非空行もコード行か先読みして、コードブロックの範囲を正しく判定する:

```python
elif stripped == '' and in_code:
    # 先読み: 次の非空行がコード行なら継続
    next_is_code = False
    for j in range(i + 1, min(i + 4, len(lines))):
        if lines[j].strip() == '':
            continue
        if re.search(r'\{\.class_s\w+\}', lines[j].strip()):
            next_is_code = True
        break
    if next_is_code:
        continue  # コードブロック継続
```

### ハイパーリンクとの区別

コードスパンのクラス名は`\w+`パターン（例: `class_s3C5`）、ハイパーリンクは`class_s3C9-0`のようにハイフンを含む。検出時に`\{\.class_s\w+\}`（ハイフンなし）を使うことでコードのみを対象にできる。

---

## pandoc行折り返しの結合

pandocは長い行を任意の位置で改行する。以下のルールで結合する。

### 結合すべきケース

| ケース | 元の形式 | 結合後 |
|-------|---------|--------|
| 選択肢（文字のみ行） | `A.\n選択肢テキスト` | `A. 選択肢テキスト` |
| 選択肢（テキスト折り返し） | `D. テキストが\n次の行に続く` | `D. テキストが次の行に続く` |
| 不正解解説（文字のみ行） | `B:\nテキスト` | `B: テキスト` |
| 不正解解説（折り返し） | `D: テキストが\n次の行に続く` | `D: テキストが次の行に続く` |
| 段落テキスト | `Cloud\nRunサービス` | `Cloud Runサービス` |
| バレット選択肢（インデント継続） | `- テキスト\n  続きの行` | `- テキスト 続きの行` |

### 結合しないケース

以下のマーカーで始まる行は新しいブロックの開始と見なし、前の行とは結合しない:

- 選択肢マーカー: `A.` 〜 `I.`（最大9選択肢まで対応）
- セクションマーカー: `解説:`, `不正解の選択肢の解説:`, `正解の選択肢:`, `参考資料:`
- 不正解解説マーカー: `A:` 〜 `I:`
- 見出し: `#`, `##`, `###`
- 空行

---

## コンテンツ構造の自動検出

### 検出すべきマーカー

#### 問題マーカー

| マーカー種別 | 例 | 検出パターン |
|------------|-----|------------|
| 問題番号（日本語） | 問1、問題1、第1問、第一問 | `問\d+`、`問題\d+`、`第\d+問` |
| 問題番号（英語） | Q1、Question 1 | `Q\d+`、`Question\s+\d+` |
| 括弧番号 | (1)、【1】、[1] | `\(\d+\)`、`【\d+】` |
| 見出し付き番号 | `## 問題 1`、`# Q1` | 見出しレベル + 問題キーワード |
| 見出し埋め込み型 | `##### 問題 1. [問題文全体]` | 問題番号と問題文が同一見出し内 |
| インラインテキスト型 | `[Question 1]{.class}: question text` | 見出しではなく本文中に埋め込み |

#### 解答マーカー

| マーカー種別 | 例 |
|------------|-----|
| セクション見出し | `## 解答`、`# 答え`、`## Answers` |
| インライン見出し | `**解答**`、`**正解**`、`**Answer**` |
| ラベル付き | `解答:`、`答え:`、`Answer:` |
| 括弧付き | `【解答】`、`【答え】`、`【正解】` |
| 解説付き | `解説:`、`Explanation:` |
| 解答例見出し | `##### 解答例` |
| 数字レスポンス型 | `Correct Response: 4` |

**正解の数字→レターマッピング:**

| 数字 | レター |
|------|--------|
| 1 | A |
| 2 | B |
| 3 | C |
| 4 | D |
| 5 | E |
| 6 | F |
| 7 | G |
| 8 | H |
| 9 | I |

#### 境界マーカー

| マーカー種別 | 例 | 意味 |
|------------|-----|------|
| 水平線 | `---`、`***` | ページ区切りの可能性 |
| ページ番号 | `- 1 -`、`Page 1` | 元のページ区切り |
| 大きな空行 | 3行以上の空行 | セクション区切りの可能性 |

### 構造パターンの判定ロジック

以下の順序で判定する。先に該当したパターンを採用する。

#### 判定1: 前半後半分離型

**判定条件:** ファイルの中盤〜後半に「解答」「答え」等の大きなセクション見出しが1つだけ存在し、前半に問題、後半に解答が並ぶ。

**パース方法:** 解答セクション見出しで2分割 → 問題番号でマッチング。

#### 判定2: 交互配置型

**判定条件:** 問題マーカーと解答マーカーが交互に出現する。

**パース方法:** マーカーの出現位置をリスト化 → 交互にペアリング。

#### 判定3: 同一セクション型

**判定条件:** 各セクション内に問題マーカーと解答マーカーの両方が含まれる。

**パース方法:** セクション内で解答マーカーを境界に分割。

#### 判定4: 章末解答型

**判定条件:** 複数の章に分かれ、各章の末尾に解答セクションがある。

**パース方法:** 章単位で分割 → 章内の問題・解答をマッチング。

#### 判定5: その他（フォールバック）

上記に該当しない場合、利用可能なマーカーを最大限活用して推測抽出 → サンプル確認でユーザー判断。

#### 判定6: 混在型

**判定条件:** 1つのEPUB内に異なる構造パターンのセクションが共存する。

**例:** Assessment Test（同一セクション型: `Correct Answer:` + `Explanation:` がQuestion直後）とPractice Exams（前半後半分離型: Questions セクションとSolutions セクションが分離）が共存。

**パース方法:** セクション単位で構造パターンを判定し、各セクションに適したパーサーを適用。最終的に全セクションのQ&Aペアを統合する。

### 判定時の注意事項

- **選択肢との混同回避**: 連番（1., 2.）は問題番号ではなく選択肢の可能性がある。周辺コンテキストで区別
- **解説の扱い**: 「解説」は解答の一部として扱う
- **図表の参照**: テキストはそのまま保持（画像自体は抽出不可）
- **参考資料/URL**: Backフィールドには含めない（除去する）

---

## フォーマット変換ルール

### 選択肢のリスト化

**形式:**

```html
<ol style="list-style-type: none; padding-left: 0;">
  <li>A. 選択肢テキスト</li>
  <li>B. 選択肢テキスト</li>
</ol>
```

- `list-style-type: none` でデフォルト番号を非表示
- `A.`, `B.` 等のプレフィックスを `<li>` 内に保持
- 全選択肢を**1つの `<ol>` にまとめる**（選択肢ごとに個別の `<ol>` を作らない）
- 選択肢間の空行があっても同一 `<ol>` に含める

**検出パターン:**

| パターン | 例 | 変換 |
|---------|-----|------|
| 半角大文字 + ドット | `A. 選択肢`, `B. 選択肢` | そのまま使用 |
| 半角大文字 + ドット（改行分離） | `A.\n選択肢テキスト` | 1行に結合 |
| バレットポイント（`-`） | `- 選択肢テキスト` | A./B./C./D./E. を自動付与 |

### Frontフィールドの構成

```
[問題文のみ（問題番号ヘッダーは含めない）]
<br><br>
<ol style="list-style-type: none; padding-left: 0;">
  <li>A. ...</li>
  ...
</ol>
```

- **問題番号（「問 N」「Question N」等）はFrontに含めない**
- 問題の内容テキストと選択肢のみ

### Backフィールドの構成

**単一正解の場合:**

```
<b>正解:</b>
A. [正解テキスト]
```

**複数正解の場合（「二つ選択」等）:**

```
<b>正解:</b>
A. [正解テキスト1]
B. [正解テキスト2]
```

**解説セクション:**

```
<b>解説:</b>（太字ラベル）
[解説テキスト]

<b>不正解の選択肢の解説:</b>（太字ラベル）
<b>C:</b> [不正解解説]（各選択肢を太字ラベル付きで）
```

### 比較テーブルのHTML変換

pandocが出力するスペース区切りのプレーンテキストテーブルを、HTMLテーブルに変換する。

**検出方法:** テキスト行の直後にダッシュ区切り行（`-------- ----------`）がある場合、テーブルとして認識。

**カラム分割:** 2つ以上の連続スペースをカラム区切りとして使用（セパレータのダッシュ位置ではなく、スペース区切りで分割する。日本語文字幅の違いによるズレを回避）。

**変換例:**

元テキスト:
```
  モニタリングツール   主な用途                 最適か
  -------------------- ------------------------ --------
  Cloud Monitoring     メトリクス収集           はい
  Cloud Trace          分散トレーシング         いいえ
```

変換後:
```html
<table style="border-collapse: collapse; width: 100%; font-size: 0.85em; margin-top: 8px;">
<tr><th style="border: 1px solid #ccc; padding: 4px 6px; background: #f0f0f0;">モニタリングツール</th><th ...>主な用途</th><th ...>最適か</th></tr>
<tr><td ...>Cloud Monitoring</td><td ...>メトリクス収集</td><td ...>はい</td></tr>
<tr><td ...>Cloud Trace</td><td ...>分散トレーシング</td><td ...>いいえ</td></tr>
</table>
```

### 改行とテキスト整形

| ルール | 変換 |
|-------|------|
| 連続する空行（3行以上） | 1つの `<br><br>` に圧縮 |
| 段落間の区切り | `<br><br>` |
| 行頭・行末の空白 | トリム |
| Markdownの見出し記号（`#`） | `<b>` タグに変換 |

### 特殊文字の処理

| 文字 | 処理 |
|------|------|
| `<` / `>` | HTMLエンティティに変換（`&lt;` / `&gt;`）※HTMLタグ以外 |
| `&` | `&amp;` に変換 |
| 画像参照 `![alt](url)` | 除去（テキストのみ抽出） |

---

## 一括投入の効率化

### AnkiConnect バッチAPI

大量のカード（50件以上）を作成する場合、MCP `add_note` の個別呼び出しではなく、AnkiConnect の `addNotes`（複数形）バッチAPIを直接使用する。

| 方法 | 200件作成時の呼び出し回数 | 推奨場面 |
|------|------------------------|---------|
| MCP `add_note` 個別 | 200回 | 少数（10件以下） |
| AnkiConnect `addNotes` バッチ | 4回（50件×4バッチ） | 大量（50件以上） |

**バッチサイズ**: 50件を推奨。

**⚠️ `createDeck` 必須**: `addNotes` 実行前に必ず `createDeck` でデッキの存在を保証すること。デッキが存在しない場合、`addNotes` は `"deck was not found"` エラーで全件失敗する。`createDeck` は既存デッキに対しても安全に呼び出せる（冪等）。

**エラーハンドリング**: `addNotes` の戻り値は配列。各要素が `null` の場合は重複またはエラーでスキップされたことを意味する。バッチ全体が失敗した場合は `error` フィールドにエラーメッセージが返る（`result` は `null`）。両方をチェックすること。

### 再作成時のワークフロー

フォーマット修正等でカードを再作成する場合:

1. `findNotes` でタグ検索（例: `tag:DevOps-Engineer-模擬問題集-200問`）
2. `deleteNotes` で旧カードを一括削除
3. **`createDeck` でデッキ存在を保証**（⚠️ 全カード削除後に空デッキが自動削除されるため必須）
4. `addNotes` で新カードを一括作成

### 翻訳時の処理

100問以上の外国語コンテンツを翻訳する場合も、LM Studioスクリプトを逐次呼び出しで処理する（ローカルLLMのため高速）:

1. 全Q&AペアをJSON（原文のみ）にパース
2. 各Q&AペアについてLM Studioスクリプトを呼び出して翻訳する
   - 問題文、各選択肢、解答、解説を個別に翻訳する
   ```bash
   python3 ${CLAUDE_PLUGIN_ROOT}/scripts/lmstudio-translate.py translate --model <選択済みモデル> --text "翻訳対象テキスト"
   ```
3. 翻訳済みJSONからAnkiConnect `addNotes` で一括投入

---

## 多言語カードのHTML構造

### 折りたたみ原文（`<details>` タグ）

英語等の外国語ソースの場合、原文を `<details>` タグで折りたたみ表示する。

```html
<details>
<summary>📄 原文（English）</summary>
<br>
[Original text here]
</details>
```

- デフォルトで閉じた状態（collapsed）
- タップ/クリックで展開
- `<summary>` に言語名を表示（`📄 原文（English）`）
- `<br>` を `<summary>` 直後に入れて余白を確保

---

## 品質チェック

カード作成後、以下を確認:

- [ ] 選択肢が**1つの `<ol>`** にまとまっているか（個別 `<ol>` になっていないか）
- [ ] `list-style-type: none` でデフォルト番号が非表示か
- [ ] 問題番号ヘッダーが含まれていないか
- [ ] pandocアーティファクトが残っていないか
- [ ] 無駄な改行が連続していないか
- [ ] 問題と解答のペアが正しくマッチしているか
- [ ] 英語ソースの場合、翻訳と原文折りたたみが正しいか
- [ ] バレット選択肢にA./B./C./D.レターが正しく付与されているか
- [ ] 比較テーブルがHTMLテーブルに変換されているか
- [ ] 複数正解の問題で全正解が表示されているか
- [ ] 正解の数字表記（Correct Response: N）が正しくレターにマッピングされているか
- [ ] 混在型EPUBで全セクションのQ&Aが漏れなく抽出されているか
- [ ] 翻訳の並列バッチが全て完了し、マージ後の件数が元の問題数と一致するか
- [ ] コードブロック（`<pre><code>`）の中身が空でないか（スパン注釈の処理失敗を検出）
- [ ] エスケープ文字（`\[`, `\]`, `\"`）がコード内で正しく`[`, `]`, `"`に復元されているか
- [ ] 誤記ヘッダー（CSSクラスとテキストの不一致）が修正されているか
- [ ] `clean_pandoc`の`\{[^}]*\}`が`<pre>`ブロック内のコードを破壊していないか
- [ ] `::: class_sBD` コードブロックがbase64退避→復元で正しく処理されているか
- [ ] 選択肢がA-I（最大9選択肢）まで対応しているか（A-E/A-Fでの打ち切りがないか）
- [ ] エスケープ除去の順序が正しいか（`\--\>` → `\>` の順。逆だと部分置換が残る）
- [ ] glob衝突でマージ済みファイルがアップロード対象に含まれていないか
