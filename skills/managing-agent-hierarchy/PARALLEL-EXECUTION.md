# 並列実行パターンとManager計画

## 🚀 並列実行の鉄則

### 基本ルール

1. **Developer起動は必ず1つのメッセージで同時実行**
2. **独立タスクは絶対に並列化**
3. **段階的実行でも各段階内は並列化**

### なぜ並列実行が重要か

- **時間短縮**: 4つのタスクを並列実行すれば、理論上1/4の時間
- **リソース活用**: Developer Agentは独立したスレッドで動作
- **効率最大化**: Claude Codeの性能を最大限に引き出す

---

## 📊 3つの実行パターン

### パターン1: 並列実行可能【推奨】

#### 適用条件
- タスク間に依存関係がない
- 独立して実装可能
- 並行開発が可能

#### 実行方法
```
1メッセージで全Developer同時起動
├─ dev1: タスクA
├─ dev2: タスクB
├─ dev3: タスクC
└─ dev4: タスクD
```

#### Manager計画例
```markdown
【配分計画】

実行方式: 並列実行可能

開発タスク:
1. dev1（Frontend）: ユーザー登録画面実装（wt-feat-auth）
2. dev2（Backend）: 認証API実装（wt-feat-auth）
3. dev3（Test）: E2Eテスト実装（wt-feat-auth）
4. dev4（Docs）: API仕様書作成（wt-feat-auth）

理由:
- 各タスクは独立しており、並行実装可能
- フロントエンド・バックエンド・テスト・ドキュメントは互いに依存しない
```

#### 実際の起動（Claude Code）
```bash
# 1メッセージで4つ同時起動
Agent thread dev1: ユーザー登録画面実装（wt-feat-auth）
Agent thread dev2: 認証API実装（wt-feat-auth）
Agent thread dev3: E2Eテスト実装（wt-feat-auth）
Agent thread dev4: API仕様書作成（wt-feat-auth）
```

---

### パターン2: 段階的実行【次善】

#### 適用条件
- タスク間に一部依存関係がある
- 段階的に進める必要がある
- ただし、各段階内では並列化可能

#### 実行方法
```
第1段階（並列）:
├─ dev1: タスクA
└─ dev2: タスクB
    ↓ 完了後
第2段階（並列）:
├─ dev3: タスクC（AとBの結果を使用）
└─ dev4: タスクD（AとBの結果を使用）
```

#### Manager計画例
```markdown
【配分計画】

実行方式: 段階的実行（2段階）

第1段階（並列）:
1. dev1（Backend）: データモデル設計（wt-feat-db）
2. dev2（Backend）: DBスキーマ定義（wt-feat-db）

第2段階（並列、第1段階完了後）:
3. dev3（Backend）: ビジネスロジック実装（wt-feat-db）
4. dev4（Backend）: API実装（wt-feat-db）

理由:
- データモデルとスキーマは並列実装可能
- ビジネスロジックとAPIはモデル・スキーマに依存
- 各段階内では並列実行で効率化
```

#### 実際の起動（Claude Code）
```bash
# 第1段階: 1メッセージで2つ同時起動
Agent thread dev1: データモデル設計（wt-feat-db）
Agent thread dev2: DBスキーマ定義（wt-feat-db）

# 第1段階完了後、第2段階: 1メッセージで2つ同時起動
Agent thread dev3: ビジネスロジック実装（wt-feat-db）
Agent thread dev4: API実装（wt-feat-db）
```

---

### パターン3: 順次実行【例外的】

#### 適用条件
- 強い依存関係がある
- タスクAの完了結果がタスクBの入力になる
- やむを得ない場合のみ使用

#### 実行方法
```
dev1: タスクA
    ↓ 完了後
dev2: タスクB（Aの結果を使用）
    ↓ 完了後
dev3: タスクC（Bの結果を使用）
    ↓ 完了後
dev4: タスクD（Cの結果を使用）
```

#### Manager計画例
```markdown
【配分計画】

実行方式: 順次実行（依存関係強）

実行順序:
1. dev1（Backend）: 基盤フレームワークセットアップ（wt-feat-base）
2. dev2（Backend）: dev1の成果物を使った認証基盤実装（wt-feat-base）
3. dev3（Backend）: dev2の成果物を使った権限管理実装（wt-feat-base）
4. dev4（Test）: dev3の成果物を使った統合テスト（wt-feat-base）

理由:
- 各タスクが前のタスクの成果物に強く依存
- 並列化は不可能
- 可能な限り避けるべきパターン
```

#### 実際の起動（Claude Code）
```bash
# 順次起動（各完了後に次を起動）
Agent thread dev1: 基盤フレームワークセットアップ（wt-feat-base）
# dev1完了待ち
Agent thread dev2: 認証基盤実装（wt-feat-base）
# dev2完了待ち
Agent thread dev3: 権限管理実装（wt-feat-base）
# dev3完了待ち
Agent thread dev4: 統合テスト（wt-feat-base）
```

**重要**: このパターンはできる限り避け、並列化可能な設計を検討してください。

---

## 🎯 Manager計画の判断フローチャート

```
タスク受信
    ↓
タスク間に依存関係は？
    ├─ No（独立）
    │   └─→ 【並列実行可能】
    │       全Developer同時起動
    │
    └─ Yes（依存あり）
        ↓
        段階的に分割可能？
        ├─ Yes
        │   └─→ 【段階的実行】
        │       各段階内で並列化
        │
        └─ No（強い依存）
            └─→ 【順次実行】
                やむを得ず順次実行
                （可能なら設計見直し）
```

---

## 📋 実行パターン比較表

| パターン | 並列度 | 実行時間 | 適用条件 | 推奨度 |
|---------|--------|---------|---------|--------|
| 並列実行 | 最大 | 最短 | タスク独立 | ⭐⭐⭐⭐⭐ |
| 段階的実行 | 中 | 中 | 一部依存 | ⭐⭐⭐ |
| 順次実行 | 最小 | 最長 | 強い依存 | ⭐（避けるべき） |

---

## ✅ 並列実行のベストプラクティス

### 1. タスク独立性の確保

**良い設計**:
```
✅ フロントエンド（UI）
✅ バックエンド（API）
✅ テスト（E2E）
✅ ドキュメント（仕様書）
→ 全て並列実行可能
```

**悪い設計**:
```
❌ データモデル設計
❌ それを使ったAPI実装
❌ それを使ったフロントエンド実装
❌ それを使ったテスト
→ 順次実行が必要（非効率）
```

### 2. 段階的実行での並列化最大化

**良い例**:
```
第1段階（並列）:
├─ データモデル設計
└─ UIコンポーネント設計

第2段階（並列）:
├─ API実装（モデル使用）
└─ フロントエンド実装（コンポーネント使用）
```

**悪い例**:
```
第1段階:
└─ データモデル設計のみ（1つだけ）

第2段階:
└─ API実装のみ（1つだけ）

第3段階:
└─ フロントエンド実装のみ（1つだけ）
→ 各段階が1タスクのみで非効率
```

### 3. 依存関係の明確化

**Managerは常に以下を明示**:
- どのタスクがどのタスクに依存するか
- なぜその実行順序が必要か
- 並列化できない理由

---

## ⚠️ よくある間違いと改善

### 間違い1: 並列化できるのに順次実行

**❌ 悪い例**:
```markdown
1. dev1: フロントエンド実装
   （完了待ち）
2. dev2: バックエンド実装
   （完了待ち）
3. dev3: テスト実装
```

**✅ 改善**:
```markdown
並列実行:
1. dev1: フロントエンド実装
2. dev2: バックエンド実装
3. dev3: テスト実装
（全て1メッセージで同時起動）
```

---

### 間違い2: 段階的実行で各段階が1タスクのみ

**❌ 悪い例**:
```markdown
第1段階: dev1のみ
第2段階: dev2のみ
第3段階: dev3のみ
```

**✅ 改善**:
```markdown
第1段階（並列）:
- dev1: タスクA
- dev2: タスクB

第2段階（並列）:
- dev3: タスクC（AとB使用）
- dev4: タスクD（AとB使用）
```

---

### 間違い3: Developer起動を複数メッセージに分割

**❌ 悪い例**:
```bash
# メッセージ1
Agent thread dev1: タスクA

# メッセージ2
Agent thread dev2: タスクB

# メッセージ3
Agent thread dev3: タスクC
```

**✅ 改善**:
```bash
# 1メッセージで全て起動
Agent thread dev1: タスクA
Agent thread dev2: タスクB
Agent thread dev3: タスクC
```

---

## 🔗 参照

- [ROLES.md](ROLES.md) - Manager Agentの役割詳細
- [WORKFLOWS.md](WORKFLOWS.md) - 実行フロー全体
- [GUIDELINES.md](GUIDELINES.md) - 判断基準と最適化
