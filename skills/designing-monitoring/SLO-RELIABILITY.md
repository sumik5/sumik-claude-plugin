# SLOベースの信頼性設計

## 概要

SLO（Service Level Objective）は、サービスの信頼性を定量的に管理し、アラート疲れを解消する現代的なモニタリング手法です。エラーバジェットという概念を使って、ビジネス目標とエンジニアリングの優先順位を明確に調整できます。

---

## SLI/SLO/SLA

### 定義と関係

| 用語 | 定義 | 役割 |
|------|------|------|
| **SLI** (Service Level Indicator) | サービスの品質を測定する具体的な指標 | 測定可能な値（レイテンシ、可用性等） |
| **SLO** (Service Level Objective) | SLIに対して設定する目標値 | 組織内部の信頼性目標 |
| **SLA** (Service Level Agreement) | 顧客との契約上の合意 | 法的・契約的な保証 |

**重要**: SLOは契約的制約ではなく、顧客満足度を測定する方法として使用すべきです。

### SLIの選び方

顧客体験をビジネス目標に直接沿った方法で測定するように定義します。

**良いSLIの例**:
- リクエストの成功率（可用性）
- レスポンスタイム（レイテンシ）
- スループット（処理量）
- 正確性（データ整合性）

**選定基準**:
1. **顧客視点**: ユーザーが実際に体験する指標か
2. **測定可能**: 自動的かつ継続的に測定できるか
3. **ビジネス影響**: ビジネス成果と相関があるか

### SLOの設定方法

#### 目標値の決定

| SLO | 月間許容ダウンタイム | ユースケース |
|-----|---------------------|-------------|
| 90% | 72時間 | 開発環境 |
| 99% | 7時間12分 | 一般的なWebサービス |
| 99.9% | 43分50秒 | ビジネスクリティカル |
| 99.95% | 21分54秒 | ミッションクリティカル |
| 99.99% | 4分19秒 | 高可用性システム |
| 99.999% | 26秒 | 超高可用性（自動修復必須） |

#### 期間の選択

**推奨: 30日間のスライディングウィンドウ**

| 期間 | メリット | デメリット |
|------|---------|-----------|
| 7日 | 素早いフィードバック | 顧客の記憶と不一致 |
| 30日 | 顧客満足度と一致 | ✅ 推奨 |
| 90日 | 長期トレンド | インシデント収拾が長期化 |

**固定ウィンドウ vs スライディングウィンドウ**:
- **固定ウィンドウ（非推奨）**: 月末でリセット → 顧客感情と不一致
- **スライディングウィンドウ（推奨）**: 人間の記憶・感情に合致した滑らかな体験

---

## エラーバジェット

### 定義と計算方法

**エラーバジェット** = ビジネスが許容できるシステム停止の最大量

#### 時間ベースの計算

```
許容ダウンタイム = (1 - SLO目標) × 期間
```

例: 99.9%のSLO、30日間
```
許容ダウンタイム = (1 - 0.999) × 30日 × 24時間 × 60分
                 = 43分50秒
```

#### イベントベースの計算

```
エラーバジェット = 総イベント数 × (1 - SLO目標)
```

例: 月間43,200イベント、99%のSLO
```
エラーバジェット = 43,200 × (1 - 0.99) = 432イベント
```

**エラーバジェット残量** = エラーバジェット - 消費済みエラー数

### エラーバジェットポリシー

| エラーバジェット残量 | アクション |
|-------------------|----------|
| 75%以上 | 通常運用（新機能開発優先） |
| 50-75% | 監視強化（信頼性改善タスクを追加） |
| 25-50% | 信頼性優先（新機能追加を抑制） |
| 0-25% | 緊急対応（新機能凍結、信頼性改善に集中） |
| 枯渇 | 機能追加停止（SLO達成まで信頼性作業のみ） |

### バジェット消費時のアクション

1. **予防的対応**: バジェット枯渇前に軌道修正
2. **優先順位変更**: 新機能開発 → 信頼性向上
3. **根本原因分析**: 消費パターンから障害要因を特定
4. **改善実施**: インフラ強化、コード改善、テスト追加

---

## SLOベースのアラート

### 従来の閾値ベースアラートとの違い

| 観点 | 従来の閾値ベース | SLOベース |
|------|---------------|----------|
| 判断基準 | 技術的な閾値（CPU 80%等） | 顧客影響の定量化 |
| アラート頻度 | ノイズが多い | 本当に重要な時のみ |
| 優先順位 | 不明確 | エラーバジェット消費速度で判断 |
| ビジネス連携 | 弱い | 強い（顧客体験と直結） |

### バーンレートアラート

**バーンレート** = 現在の消費速度でエラーバジェットが枯渇するまでの時間

#### 予測バーンアラートの種類

**1. ゼロレベルアラート**
- エラーバジェット枯渇時に発報
- 事後対応のみ（非推奨）

**2. 固定しきい値アラート**
- 残量30%以下で発報
- ゴールポストを動かすだけで粗雑

**3. 予測バーンアラート（推奨）**
- 現在のトレンドから枯渇時刻を予測
- 事前対応が可能

#### ルックアヘッドウィンドウとベースラインウィンドウ

**ルックアヘッドウィンドウ**: どこまで先を予測するか

| 予測期間 | 緊急度 | 対応時間 |
|---------|-------|---------|
| 1時間以内 | 緊急 | 即座にオンコール |
| 数時間 | 高 | 当日中に対応 |
| 数日 | 中 | 翌営業日に対応 |

**ベースラインウィンドウ**: 過去データをどこまで見るか

**実践的な比率**: ルックアヘッド : ベースライン = 4 : 1

| ルックアヘッド | ベースライン |
|-------------|------------|
| 4時間後 | 過去1時間 |
| 24時間後 | 過去6時間 |
| 4日後 | 過去1日 |

### マルチウィンドウアラート

複数の時間スケールでバーンレートを監視します。

**設定例**:
```
アラート1: 過去1時間で4時間後に枯渇予測
アラート2: 過去6時間で24時間後に枯渇予測
アラート3: 過去1日で4日後に枯渇予測
```

**注意**: 異なるベースラインを使うため、短期アラートが発報しても長期アラートは発報しない場合があります。これは正常な動作です。

### 短期間バーンアラート vs コンテキストアウェアバーンアラート

| 手法 | 計算方法 | コスト | ユースケース |
|------|---------|-------|-------------|
| **短期間** | 直近期間のみで外挿 | 低 | シンプルな監視 |
| **コンテキストアウェア** | 全ウィンドウの履歴を考慮 | 高 | 残量を考慮した緊急度判定 |

**コンテキストアウェアの利点**:
- エラーバジェット残量10%での重大エラー → 高緊急度
- エラーバジェット残量90%での重大エラー → 中緊急度

### 比例外挿の重要性

**線形外挿（非推奨）**:
```
過去6時間で25ユニット失敗 → 24時間で100ユニット失敗予測
```

**比例外挿（推奨）**:
```
過去6時間: 50ユニット中25ユニット失敗（50%）
24時間予測: 1,440ユニット × 50% = 720ユニット失敗
```

トラフィック量の変動を考慮した正確な予測が可能です。

### アラート疲れの解消

**SLOベースアラートで解決される問題**:
1. **症状ベースアラートの氾濫**: 個別のメトリクス閾値超過が大量発生
2. **重要度不明**: どのアラートを優先すべきか不明確
3. **顧客影響不明**: 技術的問題が顧客にどう影響するか不明

**解決策**:
- エラーバジェット消費速度で自動的に優先順位付け
- 顧客影響を定量化したアラート
- ノイズの多い個別メトリクスアラートを統合

---

## SLOを使ったデバッグ

### SLO違反時のトリアージ

#### 1. バーンパターンの診断

**パターン1: 緩やかな消費**
- 通常運用での散発的エラー
- 対応: 次回スプリントで改善

**パターン2: バースト的消費**
- 一時的な障害
- 対応: 根本原因を特定し修正

**パターン3: 急激な大量消費**
- 重大インシデント
- 対応: 即座にオンコール、緊急対応

#### 2. トレンド分析

**90日スライディングウィンドウで長期トレンドを確認**:
- 過去の大規模障害の影響を可視化
- 回復パターンの理解
- システム全体の信頼性トレンド

### ユーザー影響の定量化

**イベントベースSLOの利点**:
```
時系列ベース: 1分間全体が「悪い」→ 100%カウント
イベントベース: その分の6%のイベントが失敗 → 6%カウント
```

**部分的障害の測定**:
- 99.99%システムでの1%障害 = 99%システムでの100%障害
- どちらも対応時間は7時間以上
- 部分的障害を正確に測定することで猶予時間を確保

### エスカレーション基準

| バーン速度 | エラーバジェット残量 | エスカレーション |
|----------|-------------------|----------------|
| 数分で枯渇 | 関係なし | Tier 1 - 即座にオンコール全員 |
| 数時間で枯渇 | 30%未満 | Tier 2 - オンコール担当者 |
| 数時間で枯渇 | 30%以上 | Tier 3 - 当日中に調査 |
| 数日で枯渇 | 50%未満 | Tier 3 - 翌営業日対応 |
| 数日で枯渇 | 50%以上 | Tier 4 - 次回スプリント対応 |

---

## オブザーバビリティデータ vs 時系列データ

### 時系列データの限界

**問題1: 粗い粒度**
```
1分単位の評価: P95が閾値超過 → その分全体が「悪い」
99.99%SLO、月間エラーバジェット4.32分の場合
→ 1回の評価でバジェットの25%を消費
```

**問題2: 厳しいSLOでの不適合**
```
99.99%以上のSLO → エラーバジェットは数分
1分単位の評価では対応時間が不足
```

### イベントベースの利点

| 観点 | 時系列ベース | イベントベース |
|------|------------|--------------|
| 粒度 | 分単位・秒単位 | リクエスト単位 |
| 部分障害の測定 | 不可能（全体が悪） | 正確（6%障害=6%カウント） |
| 対応猶予 | 短い | 長い |
| 顧客体験の反映 | 粗い | 正確 |

**推奨**: イベントデータをSLO計算に使用することで、実際のユーザー体験を正確に評価できます。

---

## SLO導入のステップ

### フェーズ1: 準備（1-2週間）

1. **SLI候補の選定**
   - 顧客体験に最も影響する指標を3-5個選択
   - 可用性、レイテンシから開始（推奨）

2. **現状測定**
   - 過去30-90日のパフォーマンスデータを収集
   - 現在の達成レベルを把握

3. **目標設定**
   - 現状より少し高めの目標を設定
   - ビジネスステークホルダーと合意

### フェーズ2: 試験運用（1-2ヶ月）

1. **SLO監視ダッシュボード作成**
   - エラーバジェット消費グラフ
   - バーンレート表示
   - トレンドチャート

2. **アラート設定（通知のみ）**
   - まずは記録のみ、オンコール呼び出しなし
   - 誤報率の確認

3. **定期レビュー**
   - 週次でSLO達成状況を確認
   - 閾値の調整

### フェーズ3: 本格運用（継続）

1. **オンコールアラート有効化**
   - バーンレートアラートをオンコール連携
   - エスカレーションポリシー設定

2. **エラーバジェットポリシー適用**
   - バジェット残量に応じた開発優先順位変更
   - チーム合意のポリシー文書化

3. **継続的改善**
   - SLO目標の定期見直し（四半期ごと）
   - 新サービスへの展開

### チームへの展開

**成功のポイント**:
1. **小さく始める**: 1サービス、1-2個のSLIから
2. **可視化重視**: ダッシュボードで常に見える状態に
3. **教育**: SLOの意義とエラーバジェットの使い方を共有
4. **反復**: 実運用で学びながら改善

**避けるべき失敗パターン**:
- ❌ いきなり全サービスに適用
- ❌ 複雑すぎるSLI定義
- ❌ 非現実的に高い目標設定
- ❌ ステークホルダー合意なしの導入

---

## まとめ

**SLOベースの信頼性設計の利点**:
1. **顧客視点**: 技術指標ではなく顧客体験を測定
2. **明確な優先順位**: エラーバジェットで開発と信頼性のバランス調整
3. **アラート疲れ解消**: 本当に重要な時のみアラート
4. **ビジネス連携**: 経営層とエンジニアの共通言語

**次のステップ**:
- オブザーバビリティデータとSLOを統合することで、バーンアラート発報時に根本原因を即座に特定可能
- `implementing-opentelemetry` スキルでイベントベースデータ収集を実装
- `OBSERVABILITY.md` でコア分析ループと構造化イベントを理解
