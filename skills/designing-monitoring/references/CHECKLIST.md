# 監視システム設計・実装チェックリスト

本チェックリストは designing-monitoring スキルの一部です。テレメトリーシステムの設計・実装・運用の各フェーズで確認すべき項目を網羅します。

---

## 1. プロジェクト開始時の設計判断

### 1.1 テレメトリー種別の選定

- [ ] ログ収集が必要か確認
- [ ] メトリクス収集が必要か確認
- [ ] トレーシング収集が必要か確認
- [ ] 各種別の保存期間を決定（例: ログ30日、メトリクス90日、トレース7日）
- [ ] サンプリング戦略を決定（全量 vs サンプリング）

### 1.2 ストレージシステムの選定

#### ログストレージ

- [ ] 全文検索が必須か確認 → Elasticsearch検討
- [ ] コスト削減が優先か確認 → Loki検討
- [ ] スキーマ柔軟性が必要か確認 → MongoDB検討
- [ ] クエリパターンを特定（ラベルクエリ vs 全文検索 vs 集約）
- [ ] Ingestion Rateの見積もり（events/sec）
- [ ] Query Rateの見積もり（queries/sec）
- [ ] Cardinalityの見積もり（一意なフィールド/ラベル数）

#### メトリクスストレージ

- [ ] Prometheus互換が必要か確認
- [ ] 長期保存（90日以上）が必要か確認 → InfluxDB/Thanos検討
- [ ] アラートルールを設計
- [ ] メトリクス保存期間を決定
- [ ] カーディナリティ制限を設定（推奨: <1M series）

#### トレーシングストレージ

- [ ] OpenTelemetry対応が必要か確認
- [ ] サンプリングレート決定（推奨: 0.1%-1%）
- [ ] トレース保存期間決定（推奨: 7-14日）
- [ ] バックエンドストレージ選定（Cassandra vs Elasticsearch）

### 1.3 アーキテクチャパターンの選定

- [ ] プッシュ型 vs プル型を決定
- [ ] 同期送信 vs 非同期送信を決定
- [ ] バッチ送信の採用判断（推奨: バッチサイズ500-1000）
- [ ] リトライ戦略の設計（exponential backoff等）
- [ ] データ損失許容度の確認（at-most-once vs at-least-once）

---

## 2. 実装フェーズのチェック項目

### 2.1 ロギング実装

#### 構造化ロギング

- [ ] 構造化ログ形式を採用（JSON推奨）
- [ ] 必須フィールドを定義（timestamp, level, event, service等）
- [ ] ログレベルを適切に設定（debug, info, warn, error）
- [ ] コンテキスト情報のbind実装（user_id, request_id等）
- [ ] 機密情報のマスキング実装（password, token等）

#### パフォーマンス最適化

- [ ] 非同期ログ出力の実装（asyncio, threading等）
- [ ] バッファリングの実装
- [ ] ログローテーション設定
- [ ] ログ圧縮設定

#### 環境別設定

- [ ] 開発環境: ConsoleRenderer設定
- [ ] 本番環境: JSONRenderer設定
- [ ] ログ出力先の環境変数化

### 2.2 メトリクス実装

#### ラベル設計

- [ ] 低カーディナリティラベルのみ使用（例: method, status, endpoint）
- [ ] 高カーディナリティデータの除外（例: user_id, request_id）
- [ ] ラベル数の制限（推奨: <10ラベル/メトリクス）
- [ ] ラベル値のバリデーション実装

#### メトリクス種別

- [ ] Counter実装（増加のみのメトリクス）
- [ ] Gauge実装（増減するメトリクス）
- [ ] Histogram実装（分布を記録）
- [ ] Summary実装（分位数を記録）

#### カーディナリティ管理

- [ ] メトリクス数の見積もり
- [ ] メモリ使用量の計算（カーディナリティ × 3KB）
- [ ] カーディナリティ上限の監視設定
- [ ] 不要なラベルの除去（metric_relabel_configs）

### 2.3 トレーシング実装

#### インストルメンテーション

- [ ] 自動インストルメンテーション有効化
- [ ] カスタムスパンの追加（ビジネスロジック箇所）
- [ ] スパン属性の設定（http.method, http.status_code等）
- [ ] エラーステータスの記録

#### コンテキスト伝播

- [ ] HTTPヘッダーでのコンテキスト伝播実装（W3C Trace Context）
- [ ] メッセージキュー経由の伝播実装
- [ ] gRPC経由の伝播実装

#### サンプリング

- [ ] サンプリング戦略の実装（probabilistic vs rate limiting）
- [ ] 重要トランザクションの強制サンプリング設定
- [ ] エラートレースの全量収集設定

---

## 3. インフラストラクチャ設定

### 3.1 Kubernetes環境

#### ログ収集

- [ ] ログ収集方式の選択（stdout vs sidecar vs DaemonSet）
- [ ] FluentD/Fluentbit設定ファイル作成
- [ ] ログフォーマット統一（JSON推奨）
- [ ] Namespace/Pod情報の自動付与設定

#### メトリクス収集

- [ ] ServiceMonitor/PodMonitor設定
- [ ] Prometheusスクレイプ間隔設定（推奨: 15-30秒）
- [ ] リソース制限設定（CPU/メモリ）
- [ ] 永続化ストレージ設定

#### トレーシング収集

- [ ] Jaeger Agent DaemonSet設定
- [ ] Jaeger Collector設定
- [ ] サンプリング設定ConfigMap作成
- [ ] ストレージバックエンド接続設定

### 3.2 Serverless/FaaS環境

#### AWS Lambda

- [ ] CloudWatch Logsへの出力設定
- [ ] X-Rayトレーシング有効化
- [ ] カスタムメトリクスのCloudWatch送信実装
- [ ] コールドスタート最適化

#### Azure Functions

- [ ] Application Insights統合
- [ ] ログレベル設定
- [ ] サンプリング設定
- [ ] 依存関係追跡設定

#### Google Cloud Functions

- [ ] Cloud Logging統合
- [ ] Cloud Trace統合
- [ ] エラーレポート設定
- [ ] ログエントリのラベル付け

### 3.3 ネットワーク設定

#### プロトコル選択

- [ ] TCP vs UDP判断（信頼性 vs レイテンシ）
- [ ] タイムアウト値設定
- [ ] 接続プール設定
- [ ] リトライポリシー設定

#### セキュリティ

- [ ] TLS/SSL設定（転送中暗号化）
- [ ] 認証設定（APIキー/トークン）
- [ ] ネットワークポリシー設定
- [ ] ファイアウォールルール設定

---

## 4. ストレージシステム設定

### 4.1 Elasticsearch

#### インデックス設計

- [ ] インデックステンプレート作成
- [ ] シャード数決定（推奨: ノード数 × 1-3）
- [ ] レプリカ数決定（推奨: 1-2）
- [ ] リフレッシュ間隔設定（推奨: 30秒）

#### パフォーマンス最適化

- [ ] Bulk APIの使用（バッチサイズ500-1000）
- [ ] Index Lifecycle Management (ILM)設定
- [ ] フィールドマッピング最適化
- [ ] 動的マッピング制御

#### 運用設定

- [ ] スナップショット設定
- [ ] クラスター監視設定
- [ ] アラートルール設定
- [ ] ディスク使用率監視

### 4.2 Loki

#### ラベル設計

- [ ] ラベル数制限（推奨: <30）
- [ ] 静的ラベルの選定（service, environment, host）
- [ ] 動的ラベルの除外
- [ ] ラベルカーディナリティ監視

#### Retention設定

- [ ] 保存期間設定
- [ ] チャンクサイズ設定
- [ ] 圧縮設定
- [ ] ストレージバックエンド選定（S3/GCS/filesystem）

#### Promtail設定

- [ ] ログファイルパス設定
- [ ] ラベル抽出ルール設定
- [ ] パース処理設定（regex/json）
- [ ] バッファリング設定

### 4.3 Prometheus

#### スクレイプ設定

- [ ] スクレイプ間隔設定（推奨: 15-30秒）
- [ ] タイムアウト設定
- [ ] ターゲット自動検出設定（Kubernetes SD）
- [ ] メトリクスRelabel設定

#### ストレージ設定

- [ ] 保存期間設定（推奨: 15-90日）
- [ ] ストレージサイズ見積もり
- [ ] TSDB圧縮設定
- [ ] リモートライト設定（長期保存用）

#### アラート設定

- [ ] Alertmanager統合
- [ ] アラートルール定義
- [ ] 通知チャネル設定（Slack/PagerDuty等）
- [ ] アラートグルーピング設定

### 4.4 InfluxDB

#### データベース設計

- [ ] Retention Policy設定
- [ ] Shard Duration設定
- [ ] Continuous Query設定（ダウンサンプリング）
- [ ] カーディナリティ上限設定

#### パフォーマンス設定

- [ ] キャッシュサイズ設定
- [ ] バッチサイズ設定
- [ ] 最大series数制限
- [ ] タグ値数制限

### 4.5 Jaeger

#### サンプリング設定

- [ ] デフォルトサンプリングレート設定（推奨: 0.1%-1%）
- [ ] サービス別サンプリング設定
- [ ] エラートレースの全量収集設定
- [ ] レート制限設定

#### ストレージ設定

- [ ] バックエンド選定（Cassandra vs Elasticsearch）
- [ ] トレース保存期間設定（推奨: 7-14日）
- [ ] スパンストレージ設定
- [ ] インデックス設定

---

## 5. 監視・運用フェーズ

### 5.1 テレメトリーパイプライン監視

#### パイプライン健全性

- [ ] Ingestion Rate監視
- [ ] データ損失率監視
- [ ] レイテンシ監視
- [ ] エラーレート監視

#### リソース監視

- [ ] CPU使用率監視
- [ ] メモリ使用率監視
- [ ] ディスクI/O監視
- [ ] ネットワーク帯域監視

#### SLO設定

- [ ] テレメトリーデータ到達時間SLO設定（例: 99%が30秒以内）
- [ ] クエリレスポンスタイムSLO設定（例: 95%が1秒以内）
- [ ] データ保持SLO設定（例: 99.9%のデータ保存）

### 5.2 ストレージシステム監視

#### Elasticsearch

- [ ] クラスター状態監視（green/yellow/red）
- [ ] JVMヒープ使用率監視
- [ ] インデックス作成レート監視
- [ ] 検索レイテンシ監視

#### Loki

- [ ] Ingesterメモリ監視
- [ ] チャンク作成レート監視
- [ ] クエリパフォーマンス監視
- [ ] ストレージ容量監視

#### Prometheus

- [ ] TSDBサイズ監視
- [ ] スクレイプ失敗率監視
- [ ] カーディナリティ監視
- [ ] クエリレイテンシ監視

### 5.3 コスト最適化

#### ストレージコスト

- [ ] データ保存期間の最適化
- [ ] 不要なメトリクス/ログの削減
- [ ] ダウンサンプリング実装
- [ ] コールドストレージへの移行

#### 処理コスト

- [ ] サンプリングレート調整
- [ ] バッチサイズ最適化
- [ ] クエリキャッシュ活用
- [ ] インデックス最適化

---

## 6. セキュリティ・コンプライアンス

### 6.1 データ保護

- [ ] 転送中データの暗号化（TLS）
- [ ] 保存データの暗号化（at-rest encryption）
- [ ] アクセス制御設定（RBAC）
- [ ] 監査ログ記録

### 6.2 機密情報管理

- [ ] パスワード/トークンのマスキング実装
- [ ] PII（個人識別情報）の除外/匿名化
- [ ] クレジットカード番号の除外
- [ ] IPアドレスの匿名化（GDPR対応）

### 6.3 コンプライアンス

- [ ] データ保存地域の確認（GDPR/データローカライゼーション）
- [ ] データ保存期間のポリシー遵守
- [ ] データ削除要求への対応手順策定
- [ ] 監査証跡の保持

---

## 7. 正規表現最適化（パイプライン処理）

### 7.1 基本最適化

- [ ] アンカータグ（`^`, `$`）の使用
- [ ] 文字セットの具体的指定（`.`の最小化）
- [ ] Lazy演算子（`*?`, `+?`）の使用
- [ ] 正規表現のプリコンパイル
- [ ] Fail Fast戦略の適用

### 7.2 パフォーマンス検証

- [ ] 正規表現のベンチマーク実施
- [ ] バックトラック発生の確認
- [ ] メモリ使用量の測定
- [ ] 代替実装（文字列操作）との比較

---

## 8. カーディナリティ管理

### 8.1 設計時チェック

- [ ] 高カーディナリティフィールド/ラベルの特定
- [ ] カーディナリティ見積もり
- [ ] ストレージ容量への影響計算
- [ ] 代替設計の検討（ラベル除去/バケット化/サンプリング）

### 8.2 実装時チェック

- [ ] ラベル/フィールドのホワイトリスト化
- [ ] 動的ラベル/フィールドの制限
- [ ] バケット化実装（連続値 → 離散値）
- [ ] サンプリング実装

### 8.3 運用時チェック

- [ ] カーディナリティ監視ダッシュボード作成
- [ ] カーディナリティ急増アラート設定
- [ ] 定期的なカーディナリティレポート作成
- [ ] 不要なラベル/フィールドの削除

---

## 9. 監視アセスメント（現状評価）

### 9.1 ビジネスKPI監視

- [ ] ビジネスKPIが定義されているか
- [ ] ビジネスKPIの監視が実装されているか
- [ ] ビジネスKPIのダッシュボードが存在するか
- [ ] ビジネスKPIと技術メトリクスの紐付けが明確か
- [ ] ビジネスKPIのアラートが設定されているか

### 9.2 フロントエンド監視

- [ ] Real User Monitoring (RUM) が実装されているか
- [ ] Synthetic監視が実装されているか
- [ ] DOMパフォーマンスメトリクスを収集しているか（FCP, LCP, CLS等）
- [ ] JavaScriptエラーのトラッキングが実装されているか
- [ ] ブラウザ別/デバイス別の分析が可能か

### 9.3 アプリケーションとサーバの監視

- [ ] アプリケーションレベルのメトリクスを計測しているか
- [ ] healthエンドポイントが実装されているか
- [ ] アプリケーションログが適切に収集されているか
- [ ] OS標準メトリクス（CPU/メモリ/ディスク/ネットワーク）を監視しているか
- [ ] ミドルウェア（DB/キャッシュ/MQ）の監視が実装されているか
- [ ] マイクロサービス間の依存関係が可視化されているか
- [ ] サーバレス関数のメトリクスを収集しているか

### 9.4 セキュリティ監視

- [ ] セキュリティイベントのロギングが実装されているか
- [ ] 不正アクセスの検知機能があるか
- [ ] コンプライアンス要件に対応した監査ログが存在するか
- [ ] HIDS（ホスト型侵入検知システム）が導入されているか
- [ ] NIDS（ネットワーク型侵入検知システム）が導入されているか

### 9.5 アラート品質評価

- [ ] すべてのアラートに手順書が紐付けられているか
- [ ] 過去1ヶ月の誤報率が10%未満か
- [ ] アラートは緊急対応 vs FYI通知で分類されているか
- [ ] アラート通知にメールを使用していないか
- [ ] 月次でアラートレビューを実施しているか
- [ ] 自動復旧が可能なアラートに対してauto-healing実装されているか
- [ ] アラートに動的閾値（moving average等）を使用しているか

### 9.6 オンコール・インシデント管理

- [ ] オンコールローテーションが確立されているか
- [ ] オンコール担当者への補償制度があるか
- [ ] インシデント対応フローが文書化されているか
- [ ] インシデントコマンダーの役割が定義されているか
- [ ] インシデント後の振り返りが実施されているか（48時間以内）
- [ ] 振り返りドキュメントが組織全体に公開されているか

### 9.7 監視システムの成熟度

- [ ] 監視システムの所有権が明確か（特定のチーム/個人に依存していないか）
- [ ] 監視設定がコード管理されているか（Infrastructure as Code）
- [ ] 監視システム自体の監視が実装されているか（meta-monitoring）
- [ ] 監視コストが追跡されているか
- [ ] 四半期ごとに監視戦略がレビューされているか

---

## 10. ドキュメント・引き継ぎ

### 10.1 設計ドキュメント

- [ ] アーキテクチャ図作成
- [ ] データフロー図作成
- [ ] ストレージシステム選定理由記述
- [ ] カーディナリティ設計書作成

### 10.2 運用ドキュメント

- [ ] 運用手順書作成
- [ ] トラブルシューティングガイド作成
- [ ] エスカレーションフロー文書化
- [ ] SLA/SLO定義文書作成

### 10.3 開発者向けドキュメント

- [ ] ロギング実装ガイド作成
- [ ] メトリクス実装ガイド作成
- [ ] トレーシング実装ガイド作成
- [ ] コード例・テンプレート整備

---

## 11. 継続的改善

### 11.1 定期レビュー

- [ ] 四半期ごとのパフォーマンスレビュー
- [ ] コスト分析レポート作成
- [ ] カーディナリティトレンド分析
- [ ] ストレージ容量予測

### 11.2 最適化施策

- [ ] 不要なメトリクス/ログの削除
- [ ] サンプリングレート調整
- [ ] クエリパターン最適化
- [ ] インデックス戦略見直し

### 11.3 新技術評価

- [ ] 新しいストレージシステムの評価
- [ ] 新しいテレメトリープロトコルの評価（OpenTelemetry等）
- [ ] 新しい可視化ツールの評価
- [ ] AIベース異常検知の評価

---

## まとめ

本チェックリストは、テレメトリーシステムと監視戦略のライフサイクル全体をカバーしています:

1. **設計フェーズ**: ストレージ選定、アーキテクチャ決定
2. **実装フェーズ**: ログ・メトリクス・トレースの実装
3. **インフラフェーズ**: Kubernetes、Serverless環境の設定
4. **ストレージフェーズ**: Elasticsearch、Loki、Prometheus等の設定
5. **運用フェーズ**: 監視、コスト最適化
6. **アセスメント**: 現状評価、成熟度確認
7. **改善フェーズ**: 継続的な最適化

各項目を順次確認し、堅牢で持続可能な監視システムを構築してください。
