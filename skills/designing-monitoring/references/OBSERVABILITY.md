# オブザーバビリティの基礎

## オブザーバビリティとは

### 制御理論からソフトウェアへ

オブザーバビリティは、制御理論において「外部出力の知識からシステムの内部状態をどれだけうまく推測できるかの尺度」として定義されています。この概念をソフトウェアシステムに適用すると、以下の能力が必要となります:

- アプリケーションの内部構造を理解する
- 予測できない斬新な状態に陥っても、システムの状態を理解する
- 外部ツールで観測・調査して内部動作を理解する
- **新たにコードを改修することなく** 内部状態を理解する

### オブザーバビリティの判断基準

システムがオブザーバビリティを備えているかを判断するための質問:

- 異常を説明する際に、調査が行き詰まることなく継続的にアプリケーション内部について質問に答えられるか
- 任意の特定ユーザーが任意の時間に体験していることを理解できるか
- システムパフォーマンスを任意の切り口で、トップレベルから単一リクエストまで素早く見られるか
- 予期せぬ挙動を体験したユーザーに共通する属性を正確に特定できるか
- 隠れたタイムアウトや異常値を見つけ出せるか
- 過去に経験したことがない問題でも、事前の予測なしに答えられるか

オブザーバビリティとは、システムがどのような状態になったとしても、どんなに斬新で奇妙な状態であっても、**新しいコードをデプロイすることなく** 理解し説明できることを意味します。

### 「既知の未知」と「未知の未知」

| 対象 | アプローチ | 発見できるもの |
|------|----------|--------------|
| モニタリング | リアクティブ（反応的） | **既知の未知** - 過去に発生したことのある障害モード |
| オブザーバビリティ | プロアクティブ（積極的） | **未知の未知** - 今まで見たことがない斬新な障害モード |

---

## モニタリングとオブザーバビリティの違い

### デバッグ手法の比較

#### モニタリングベースのデバッグ

- 過去の障害モードに基づくパターン認識に依存
- 予測可能なしきい値の検出
- ダッシュボードとメトリクスを使った視覚的パターンマッチング
- システムに精通した経験者が最も効果的

**限界:**
- 新しい問題には対応できない
- 直感や経験に依存
- 確証バイアスの影響を受けやすい
- システムごとに異なるスキルが必要

#### オブザーバビリティベースのデバッグ

- 第一原理からの体系的な調査
- 任意のディメンションでのデータ探索
- 仮説駆動型デバッグ
- 好奇心旺盛なエンジニアが最も効果的

**利点:**
- 未経験の問題にも対応可能
- システムの深い知識が不要
- 異なるシステム間で通用する調査能力
- 民主化されたデバッグ

### システム複雑性の転換点

モノリシックシステムから現代の分散システムへの移行により、以下の変化が発生:

**従来の前提（もはや通用しない）:**
- アプリケーションはモノリスである
- データベースは1つである
- ノードやコンテナは静的で長期間稼働している
- 限られたディメンションで相関関係を調査する

**現代のシステムの実態:**
- 多数のサービスが疎結合で連携
- 複数の永続化機構を使用
- インフラストラクチャが動的に増減
- 事実上無制限のディメンションで相関関係を分析

---

## カーディナリティとディメンションの役割

### カーディナリティ（Cardinality）

集合に含まれるデータの値の一意性を示す指標:

| カーディナリティ | 例 | デバッグでの価値 |
|----------------|----|--------------|
| **高い** | UUID、ユーザーID、トレースID | ⭐⭐⭐ 非常に有用 |
| **中程度** | 姓名、セッションID | ⭐⭐ 有用 |
| **低い** | ステータスコード、HTTPメソッド | ⭐ 限定的 |

**重要:** 高いカーディナリティの情報は、ほとんどの場合にもっとも役に立ちます。メトリクスベースのシステムでは、カーディナリティの高いディメンションを扱えません。

### ディメンション（Dimension）

データ内のキーの数を意味します。オブザーバビリティでは、イベントが「幅広い」（何百、何千ものキーバリューペア）ことが重要です。

**ディメンション活用例:**
```
# 6つの基本ディメンション
time, app, host, user, endpoint, status

# 任意の組み合わせでクエリー可能
- hostがfooで、過去30分間に発生した、すべての502エラー
- userがbarで、endpoint が /export のリクエストで発生した、すべての403エラー
- appがbazで、endpoint が /payments のリクエストを、どのホストから送信されたかを含めて
```

高いディメンションのデータは、アプリケーション動作の隠れたパターンを見つける可能性を高めます。

---

## 構造化イベント

### イベントの定義

**構造化イベント** とは、本番環境のサービスへのリクエストがサービスとやりとりしている間に発生したすべての記録で、キーバリューペアとして整理されたデータです。

**作業単位のスコープ:**
- HTTPリクエストを受け、レスポンスを返すまで
- リクエストパラメーター、環境情報、ランタイム内部情報を含む
- 実行中に追加される情報（ユーザーID、実行時間、エラーメッセージなど）

### メトリクスの限界

メトリクスは「あらかじめ定義された期間にわたってシステムの状態を集計したもの」であり、以下の限界があります:

- **事前集計された測定値** - 最小粒度が固定
- **コンテキスト欠如** - リクエスト単位の詳細が失われる
- **再構築不可能** - 同一リクエストから生成されたメトリクスをつなぎ合わせられない
- **カーディナリティ制限** - 高いカーディナリティのデータを扱えない

### ログの限界

**非構造化ログ:**
- 人間が読めるように設計されているが、機械処理が困難
- 複数行にまたがる物語構造
- パーサーが必要だが、フォーマット規約が統一されていない

**構造化ログ:**
- 機械的に解析可能
- 構造化イベントとして扱えるように再設計すれば有用

### デバッグに役立つイベントのプロパティ

成熟した計装では、生成されるイベントは300〜400のディメンションを含むことが一般的です:

- **任意にワイドな構造** - 既知のフィールドに制限されない
- **高いカーディナリティをサポート** - UUID、リクエストID、ユーザーID等
- **高いディメンション** - 何百ものキーバリューペア
- **スキーマレス** - 事前にデータ型や形状を定義する必要がない

**クエリー例:**
「iOSのバージョン11.0.4を実行しているすべてのカナダのユーザーで、フランス語の言語パックを使用していて、先週の火曜日にアプリをインストールし、ファームウェアのバージョン1.4.101で、リージョンus-west-1のshard3に写真を保存している人」

このような高いカーディナリティと高いディメンションの組み合わせが、干し草の山から針を見つける能力を提供します。

---

## イベントとトレースの接続

構造化イベントを分散トレースとして接続することで、以下が可能になります:

- 複数のホストにまたがる問題のデバッグ
- サービス間の依存関係の可視化
- リクエストのライフサイクル全体の追跡
- バージョン互換性の問題の発見

分散トレースは、モノリスのようにすべての情報を頭の中に入れておく必要性を排除し、チームが協力してシステムをデバッグするための共有コンテキストを提供します。

---

## コア分析ループ

### 第一原理からのデバッグ

**第一原理** とは、あるシステムに関する基本的な仮定で、他の仮定から演繹されたものではないものです。第一原理からのデバッグは、オブザーバビリティの核となる能力です。

### コア分析ループの4ステージ

```
1. 全体像の把握
   ↓
2. 真実の検証（パフォーマンスの変化を確認）
   ↓
3. 要素の探索
   - サンプル行を調べて異常値を発見
   - ディメンションで切り取りパターンを探す
   - フィルタリングで異常値を明確化
   ↓
4. 仮説の確認
   - 発生している問題が理解できたか？
     → Yes: 完了
     → No: ステップ3に戻る
```

### 総当り分析の自動化

コア分析ループの総当たり部分は、オブザーバビリティツールが自動化すべきです:

**自動化のアプローチ:**
1. 異常領域（気になるシステムパフォーマンス）を分離
2. 異常領域と基準領域の両方ですべてのディメンションの値を取得
3. 差分を計算してソート
4. もっとも差が大きいディメンションを提示

**例（BubbleUp機能）:**
- 異常領域のイベントの98%で `availability_zone` が `us-east-1a`
- 基準領域のイベントでは17%のみ
- → クラウドプロバイダーのAZ全体のネットワーク問題が判明

---

## AIOpsの限界

### AIが苦手なこと

**異常検出の課題:**
- ウィンドウの選択が困難（どこを「異常」と判断するか）
- システムの挙動が頻繁に変わる環境では誤検知が多発
- 枠が小さすぎる → 多くの正常な動作が異常と認識される
- 枠が大きすぎる → 異常が正常な動作と誤認される

**革新的な環境での問題:**
- 新機能のデプロイ → パフォーマンス変化は異常だが正常
- バグ修正 → パフォーマンス変化は異常だが正常
- 最適化導入 → パフォーマンス変化は異常だが正常

### 人間と機械知能の融合

オブザーバビリティとコア分析ループの自動化は、両者の長所を引き出します:

| 担当 | 得意なこと | 役割 |
|------|----------|------|
| **コンピューター** | 膨大なデータの処理・パターン検出 | 数値計算、スパイク検出 |
| **人間** | 認知的な文脈の付加・価値判断 | パターンの意味づけ、重要なシグナルの選別 |

**重要:** どんなコンピューターでも数字を計算してスパイクを検出できますが、そのスパイクに意味を見いだせるのは人間だけです。それは良いことなのか、悪いことなのか、意図的なものなのか、そうでないのか。今日のテクノロジーで、AIOpsはこれらの価値判断を確実には行えません。

---

## オブザーバビリティとモニタリングの使い分け

### モニタリングが適した場所

| 要素 | 説明 |
|------|------|
| **対象** | システムレベルの関心事（インフラストラクチャ、ランタイム） |
| **特性** | 変更頻度が低く、予測可能 |
| **目的** | 既知の障害状態の検出（既知の未知） |
| **評価視点** | システム自体の健全性 |
| **ユースケース** | - CPU/メモリ/ディスク使用率<br>- ネットワークトラフィック<br>- サービス稼働状態<br>- キャパシティ計画 |

**適しているチーム:**
- IaaSプロバイダー
- ベアメタルシステムを運用
- 自社でインフラストラクチャを管理

### オブザーバビリティが適した場所

| 要素 | 説明 |
|------|------|
| **対象** | アプリケーションレベルの関心事（ビジネスロジック） |
| **特性** | 変更頻度が高く、予測不可能 |
| **目的** | 未知の障害モードの発見（未知の未知） |
| **評価視点** | ビジネス上の顧客体験 |
| **ユースケース** | - ユーザーリクエストの追跡<br>- 個別リクエストのパフォーマンス<br>- 機能フラグの影響分析<br>- エンドツーエンドのトレース |

**適しているチーム:**
- SaaSアプリケーション開発
- マイクロサービスアーキテクチャ
- 継続的デリバリーを実践
- PaaS/サーバーレスを活用

### 判断基準テーブル

| 状況 | 推奨アプローチ |
|------|--------------|
| 変更が予測可能 | モニタリング |
| 変更が予測不可能 | オブザーバビリティ |
| 既知の障害モードを検出 | モニタリング |
| 未知の障害モードを発見 | オブザーバビリティ |
| インフラストラクチャがビジネスの差別化要因 | モニタリング重視 |
| ソフトウェアがビジネスの差別化要因 | オブザーバビリティ重視 |
| 少数の静的なホスト | モニタリング |
| 多数の動的なコンテナ/ファンクション | オブザーバビリティ |
| 顧客体験を重視 | オブザーバビリティ |
| システム稼働を重視 | モニタリング |

### システム vs ソフトウェアの比較

| 要因 | システム | ソフトウェア |
|------|---------|-------------|
| **変更頻度** | パッケージの更新（月次） | リポジトリへのコミット（日次） |
| **予測可能性** | 高い（安定している） | 低い（多数の新機能） |
| **ビジネス上の価値** | 低い（コストセンター） | 高い（売上の源泉） |
| **ユーザー数** | 少ない（社内のチーム） | 多い（ビジネス上の顧客） |
| **主な関心事** | システムやサービスは健全か | 各リクエストがタイムリーかつ確実に実行されるか |
| **評価視点** | そのシステム自体 | ビジネス上の顧客 |
| **理解する方法** | **モニタリング** | **オブザーバビリティ** |

### 例外: 無視できないインフラストラクチャメトリクス

ソフトウェアパフォーマンスに直接影響を与える高次のインフラストラクチャメトリクスは、オブザーバビリティのアプローチに含めるべきです:

- **CPU使用率** - 物理的な性能限界の早期警告
- **メモリ使用量** - メモリリークの検出
- **ディスク使用状況** - ストレージ枯渇の予防

これらはコードによって引き起こされる問題の早期警告シグナルになります。

---

## DevOps・SRE・クラウドネイティブとの関連

### クラウドネイティブの定義

クラウドネイティブ技術は、**レジリエントで**、**管理可能で**、**オブザーバビリティを備えた** 疎結合なシステムを可能にします。堅牢な自動化と組み合わせることで、エンジニアは **最小限の労力で、インパクトのある変更を頻繁かつ予測可能に行える** ようになります。

### 新たな管理課題

クラウドネイティブシステムがもたらす課題:

- **コンポーネント間の相互依存** - 認識の複雑さの増大
- **一時的な状態** - コンテナ再起動後に状態が失われる
- **バージョン互換性** - 別々にリリースされたコンポーネント間の問題
- **イミュータブルインフラ** - sshでホストに入ることが困難

**解決策:** 分散トレースのようなツールで、システム内部から問題を検出し理解する。

### DevOpsとSREの強化

オブザーバビリティは以下のプラクティスを強化します:

| プラクティス | オブザーバビリティの役割 |
|------------|----------------------|
| **カオスエンジニアリング** | システムの定常状態を理解し、実験による逸脱を検出 |
| **機能フラグ** | フラグの状態の組み合わせがユーザーごとに与える影響を把握 |
| **漸進的リリース** | カナリアデプロイ時にリリースを止めるタイミングを判断 |
| **インシデント分析** | 障害時の技術システムの状態と人間の運用担当者の認識を記録 |
| **継続的検証** | テスト時の予想される動作と実際の動作の逸脱を説明 |

### 社会技術的な変革

クラウドネイティブへのシフトは、新しいテクノロジーの採用だけでなく、人々の働き方を変える必要があります:

- 手作業による苦労（トイル）の削減
- フィードバックループの短縮
- より良い価値を、より早く、より安全に、そしてより幸せに提供

オブザーバビリティは、DevOps、SRE、クラウドネイティブプラクティスの **結果であり、不可欠な要素** です。

---

## まとめ

オブザーバビリティは、現代のソフトウェアシステムを理解するための基本的な能力です:

1. **構造化イベント** - オブザーバビリティの基本構成要素
2. **高いカーディナリティと高いディメンション** - 干し草の山から針を見つける能力
3. **第一原理からのデバッグ** - システムの深い知識なしに問題を発見
4. **コア分析ループ** - 仮説駆動型の体系的な調査
5. **人間と機械知能の融合** - それぞれの長所を活かした協働

オブザーバビリティとモニタリングは対立するものではなく、補完的です。システムレベルの関心事にはモニタリング、アプリケーションレベルの関心事にはオブザーバビリティを活用し、現代のソフトウェアシステムを効果的に管理しましょう。
