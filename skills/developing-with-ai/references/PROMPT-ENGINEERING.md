# プロンプトエンジニアリング実践ガイド

プロンプトエンジニアリングは、AI支援開発における中核スキルであり、開発者の意図とAIの実行を結ぶコミュニケーション手法です。

---

## プロンプトの構造

### 良いプロンプトの4要素

効果的なプロンプトは以下の要素で構成されます：

| 要素 | 説明 | 例 |
|------|------|-----|
| **タスク記述** | 明確で具体的な目的の記述 | "JavaScriptでメールアドレスを検証する関数を作成" |
| **コンテキスト** | 実装環境・目的・制約の提供 | "Reactアプリのユーザー登録フォームで使用" |
| **制約** | 技術的・スタイル的・運用上の要件 | "外部ライブラリ不使用、空文字列・null値処理必須" |
| **出力フォーマット** | 期待される成果物の形式 | "JSDoc付き、パラメータ名明示、2-3のテスト例を含む" |

### Bad/Good 対比例

```markdown
# ❌ 悪い例（曖昧）
"ソート関数を書いて"

# ✅ 良い例（明確）
"TypeScriptで、product オブジェクトの配列を price プロパティで昇順ソートする関数を作成してください"
```

```markdown
# ❌ 悪い例（情報過多）
"我々のeコマースプラットフォームは2019年に構築され、マイクロサービスアーキテクチャを採用し、AWSにデプロイされ、15ヶ国にサービス提供し、50人の開発者がいます。Node.jsアプリケーションでユーザー認証機能を作成してください"

# ✅ 良い例（関連情報のみ）
"マイクロサービスアーキテクチャでJWTトークンを検証するNode.js関数を作成してください"
```

---

## アンチパターン

| パターン | 問題 | 改善方法 |
|---------|------|---------|
| **曖昧なタスク記述** | AIが推測で要件を補完し、期待外れの結果を生成 | 言語、データ型、処理内容、ソート基準などを明示 |
| **情報過多** | 主目的が不明確になり、AIが無関係な情報に焦点 | タスクに直接関連する情報のみに絞る（例：開発年やチーム規模は不要） |
| **矛盾する要件** | AIが不適切な妥協案を生成 | "軽量でミニマル" と "包括的エラーハンドリング・詳細ログ" など矛盾する要求を避ける |
| **実装詳細の不足** | AIが標準的な実装に頼り、プロジェクト固有の要件を無視 | 統合先システム、コーディング規約、エッジケースを明示 |

---

## プロンプトテンプレート集

### 1. コード生成テンプレート

```
「[言語]で[コンポーネントタイプ]を作成してください。
[主要機能]を実装し、[特定の機能]を含め、[エッジケース]を処理する必要があります。
[既存システム]と統合し、[コーディング規約]に従ってください」

【例】
「Python の WeatherService クラスを作成してください。
外部APIから天気データを取得し、30分間レスポンスをキャッシュし、ネットワーク障害を適切に処理します。
現在の天気と5日間予報のメソッドを公開し、PEP 8 スタイルガイドラインに従ってください」
```

### 2. コード説明テンプレート

```
「この[言語]コードの動作を説明してください。[特定の側面]と[主要メカニズム]に焦点を当て、
[複雑な部分]を分解し、[パターン/最適化/懸念事項]をハイライトしてください」

【例】
「このPythonコードの動作を説明してください。リスト内包表記とイテレーションの使用に焦点を当て、
偶数をフィルタリングするロジックを分解し、パフォーマンス最適化や可読性の懸念をハイライトしてください」
```

### 3. デバッグテンプレート

```
「この[言語]コードで[エラー説明]を修正してください。
現在の動作は[観察]ですが、期待される動作は[期待]です。
エラーメッセージ：[正確なエラーテキスト]」

【注意】
開発セッション中であれば、エラーメッセージをそのまま貼り付けるだけで十分な場合が多い。
AIツールが既にコードコンテキストを持っている場合は、エラーメッセージだけで関連付けが可能。
```

### 4. リファクタリングテンプレート

```
「この[言語]コードを[改善目標]によって改善してください。
[主要な懸念事項]に焦点を当て、[要件]を維持しながら、[パターン/テクニック]の適用を検討してください」

【注意】
リファクタリングは主観的で多様なアプローチが存在するため、
改善対象の要素を明確に指定し、進め方の提案を含めることでAIツールの効果的な作業を支援する。
```

### 5. テスト生成テンプレート

```
「この[言語]の[機能/クラス]に対するユニットテストを作成してください。
[テストフレームワーク]を使用し、[カバレッジ要件]を満たし、
[エッジケース]をテストしてください」

【例】
「この TypeScript の UserService クラスに対する Jest のユニットテストを作成してください。
全パブリックメソッドをカバーし、認証失敗、ネットワークタイムアウト、無効なユーザーIDのエッジケースをテストしてください」
```

### 6. ドキュメント生成テンプレート

```
「この[言語]コードに対して[ドキュメントタイプ]を作成してください。
[ドキュメント標準]に従い、[必須セクション]を含め、[対象読者]のニーズに焦点を当ててください」

【注意】
AIツールはドキュメント生成時に冗長になりがちであるため、
ドキュメント標準と対象読者を明示することで、焦点を絞った効果的な成果物を得られる。
```

---

## 高度なテクニック

### 1. マルチパートプロンプティング（段階的アプローチ）

複雑なタスクを論理的な単位に分解し、段階的に実装する手法です。

```markdown
# 初期計画プロンプト
「[複雑な機能]を開発する必要があります。これを管理可能な部分に分解しましょう：
1. まず、全体的なアーキテクチャとアプローチを議論します
2. 次に、各コンポーネントを順番に実装します
3. 最後に、コンポーネントを統合します

パート1から始めましょう：[具体的な最初のタスク]」

# 後続プロンプト（コンテキスト保持）
「前回の議論で[前回の作業の簡単な要約]を行いました。次のパートに移りましょう：

[以前のパートからの決定事項/コードを参照した現在のタスクの詳細]

確立したアプローチとの一貫性を保ちながら、[特定のコンポーネント/機能]を実装してください」
```

**ポイント**：
- 各ステップで集中的な注意を得られる
- 以前の決定事項に基づく一貫した実装
- 複雑さを管理可能な単位に分割

### 2. コンテキスト要約テクニック

長時間のセッションでコンテキストを維持するための手法です。

```markdown
「続ける前に、これまでの進捗を要約させてください：
- [コンポーネントA]を[主要な特性]で実装しました
- [特定の要件]を処理するために[アーキテクチャパターン]を設計しました
- [理由]により[技術/アプローチ]を使用することに決定しました

それでは、[次のタスク]に進みましょう」
```

**使用タイミング**：
- トークン制限に近づいたとき
- 開発フェーズを切り替えるとき
- 複雑さの蓄積が関係性を不明確にしているとき

### 3. Chain of Thought（段階的推論）

AIに明示的な推論プロセスを要求し、より思慮深い解決策を得る手法です。

```markdown
「[問題]を解決する必要があります。ステップバイステップで考えてください：

1. まず、[問題の最初の側面]を分析します
2. 次に、[第二の側面または決定ポイント]を検討します
3. その後、[追加の検討事項または代替案]を評価します
4. 最後に、前のステップに基づいて[解決策]を開発します

最終的な解決策を提供する前に、各ステップでの推論を説明してください」
```

**効果**：
- AIが複数の側面を検討することを強制
- 自然な検証チェックポイントを作成（推論が誤っていれば介入可能）
- 単なるコード生成ではなく、設計決定のドキュメントを提供
- より徹底的な解決策（元の要件で説明されていないエッジケースへの対処）

### 4. ロールベースプロンプティング（システムプロンプト設定）

特定のペルソナとコンテキストを設定し、一貫した応答を得る手法です。

```markdown
# システムプロンプト例
「あなたは[専門的な役割]であり、[関連技術/ドメイン]の専門知識を持っています。

プロジェクトコンテキスト：
- 技術スタック：[言語、フレームワーク、ライブラリ]
- コーディング規約：[スタイルガイドライン、従うべきパターン]
- 制約：[パフォーマンス要件、互換性ニーズ]

コード生成時：
- 常に[特定の要件1]
- 必ず[特定の要件2]
- 決して[避けるべきこと]はしない
- [特定のパターンまたはアプローチ]に従う

あなたの応答は[品質属性]を優先し、[期待されるコンポーネント]を含める必要があります」
```

**用途**：
- プロジェクト固有の制約を確立（特定のライブラリ、アーキテクチャパターン、パフォーマンス要件、コンプライアンス標準など）
- チーム環境で特に効果的（共有システムプロンプトとペルソナ定義がチーム実践に沿ったAI動作を作成）

---

## 実践ワークフロー

### 1. 反復改善プロセス（3ステップサイクル）

```
1. プロンプト作成
   ↓ 明確で焦点を絞ったプロンプトから開始
2. 応答評価
   ↓ 正確性、完全性、品質、エッジケース処理を評価
3. プロンプト改善
   ↓ 評価に基づき、精度向上のための具体的ガイダンスで改善
   ↓（1に戻る）
```

**評価基準**：
- **正確性**: ソリューションは意図通りに動作するか？
- **完全性**: すべての要件に対応しているか？
- **品質**: コードは適切に構造化され、最適化されているか？
- **エッジケース**: 重要なエッジケースが処理されているか？

### 2. プログレッシブコンテキスト構築（3フェーズ）

複雑なタスクを段階的にコンテキストを蓄積しながら進める手法です。

#### Foundation（基盤フェーズ）
```
「Reactでeコマースアプリのショッピングカート機能を構築しています」
```
- 広範なプロジェクト状況を確立
- 技術エコシステムと主要目標を定義
- 実装の詳細には踏み込まない

#### Expansion（拡張フェーズ）
```
「Cartコンポーネントが必要です。アイテム、数量、価格を表示し、数量を更新できるようにしてください」
```
- 技術仕様と機能要件を導入
- 抽象的な概念を具体的な開発目標に変換

#### Refinement（洗練フェーズ）
```
「Cartコンポーネントで、アイテム数量がゼロを下回らないようにしてください」
```
- 最適化、エッジケース、高度な考慮事項に焦点
- 基本機能を本番環境対応コードに昇格

### 3. 階層的コンテキスト管理

複数レベルのコンテキストを同時に維持する手法です。

```markdown
# プロジェクトコンテキスト：
<!-- プロジェクトの技術状況と制約を説明 -->

# モジュールコンテキスト：[モジュール名]
<!-- モジュールの責任と境界を説明 -->

# 関数コンテキスト：[関数名]
<!-- 関数の責任とシグネチャ -->
```

**コンテキストフィルタリング手法**：
- **優先度ベース**: 現在のタスクに基づいて優先順位をつけ、低優先度のものを削除
- **時間ベース**: 最近の議論を強調しつつ、重要な履歴コンテキストへのアクセスを維持
- **スコープベース**: 高レベル情報を保持し、現在の作業に無関係な詳細を削除

---

## ドメイン別プロンプト戦略

### フロントエンド開発

```markdown
# アーティファクト駆動型
「このワイヤーフレーム [画像添付] に基づいてナビゲーションコンポーネントを実装してください。
[URL] の既存デザインシステムと統合し、
スタイルガイドで定義されたレスポンシブブレークポイントを処理し、
チームドキュメントで概説されたアクセシビリティ標準を維持してください」

# プログレッシブエンハンスメント
ステップ1: 基本レイアウトと構造
ステップ2: インタラクティブ機能追加
ステップ3: アニメーションとレスポンシブ対応
```

### バックエンド開発

```markdown
# 仕様ファースト
「このOpenAPI仕様 [ファイル添付] に基づいて [API] を生成してください。
ERD [図添付] で定義されたデータベーススキーマを使用し、
システムアーキテクチャ [図添付] で示された既存の [認証システム] と統合してください」

# パフォーマンス重視
「リクエストボリューム [数値]、レイテンシ期待値 [数値]、同時実行要件 [数値] を考慮して
[エンドポイント] を実装してください。
既存の [参照実装] のパターンに従ってください」
```

### データベース

```markdown
# データモデリング
「ERD [図] に基づいてPostgreSQLスキーマを作成してください。
正規化レベル [3NF/BCNF]、インデックス戦略 [説明]、
パーティショニング要件 [説明] を含めてください」
```

### インフラ

```markdown
# IaC（Infrastructure as Code）
「Terraform/Pulumi/CloudFormationで [リソース] をプロビジョニングしてください。
環境分離 [dev/staging/prod]、セキュリティグループ [要件]、
コスト最適化 [制約] を考慮してください」
```

### セキュリティ

```markdown
# セキュリティファースト
「OWASP Top 10 対策を含む認証機能を実装してください。
具体的に、SQLインジェクション、XSS、CSRF、ブルートフォース攻撃への対策を含めてください。
[コンプライアンス標準: GDPR/HIPAA/PCI-DSS] に準拠してください」
```

---

## 構造化フレームワーク

### AUTOMAT フレームワーク

```markdown
# A - Act as（役割設定）
「[特定の開発者役割または専門レベル]として振る舞ってください
（例：認証の専門知識を持つシニアバックエンド開発者）」

# U - User Persona & Audience（ユーザー・対象読者）
「[コード/システムの対象ユーザー]
（例：金融データにアクセスするモバイルアプリユーザー）」

# T - Targeted Action（対象アクション）
「[特定の開発タスクまたは目標]
（例：JWTトークンによるユーザー認証を処理するセキュアなログインエンドポイントを実装）」

# O - Output Definition（出力定義）
「[期待される形式と内容]
（例：すべてのルート、ミドルウェア構成、エラーハンドリングロジック、ユニットテストを提供）」

# M - Mode/Tonality/Style（モード・トーン・スタイル）
「[コーディングスタイルと規約]
（例：async/awaitパターンを使用、説明的な変数名、チーム標準に従ったドキュメント）」

# A - Atypical Cases（非定型ケース）
「[処理が必要なエッジケース]
（例：ブルートフォース試行検出とアカウントロックアウト手順を処理）」

# T - Topic Whitelisting（トピックホワイトリスト）
「[関連技術と制約]
（例：Express.js、MongoDB、JWT for tokens、bcrypt for password comparison を使用）」
```

### CO-STAR フレームワーク

```markdown
# C - Context（コンテキスト）
「[プロジェクト背景と既存コードベースの詳細]
（例：セキュリティアップグレードが必要なExpress.jsバックエンドを持つ金融アプリ）」

# O - Objective（目的）
「[特定の開発目標または機能]
（例：JWTによるセキュアなログインエンドポイントを実装）」

# S - Style & Tone（スタイル・トーン）
「[コーディング規約とドキュメントアプローチ]
（例：Async/await、説明的な名前、JSDocコメント）」

# T - Technical Constraints（技術的制約）
「[言語バージョン、フレームワーク、ライブラリ]
（例：Express.js、MongoDB、JWT、bcrypt、OWASPガイドライン）」

# A - Audience（対象読者）
「[チームメンバーまたはエンドユーザー]
（例：金融データにアクセスするモバイルアプリユーザー）」

# R - Response Format（応答形式）
「[期待されるコード構造とドキュメント]
（例：ミドルウェア、エラーハンドリング、テストを含むExpressルート）」
```

**使い分け**：
- **AUTOMAT**: 徹底的な実装詳細とエッジケース処理を重視。役割固有の視点から開発プロセスをガイド
- **CO-STAR**: 既存システムとチームダイナミクスの深いコンテキスト理解が必要な状況に最適。プロジェクト背景と対象読者を強調
- **組み合わせ**: 複雑な課題に対しては両フレームワークの要素を組み合わせることで最大の効果を発揮

---

## プロンプト効果性の測定

### 測定指標

| 指標 | 説明 | 目標 |
|------|------|------|
| **Time to Solution** | 最初のプロンプトから満足できる解決策までの時間 | 短縮 |
| **Iteration Count** | 受容可能な成果を得るまでのプロンプト改善回数 | 低減（通常6回未満） |
| **Solution Accuracy** | AI生成コードがデプロイ前に必要とする修正の度合い | 80/100以上 |
| **Code Quality** | 循環的複雑度、アルゴリズム効率、linting効率、ドキュメント品質 | チームレベルで定義 |

### ダッシュボード例

プルリクエストデータから以下を追跡：
- プロンプト効果性トレンド（チーム/個人）
- 反復回数の分布
- コード品質スコアの推移
- タスクタイプ別のTime to Solution

**注意**: これらの指標はプロンプトエンジニアリングを測定可能なエンジニアリング実践に変換し、直感的な技術から体系的なスキルへと進化させます。
