# サードパーティーライブラリのトレードオフ

## 概要

サードパーティーライブラリをインポートした瞬間、そのコードは自分たちのコードになる。エンドユーザーはライブラリの選択など知らないし、障害が起きれば責任を問うのは自分たちのチームだ。

ライブラリ選定には「動くかどうか」だけでなく、**デフォルト値・並列実行モデル・テスト容易性・依存関係・メンテナンスコスト**という5つの視点が必要となる。

---

## トレードオフ分析

### デフォルト値と「設定より規約」

ライブラリの「設定より規約」は迅速なプロトタイピングを可能にするが、本番環境では牙をむく。

| 観点 | デフォルト設定のまま | 明示的な設定 |
|------|-------------------|-----------:|
| 開発速度 | ★★★★★（即使える） | ★★★（設定コストあり） |
| 本番適合性 | ★★（ユースケース依存） | ★★★★★ |
| タイムアウト管理 | 不定または無限 | SLAに合わせて調整 |
| デバッグ容易性 | 低（暗黙的） | 高（明示的） |

**判断基準テーブル:**

| シナリオ | 推奨アプローチ |
|---------|-------------|
| プロトタイピング・PoC | デフォルト設定で素早く試す |
| 本番サービス | すべての重要設定を明示的に上書き |
| SLAが厳しいサービス | タイムアウト・リトライ・接続数を必ず設定 |
| マイクロサービス | カスケード障害防止のため短いタイムアウトを設定 |

---

### 並列実行モデルとスケーラビリティ

ライブラリの内部実行モデルがアプリケーションの処理モデルと合わない場合、深刻なパフォーマンス問題が起きる。

| 実行モデル | 特徴 | 適合する状況 |
|----------|------|-----------|
| ブロッキング（同期） | 呼び出し元スレッドが処理完了まで待つ | 単純な逐次処理、スループット要件が低い |
| ノンブロッキング（非同期） | 処理を委譲し即返る | 高トラフィック、イベントループアーキテクチャ |

**ライブラリ選択の判断基準:**

| アプリのモデル | ライブラリAPIの好ましい形 | 注意点 |
|-------------|----------------------|------|
| ブロッキング（同期）フロー | 同期・非同期どちらでも利用可 | 非同期ライブラリは後の移行を容易にする |
| ノンブロッキング（非同期）フロー | 非同期API必須 | ブロッキングライブラリの組み込みはスレッドをブロックし性能劣化を招く |

**分散環境での注意:**

| 観点 | スケールできないライブラリ | スケールできるライブラリ |
|------|----------------------|---------------------|
| グローバル状態 | あり（全ノードで競合） | なし or パーティション分割 |
| 分散ロック | 性能ボトルネックになる | 必要最小限 |
| ノード追加効果 | 低い（競合が増えるだけ） | 線形スケール |

> **重要**: 1ノードでの検証では分散スケーラビリティの問題は発現しない。高トラフィック時（繁忙期など）に初めて問題が露見する。

---

### テスト容易性

良いライブラリはテストを支援する。テストしにくいライブラリは将来のリスクを内包している。

| テスト容易性の要素 | 高評価の兆候 | 低評価の危険サイン |
|-----------------|------------|-----------------|
| テストライブラリの提供 | 専用のテストヘルパーあり | テストライブラリなし |
| 内部コンポーネントの注入 | Fake/Mockを注入できる | 内部実装が完全に隠蔽 |
| 時間・状態の制御 | テスト用の時計・状態を差し替え可能 | `Thread.sleep()`が必要になる |
| 統合テストの容易性 | テスト用の組み込み起動手段あり | 実環境なしにテスト不可 |

---

### 依存関係管理

| 問題 | 発生状況 | 対処法 |
|------|---------|-------|
| バージョン衝突 | 複数ライブラリが同じライブラリの異なるバージョンに依存 | セマンティックバージョニングの確認、シェーディング利用のライブラリを選ぶ |
| 推移的依存の汚染 | ライブラリの内部依存が自分のコードから見えてしまう | シェーディング済みライブラリを選択 |
| デプロイサイズの肥大化 | 大量の依存関係でデプロイパッケージが巨大化 | 依存数の少ないライブラリを選択 |

**ライブラリ vs フレームワーク:**

| 比較軸 | ライブラリ | フレームワーク |
|-------|---------|-------------|
| コード侵食度 | 低（必要箇所のみ） | 高（全体に影響） |
| 置き換えコスト | 低（抽象化で隠蔽可） | 非常に高い |
| 調査・評価の厳密さ | 標準 | より徹底的に |

---

## よくある誤り

1. **デフォルトタイムアウトを本番で使う**: タイムアウト無限や10秒デフォルトは、SLA違反やカスケード障害の温床になる

2. **ブロッキングライブラリをノンブロッキングフローで呼ぶ**: イベントループの処理スレッドをブロックし、アプリ全体の性能を破壊する

3. **1ノードのみでテストしてOKとする**: 分散スケーラビリティの問題は複数ノード環境でしか現れない

4. **推移的依存のコードを直接使う**: ライブラリが内部依存を変更した際に、自分のコードが突然壊れる

5. **ライブラリのテスト容易性を評価せずに採用する**: 後から「テストできない」と気づいても、ライブラリ変更のコストは甚大

6. **セキュリティアップデートを後回しにする**: 脆弱性が公開されてからの時間は攻撃者の機会になる

---

## 実践ガイドライン

### ライブラリ評価チェックリスト

- **設定**: 重要なパラメーター（タイムアウト、接続数、リトライ）を明示的に設定できるか
- **実行モデル**: アプリの処理モデル（同期/非同期）と一致するAPIを提供しているか
- **スケーラビリティ**: 分散環境（複数ノード）で安全に動作するよう設計されているか
- **テスト支援**: テスト用ライブラリ、Fake/Mock注入の仕組みを提供しているか
- **依存関係**: 推移的依存の数は適切か、シェーディングを利用しているか
- **安定性・活発さ**: 活発にメンテナンスされているか、ドキュメントは整備されているか
- **ライセンス**: 商用利用・コードの扱いに問題はないか
- **セキュリティ**: セキュリティアップデートの頻度と追跡可能性

### 抽象化によるベンダーロックイン軽減

```
# 推奨パターン
呼び出しコード → [自作の抽象化レイヤー] → サードパーティーライブラリ

# アンチパターン
呼び出しコード → サードパーティーライブラリ（コード全体に散在）
```

将来の置き換えを見据えて、ライブラリへの依存は抽象化レイヤーの背後に隠す。フレームワークは侵食性が高いため、より慎重に選択する。

---

## まとめ

- **使うライブラリは自分のコード**: デフォルト設定を盲信せず、本番環境に合わせて設定を調整する
- **並列実行モデルの整合性**: ライブラリの実行モデルがアプリのアーキテクチャと合致するか確認する
- **テスト容易性は選定基準**: 仮説を検証できないライブラリは、潜在リスクを抱えたまま使い続けることになる
- **分散スケーラビリティは事前確認**: 1ノードでは問題が見えない。高負荷時に初めて露見するリスクを事前に排除する
- **依存関係は最小に**: ライブラリが持ち込む依存が増えるほど、バージョン衝突とセキュリティリスクが高まる
