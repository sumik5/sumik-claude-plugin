# APIのわかりやすさ vs メンテナンスコスト

## 概要

APIの設計において、依存ライブラリの設定を「そのまま公開する」か「隠蔽して独自インターフェースを提供する」かの選択は、ユーザー体験とメンテナンスコストに根本的な影響を与える。どちらの選択も一長一短があり、用途・変更頻度・ユーザー層に応じて使い分けが必要。

---

## トレードオフ分析

### パターン比較：設定公開 vs 設定隠蔽

```
【設定公開パターン（透過的伝播）】
ユーザー → [自ライブラリ] → [依存ライブラリの設定をそのまま渡す] → 依存ライブラリ

【設定隠蔽パターン（抽象ラッパー）】
ユーザー → [自ライブラリの独自設定] → [内部で変換] → 依存ライブラリ
```

### 操作別コスト比較テーブル

| 操作 | 設定公開パターン | 設定隠蔽パターン |
|------|----------------|----------------|
| **新規設定の追加** | 自ライブラリ変更不要。ユーザーは依存ライブラリの設定変更が必要 | 自ライブラリに設定を追加する変更が必要。ユーザーへの影響なし |
| **設定の非推奨化** | 依存ライブラリのメカニズムをそのまま利用可能 | 内部で古い設定を新しい設定に変換するロジックが必要 |
| **設定の削除** | 自ライブラリの変更は不要だが、ユーザー側のコードに影響 | 内部処理を変更しユーザーインターフェースは維持できる |
| **依存ライブラリの差し替え** | ユーザーの設定コードがすべて書き直しになる（リスク大） | ユーザーは気づかず差し替え可能（透明性が高い） |
| **設定の柔軟性** | 依存ライブラリのすべての機能に即座にアクセス可能 | 自ライブラリが未公開の設定にはアクセス不可 |
| **ドキュメントコスト** | 依存ライブラリのドキュメントを参照させるだけでよい | 独自設定の完全なドキュメントが必要 |

### 選択判断基準

| 条件 | 推奨パターン | 理由 |
|------|------------|------|
| 依存ライブラリの設定が頻繁に変わる | **設定隠蔽** | ユーザーへの影響を遮断できる |
| ユーザーが依存ライブラリの専門家 | **設定公開** | 既知の設定をそのまま使える利便性が高い |
| 単発・バッチ処理系のAPI | **設定公開** | 設定の透過性が重要な場面が多い |
| 長期稼働・ストリーミング系のAPI | **設定隠蔽** | 安定したインターフェースが重要 |
| 依存ライブラリを将来差し替える可能性がある | **設定隠蔽** | インターフェースの安定性を保てる |
| プロトタイプ・小規模ツール | **設定公開** | 開発速度優先の場面では手間を省ける |

---

## よくある誤り

### 誤り1: 設定削除時のひどい回避策

設定公開パターンで依存ライブラリが設定を削除した場合、以下のような回避策に頼りがちになる：

```
// ❌ やってはいけない例（概念）
// 削除された設定を維持するために「何もしない」メソッドを公開し続ける
setDeprecatedOption(value) {
    // 何もしない（ただし公開APIとして残り続ける）
}
```

**問題点**: UXが悪化し、ユーザーは設定を渡しているつもりが実際には無視されている状態になる。

### 誤り2: すべてを公開・すべてを隠蔽

- **全公開の罠**: 依存ライブラリのすべての設定をそのまま公開すると、依存ライブラリのバージョンアップのたびにユーザーへの影響が生まれる
- **全隠蔽の罠**: すべての設定を隠蔽すると、ユーザーがわずかな調整すらできなくなりカスタマイズ性が失われる

### 誤り3: ハイラムの法則を無視した設計

> **ハイラムの法則**: APIのすべての観察可能な動作は、ユーザーが依存する可能性がある。

「内部実装だから変えていい」と思っていた挙動を、多くのユーザーが依存していることがある。API設計時には、意図していない動作にもユーザーが依存することを想定する必要がある。

---

## 実践ガイドライン

### 設計フェーズでの意思決定フロー

```
① 依存ライブラリの安定性を評価
   ├─ 安定している → 設定公開を検討
   └─ 変化が激しい → 設定隠蔽を強く推奨

② ユーザーの技術レベルを評価
   ├─ 依存ライブラリを熟知 → 設定公開でOK
   └─ 自ライブラリの抽象レベルで使いたい → 設定隠蔽

③ 将来の依存ライブラリ変更可能性を評価
   ├─ 差し替え予定あり → 設定隠蔽必須
   └─ 変更なし → どちらでも可

④ メンテナンスコスト許容度を評価
   ├─ コスト削減優先 → 設定公開
   └─ UX安定優先 → 設定隠蔽
```

### 設定隠蔽パターンのコスト削減テクニック

| テクニック | 効果 |
|-----------|------|
| 設定の遅延公開（プレリリース版） | ユーザーからのフィードバックを得てから安定APIに昇格させる |
| デフォルト値の充実 | ほとんどのユーザーはデフォルトで満足するようにし、公開設定数を最小化 |
| エスケープハッチの提供 | 高度なユーザー向けに依存ライブラリへの直接アクセス手段を残す |
| 段階的移行サポート | 設定変更時に旧設定→新設定の変換レイヤーを一定期間維持する |

### 互換性管理の基本原則

1. **削除より非推奨化を先行させる**: いきなり削除せず `@Deprecated` 等で告知期間を設ける
2. **変更の影響範囲を事前に測定**: どのユーザーが影響を受けるかを把握してから変更する
3. **追加は安全・削除は危険**: 設定の追加は基本的に後方互換性を保つが、削除は必ず破壊的変更になる

---

## まとめ

| 視点 | 設定公開 | 設定隠蔽 |
|------|---------|---------|
| ユーザー体験 | 依存ライブラリ変更の影響を受ける | 安定したインターフェース |
| 実装コスト | 低い（依存ライブラリに委譲） | 高い（独自設定と変換ロジックが必要） |
| 依存ライブラリ差し替え | ユーザーへの影響大 | 透明に差し替え可能 |
| カスタマイズ性 | 依存ライブラリの全機能に直接アクセス | 公開された範囲内のみ |
| 適した場面 | バッチ処理、依存ライブラリが安定 | 長期稼働、依存ライブラリが変化する |

**結論**: 「どちらが正しい」ではなく、APIの用途・安定性要件・ユーザー層に応じて使い分けること。技術的な選択は必ずユーザー体験に波及する。
