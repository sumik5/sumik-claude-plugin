# 分散システムにおける一貫性と原子性

## 概要

分散システムでは「一貫性のある状態を保つこと」と「耐障害性を確保すること」は本質的に競合する目標だ。単一ノードではトランザクションが原子性を保証するが、Nノードに水平スケールすると前提が崩れる。リトライによって重複が発生し、重複排除ロジックが非アトミックなままだとレースコンディションが起こり、システムは静かに壊れていく。

分散環境での正しさを設計するには、「何をべき等にするか」「どこで重複排除するか」「アトミック操作とは何か」を明確に定義しなければならない。

## トレードオフ分析

### べき等性設計：デルタ vs フルステート送信

| 観点 | デルタ送信（増分イベント） | フルステート送信（集計済みスナップショット） |
|------|--------------------------|------------------------------------------|
| ペイロードサイズ | 小さい | 大きい（ステートが増えるほど増大） |
| べき等性 | 難しい（リトライで重複カウント） | 実現しやすい（上書き可能） |
| 順序依存性 | 高い（順序が逆転すると不整合） | 低い（最新スナップショットが優先） |
| 適用例 | ログ追記、ストリーム集計 | ショッピングカート、設定同期 |
| 注意点 | コンシューマーが状態を再構築する必要 | パーティション内の順序保証が別途必要 |

### 重複排除ロジック：チェック→保存 vs アトミックUPSERT

| 観点 | 非アトミック（2ステップ実装） | アトミックUPSERT |
|------|------------------------------|-----------------|
| 実装難度 | 簡単 | データベース機能依存 |
| 単一ノード・低負荷 | 実用上問題ない場合も | 常に正しい |
| 複数ノード・高負荷 | レースコンディション必発 | 常に正しい |
| レイテンシー重複リスク | タイムアウト設定次第で重複 | なし |
| ロールバック要否 | 複雑なロールバックが必要 | DB側で自動処理 |

### 重複排除のタイミング：処理前 vs 処理後にIDを記録

| 観点 | 処理前に記録 | 処理後に記録 |
|------|-------------|-------------|
| 重複送信リスク | 低い | 高い（リトライで再送可能） |
| メッセージロストリスク | 高い（処理失敗後もID済みと判定） | 低い |
| at-least-once実現 | 困難 | 自然に実現 |
| 推奨ユースケース | 冪等な処理のみ | 非べき等な処理全般 |

## よくある誤り

### 1. リトライを実装しただけで「耐障害性あり」と判断する

リトライはat-least-once配信を意味する。受け側が非べき等（メール送信、支払い処理など）の場合、重複を引き起こす。リトライを実装するなら、受け側の重複排除が必ずセットで必要だ。

### 2. 単一ノードでテストした重複排除ロジックを、そのまま本番環境に適用する

```
// 危険なパターン（非アトミック）
if (not exists in DB) {
    execute_action()    // ← ここで別ノードが同じチェックを通過する
    save_id_to_DB()
}
```

複数ノード環境では、2つのノードが同時に「存在しない」と判定してしまう。チェックと保存が2つの独立した操作である限り、レースコンディションは避けられない。

### 3. リトライにより順序が逆転することを想定しない

T1のリクエストが失敗してT3でリトライした場合、T2が先に成功している状況では古いスナップショットが新しい状態を上書きする。パーティションキーによる順序保証と、リトライポリシーを組み合わせて設計する必要がある。

### 4. 「分散データベースだから原子性は保証される」と思い込む

UPSERTがアトミックかどうかはデータベースの実装次第だ。使用するデータベースが単一オペレーションとしてUPSERTを提供しているかを事前に確認すること。

## 実践ガイドライン

### べき等設計の優先順位

1. **読み取り操作** — 本質的にべき等。積極的にリトライしてよい
2. **削除操作（ID指定）** — 実質べき等。リトライ可能
3. **フルステート更新** — 適切に設計すればべき等
4. **デルタ生成・副作用操作** — 非べき等。重複排除ロジックが必須

### アトミック重複排除の実装方針

```
// 安全なパターン（アトミックUPSERT）
was_inserted = db.insert_if_not_exists(request_id)
if was_inserted:
    execute_action()
else:
    // 重複。スキップまたはキャッシュ済みレスポンスを返す
```

- `insert_if_not_exists` は1回のDB操作で完結させる（ストアドプロシージャ、`ON CONFLICT DO NOTHING` など）
- メソッドの戻り値で「挿入成功か否か」を判定する
- ビジネスロジック（`execute_action`）は挿入成功時のみ実行する

### CQRSパターンでのべき等設計

書き込みモデル（コマンド側）でイベントを発行し、複数の読み取りモデル（クエリ側）がそれを消費する場合：

- 各コンシューマーは独立した重複排除テーブルを持つ
- イベントIDはプロデューサー側で生成し、全コンシューマーで共有する
- 読み取りモデルごとに「処理済みオフセット」を管理する

### パフォーマンスとのトレードオフ

フルステート送信はべき等性を確保しやすい反面、ペイロードが大きくなりシリアライズ・デシリアライズのコストが増大する。ビジネス要件（重複許容度）に基づいてデルタ/フルステートを選択する。

## まとめ

| ポイント | 内容 |
|---------|------|
| 根本原因 | 分散システムではチェックと保存の間に必ずレースウィンドウが生じる |
| 解決策 | アトミックUPSERT（1オペレーション）で重複排除する |
| べき等設計 | フルステート送信か、デルタ+順序保証を明示的に選択する |
| 覚えておくこと | 単一ノードで動いた重複排除ロジックは複数ノードでは正しく動かない |
