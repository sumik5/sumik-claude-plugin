# バージョンと互換性の管理

## 概要

バージョン管理は「変更の影響範囲をコントロールする」仕組みである。ライブラリ・ネットワークAPI・データストレージの3つの領域でそれぞれ異なる戦略が必要。互換性の種類を正確に理解し、破壊的変更を意図的にコントロールすることが長期的なシステム安定性につながる。

---

## トレードオフ分析

### セマンティックバージョニング（SemVer）の基本

```
バージョン形式: MAJOR.MINOR.PATCH[-プレリリース][+ビルドメタデータ]

例: 2.3.1-beta.1+20231201

変更ルール:
  MAJOR増加 → 破壊的変更（後方互換性なし）
  MINOR増加 → 後方互換性のある機能追加
  PATCH増加 → 後方互換性のあるバグ修正
```

### バージョン変更タイプの判断基準

| 変更内容 | SemVerの影響 | 理由 |
|---------|------------|------|
| 公開APIの削除 | MAJOR | 既存ユーザーのコードが壊れる |
| 公開APIの追加 | MINOR | 既存ユーザーへの影響なし |
| バグ修正（動作変化なし） | PATCH | 既存の期待動作を維持 |
| バグ修正（動作変化あり） | MAJOR | ハイラムの法則：既存挙動に依存しているユーザーがいる |
| セキュリティ修正 | PATCH or MINOR | 緊急性により判断 |
| パフォーマンス改善 | PATCH | 観察可能な動作に変化なし |
| 内部リファクタリング | PATCH | インターフェースに変化なし |

### 互換性の3種類（ライブラリ）

| 互換性の種類 | 定義 | 影響範囲 |
|------------|------|---------|
| **ソース互換性** | 既存コードが再コンパイルできる | 開発者のビルド環境 |
| **バイナリ互換性** | 既存バイナリが再コンパイルなしで動作する | デプロイ済みの成果物 |
| **セマンティック互換性** | 既存の動作・出力が変わらない | ランタイムの振る舞い |

```
ソース互換性あり ≠ バイナリ互換性あり
バイナリ互換性あり ≠ セマンティック互換性あり

最も厳しい要件: セマンティック互換性
最も測定しにくい: セマンティック互換性
```

### 菱形依存問題（Diamond Dependency）

```
【問題のある依存グラフ】
        アプリ
       /     \
    ライブラリA  ライブラリB
       \     /
      共通ライブラリC
      (A は v1.0 を要求、B は v2.0 を要求)

結果: どちらのバージョンをロードするかで競合が発生
```

| 解決アプローチ | 特徴 | リスク |
|--------------|------|-------|
| 最新バージョンを使用 | シンプル | 古いバージョンを必要とするライブラリが壊れる |
| 両バージョンを共存 | 互換性を最大化 | メモリ使用量増加・挙動の不一致 |
| バージョン範囲指定 | 柔軟性がある | 範囲が広すぎると予測不能な問題が発生 |
| モノレポ管理 | 一貫性が高い | 大規模リポジトリ管理コスト |

### ネットワークAPIのバージョン管理：2つの戦略

| 戦略 | 説明 | メリット | デメリット |
|------|------|---------|----------|
| **クライアント制御** | クライアントが具体的なAPIバージョン（例: v2024-01-01）を指定 | クライアントが制御権を持つ。古いバージョンを長く使える | クライアントがバージョンを更新し続ける必要がある |
| **サーバー制御** | メジャーバージョン（v1, v2）のみ指定。マイナー変更はサーバーが後方互換性を保つ | クライアントの更新負担が少ない | サーバー側の後方互換性維持コストが高い |

```
【クライアント制御の例】
GET /api?version=2024-01-15  → 2024-01-15時点のAPIを提供

【サーバー制御の例】
GET /api/v2/resource  → v2の最新挙動（後方互換性を保ちながら進化）
```

---

## よくある誤り

### 誤り1: バグ修正を「安全」と過信する

バグ修正であっても、既存の（バグを含む）動作に依存しているユーザーがいる可能性がある。

> **ハイラムの法則**: APIのすべての観察可能な動作は、ユーザーが依存する可能性がある。

**対策**: バグ修正でも変更ログに明記し、セマンティックバージョンを適切に更新する。

### 誤り2: 0.x.y を「安定」として扱う

SemVer ではメジャーバージョン0は「開発中」を意味し、マイナーバージョンアップでも破壊的変更を行える。ユーザーは0.xを本番利用する際にこの性質を理解する必要がある。

### 誤り3: 破壊的変更なしに「ネーミング」を変える

```
// Before
calculateTotal() → 廃止
// After
computeSum()      → 新設

// ❌ 問題: 古い関数に依存しているユーザーは壊れる
// ✅ 対策: 古い関数を一定期間deprecated扱いで残す
```

### 誤り4: データストレージの即時マイグレーション

ライブ稼働中のシステムで、古いスキーマを削除してから新しいスキーマに移行しようとすると、移行中にシステムが停止する。

---

## 実践ガイドライン

### プレリリースバージョンの活用

| フェーズ | バージョン例 | 目的 |
|---------|------------|------|
| 開発中 | 1.0.0-alpha.1 | 内部テスト・概念検証 |
| ベータ版 | 1.0.0-beta.1 | 外部ユーザーへのフィードバック収集 |
| リリース候補 | 1.0.0-rc.1 | 最終確認・バグ修正のみ |
| 安定版 | 1.0.0 | 本番利用可能 |

**効果**: 安定版リリース前にAPIデザインのフィードバックを得られる。一度安定版を出すと破壊的変更のコストが跳ね上がる。

### 破壊的変更を行う際の手順

```
Phase 1: 新しいAPIを追加（古いAPIはそのまま維持）
Phase 2: 古いAPIを @deprecated 等でマーク・告知
Phase 3: マイグレーションガイドを提供
Phase 4: 十分な移行期間の後、古いAPIを削除
```

### データストレージの段階的マイグレーション

新しいフィールド追加の安全な手順：

```
Step 1: 新フィールドを「オプション」として追加（旧コードも動作可能）
Step 2: 書き込み時：新フィールドに値を書き込む
Step 3: 読み取り時：新フィールドがあれば新値、なければデフォルト値を使用
Step 4: バックフィル：既存レコードに新フィールドを一括設定
Step 5: 新フィールドを「必須」に変更（全レコードに値があることを確認後）
Step 6: 旧フィールドを削除
```

**重要**: 各Stepは独立したデプロイで実施し、問題があればロールバック可能にする。

### バージョン範囲指定のベストプラクティス

| 指定方法 | 例 | 適した場面 |
|---------|-----|----------|
| 完全固定 | `==1.2.3` | 再現性が最重要な場面（本番デプロイ） |
| パッチのみ許容 | `~1.2.0` | バグ修正のみ自動適用したい場面 |
| マイナー以下許容 | `^1.0.0` | 機能追加も自動適用したい場面（SemVer信頼時） |
| 広範囲 | `>=1.0,<2.0` | 互換性最大化が必要な場面 |

---

## まとめ

| 領域 | 重要な考え方 | 主なリスク |
|------|------------|----------|
| **ライブラリ** | ソース・バイナリ・セマンティック互換性を区別する | 菱形依存・ハイラムの法則 |
| **ネットワークAPI** | クライアント制御 vs サーバー制御の特性を理解する | バージョン爆発・後方互換性コスト |
| **データストレージ** | 段階的マイグレーションで無停止移行を実現する | スキーマ変更によるシステム停止 |

**結論**: バージョン管理は「変更を管理すること」ではなく「変更の影響をコントロールすること」。SemVerは合意形成のための共通言語であり、実際の互換性はコードと運用が保証する。プレリリース版を活用してAPIの設計フィードバックを早期に得ることが、長期的なメンテナンスコストの削減につながる。
