# 日付と時間の処理トレードオフ

## 概要

日時処理の最大の罠は「シンプルに見える」こと。整数の加減算と違い、カレンダー演算は結合法則を満たさず、タイムゾーンの切替でローカル時刻が重複・消滅し、暦法が文化ごとに異なる。適切な概念モデルとライブラリ選択により、年に2時間だけ発生するようなバグを事前に防げる。

日時情報は3層の概念に分かれる。**機械時間**（Instant・Duration・Epoch）は文化依存なしの純粋な時系列、**常用時**（暦法・日付・時刻・時間量）は人間が使う文化依存の表現、**タイムゾーン**はこの2者をマッピングする変換関数だ。

## トレードオフ分析

### 日時型の選択

| 使用場面 | 適切な型 | 使ってはいけない型 | 理由 |
|---------|---------|----------------|------|
| ログ・DBトランザクション記録 | Instant（時点） | LocalDateTime | タイムゾーン情報が失われる |
| 返品期限・誕生日 | LocalDate（日付のみ） | Instant | 時刻・タイムゾーン変換が不要 |
| アラーム・営業時間 | LocalTime（時刻のみ） | Instant | 特定日に依存しない |
| 月次処理・加算操作 | Period（時間量） | Duration | 月・年の長さが可変のため |
| 処理時間・タイムアウト | Duration（期間） | Period | 固定の経過時間が必要 |
| ユーザー入力のタイムスタンプ | 入力形式をそのまま保存 | 即変換後に捨てる | 変換前の情報を保持できる |

### タイムゾーン処理の戦略

| 戦略 | 適用場面 | トレードオフ |
|------|---------|-------------|
| UTCで統一保存 | ログ・内部システム | シンプルだが「未来の予定」には危険 |
| 元のタイムゾーンを保存 | 将来の予定・ユーザー入力 | 安全だがストレージとクエリーが複雑 |
| IANAタイムゾーンID保存 | タイムゾーン情報が必要な場合 | 最も正確だがデータベース設計が複雑 |
| タイムゾーン対応不要 | 単一タイムゾーンの内部システム | 最もシンプルだが後から変更が困難 |

> **UTCだけを保存する落とし穴**: 「東京時間2025年3月9日9:00の予定」をUTCで保存すると、将来タイムゾーンルールが変わった場合に意図した時刻が変わってしまう。未来の予定は元のタイムゾーン情報とセットで保存すること。

### 暦法・スコープの決定

| 判断基準 | グレゴリオ暦のみ | 複数暦法 |
|---------|--------------|---------|
| 対象ユーザー | 一般的なビジネス | 宗教関連・特定地域向け |
| 開発コスト | 低 | 高（テスト境界条件が増大） |
| 変更リスク | 後から追加が困難 | 最初から設計する必要あり |
| 推奨アプローチ | スコープを明示的にドキュメント化 | プロダクトオーナーと確認後に設計 |

## よくある誤り

### 1. UTCオフセットとタイムゾーンの混同

`2021-06-19T14:00:00-04:00` はUTCオフセット情報であり、タイムゾーン情報ではない。同じオフセット `-04:00` でも12月になるとニューヨークは `-05:00`、パラグアイは `-03:00` に変化する。**PST・PDT などの省略形はタイムゾーンではない。**

### 2. カレンダー演算の非結合性

```
(2021/1/31 + 1ヶ月) + 2ヶ月 = 2021/4/28
 2021/1/31 + (1ヶ月 + 2ヶ月) = 2021/4/30
```

計算の括弧の位置で結果が変わる。プロダクトオーナーと「どちらの計算を使うか」を必ず合意し、ドキュメント化すること。

### 3. 計算の不可逆性

`(日付 + 期間) - 期間 ≠ 日付` となる場合がある。1月31日 + 1ヶ月 - 1ヶ月 = 2月28日（元に戻らない）。

### 4. サマータイムの重複・スキップ

フォールバック（夏→冬）では同じローカル時刻が **2回** 発生する。スプリングフォワード（冬→夏）では特定のローカル時刻が **存在しない**。常用時→時点の変換は曖昧になりうる。

### 5. システムタイムゾーン・システム時計への暗黙依存

```
// テスト不可能なコード
String now = DateFormat.getDateInstance().format(new Date());
```

システム時計をハードコードすると特定時点のテストが不可能になる。Clockインターフェースを依存性注入で渡し、テスト時はフェイク実装を使う。

### 6. テキスト表現の過信

`toString()` の出力をパースしてはいけない。デバッガーで2つの変数が同じ文字列に見えても等価とは限らない。テキスト表現で何の概念（時点？日付？）を表しているかを常に明示する。

## 実践ガイドライン

### 実装前チェックリスト

実装開始前にプロダクトオーナーと以下を合意し、ドキュメントに記録する：

- [ ] グレゴリオ暦のみか、複数暦法が必要か
- [ ] タイムゾーンサポートが必要か
- [ ] どのタイムゾーンデータベースを使うか（推奨: IANA）
- [ ] 未来の予定はタイムゾーン情報ごと保存するか
- [ ] カレンダー演算の月末処理ルール（切り捨て・繰り越しどちらか）
- [ ] 時刻粒度（秒・ミリ秒・マイクロ秒）

### テスト容易性の確保

```
# 良いパターン: Clockを外部から注入
class ReturnDeadlineCalculator:
    def __init__(self, clock):  # テスト時はフェイク時計を注入
        self.clock = clock

    def is_within_deadline(self, deadline):
        now = self.clock.get_current_instant()
        return now <= deadline

# 悪いパターン: システム時計に直接依存
class ReturnDeadlineCalculator:
    def is_within_deadline(self, deadline):
        now = datetime.now()  # テスト不可能
        return now <= deadline
```

テストすべき境界条件：
- ちょうど期限当日（`<=` か `<` かで結果が変わる）
- うるう年の2月29日を含む計算
- サマータイム切替をまたぐ時間帯
- 月末から翌月初めへの加算（31日→翌月1日 vs 翌月末）
- 深夜0時をまたぐタイムゾーン変換

### テキスト表現のルール

| 利用者 | 推奨フォーマット | 注意点 |
|--------|--------------|-------|
| マシン間通信 | ISO-8601 (`2024-03-01T14:30:00Z`) | 標準規格を使い自前実装しない |
| ユーザー表示 | ロケール依存のライブラリ関数 | ユーザー入力を同じフォーマットでパースしない |
| 開発者ログ | ISO-8601 + タイムゾーン情報 | デフォルトの `toString()` に依存しない |

**変換のDRY原則**: フォーマット文字列は一箇所に集約し、再利用すること。`m`（分）と `M`（月）、`h`（12時間）と `H`（24時間）の取り違えは典型的なバグ原因。

## まとめ

- **機械時間・常用時・タイムゾーンを区別する**: 概念ごとに適切な型を使うことで論理的に無効な操作をコンパイル時に検出できる
- **スコープを先に決める**: グレゴリオ暦のみか、どのタイムゾーンを扱うかを実装前にドキュメント化する
- **未来の予定にはタイムゾーンIDを保存する**: UTCだけでは将来のルール変更に対応できない
- **カレンダー演算は曖昧**: 月末処理・結合法則・不可逆性の問題をプロダクトオーナーと確認し、受け入れテストに落とし込む
- **Clock を外部から注入する**: テスト可能な設計のために、システム時計への直接依存を避ける
- **ライブラリのテキスト操作に頼る**: 自前のフォーマット実装は避け、ISO-8601互換フォーマットを使う
