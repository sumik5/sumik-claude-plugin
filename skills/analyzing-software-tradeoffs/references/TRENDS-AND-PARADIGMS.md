# 技術トレンドとパラダイムのトレードオフ

## 概要

新しいパターンやフレームワークを採用する前に、「自分たちのシステムが解決したい問題」を正確に理解することが最優先だ。流行を追いかけることが目的化すると、解決策の複雑さがメリットを上回る。

依存性注入（DI）、リアクティブプログラミング、関数型プログラミング、遅延評価はそれぞれ実績のある強力なパターンだが、**適用するコンテキストを誤ると逆効果になる**。さらにデータの表現方式（リテラルから動的DBまで）も同様に、要件に応じたトレードオフの判断が必要となる。

---

## トレードオフ分析

### 依存性注入（DI）: 手作り vs. フレームワーク

依存性注入はテスト容易性とコンポーネントのライフサイクル管理を向上させる実績あるパターンだ。問題はその「実現方法」の選択にある。

| 比較軸 | 手作りDI | DIフレームワーク |
|-------|--------|--------------|
| 実装コスト | 低（単純なケース） | 中（学習コスト） |
| 透明性 | 高（初期化処理が一箇所に集中） | 低（フレームワーク内部で処理） |
| デバッグ難易度 | 低（コードが追いやすい） | 高（ライフサイクルが隠蔽される） |
| コードの汚染 | なし | あり（フレームワークのアノテーション等が全体に波及） |
| スコープ管理（リクエスト単位等） | 手動実装が必要 | 自動（フレームワークの機能） |
| フレームワーク依存度 | なし | 高（脱却コストが大きい） |

**採用判断の基準:**

| 状況 | 推奨 |
|-----|-----|
| 外部依存が少なく、コンポーネント数が少ない | 手作りDI（シンプルさを維持） |
| スコープ管理（リクエスト・セッション単位）が必要 | DIフレームワーク検討 |
| チーム全体がDIフレームワークに精通している | DIフレームワーク採用 |
| フレームワーク変更コストが問題になりうる | 手作りDIで始め、必要に応じて移行 |

---

### リアクティブプログラミング: 使いどころの見極め

リアクティブプログラミングはノンブロッキングなデータストリーム処理を実現するが、適用範囲を誤ると技術的負債になる。

| 比較軸 | 従来の非同期（Promise/Future） | リアクティブプログラミング |
|-------|---------------------------|----------------------|
| 学習曲線 | 中 | 高（チーム全体への教育が必要） |
| コードの変更範囲 | 局所的に非同期化可能 | プロデューサーから最後のコンシューマーまで一貫して変更が必要 |
| スレッドモデルの複雑さ | 中 | 高（I/OとCPU処理で最適なスレッドプールが異なる） |
| バックプレッシャー対応 | 自前実装が必要 | 標準サポート |
| ブロッキングコードとの混在 | 比較的容易 | 困難（リアクティブ仕様違反になる） |
| 無限ストリーム処理 | 不向き | 適している |

**採用判断の基準:**

| 状況 | 推奨 |
|-----|-----|
| 一部のコンポーネントのみ並列化したい | Promise/Future（局所的に非同期化） |
| システム全体をノンブロッキングに移行する計画がある | リアクティブを全層に適用 |
| チームがリアクティブに不慣れ | 従来の非同期を選択 |
| 大量データストリームのバックプレッシャー制御が必要 | リアクティブが適している |

> **重要**: リアクティブAPIを公開すると、呼び出し元すべてにリアクティブな実装を強制することになる。「一部だけリアクティブ」は機能しない。

---

### 関数型プログラミング: OOP言語での適用限界

関数型プログラミングは不変性・副作用なし・テスト容易性という強力なメリットをもたらす。しかし、OOP言語で「完全に関数型」を目指すと罠がある。

| 関数型の要素 | OOP言語での注意点 | 推奨アプローチ |
|-----------|----------------|-------------|
| 再帰処理 | スタックオーバーフローのリスク（末尾再帰最適化がない言語では大量データに対応不可） | 命令型ループを使う（内部実装は命令型でも関数型APIを提供できる） |
| 不変オブジェクト | 変更のたびにコピーが発生 → メモリ消費増・GCコスト増 | 不変設計の効果と生成コストを測定してバランスを取る |
| 純粋関数 | 言語がサポートしない場合、強制できない | コードレビューやツールで副作用を制御 |
| パターンマッチング | OOP言語では冗長なコードになる場合がある | 言語標準のマッチング機能を活用 |

**関数型アプローチの選択基準:**

| 状況 | 推奨 |
|-----|-----|
| 関数型言語（Haskell、Scala等）を使用 | 再帰・不変性を積極的に活用 |
| OOP言語で一部関数型を採用 | 標準ライブラリのStream/map/filter等を活用（内部は命令型実装） |
| 大量データの再帰処理が必要 | 命令型ループで実装し、関数型APIを外部に提供 |
| 不変オブジェクトの採用 | メモリ消費と整合性維持の効果を測定し採用を判断 |

---

### 遅延評価 vs 先行評価

初期化タイミングの選択は、起動時間・レスポンスタイム・エラー検知タイミングのすべてに影響する。

| 比較軸 | 遅延評価（Lazy） | 先行評価（Eager） |
|-------|--------------|---------------|
| アプリ起動時間 | 短い（処理を先送り） | 長い（起動時にコストを払う） |
| 初回リクエストへの影響 | 遅くなる（初期化コストが乗る） | 影響なし（起動時に完了済み） |
| エラー検知タイミング | 実行時（サービス運用後） | デプロイ時（本番ロールアウト前） |
| スケールアウトへの適合 | ★★★★（起動が速い） | ★★（起動コストがスケールアウトを遅らせる） |

**採用判断の基準:**

| 状況 | 推奨 |
|-----|-----|
| 厳しいSLAがあり、初回リクエストも外れ値にできない | 先行評価（起動時にコスト払い済み） |
| スケールアウトが頻繁で起動時間が重要 | 遅延評価 |
| デプロイ時の問題を早期検知したい | 先行評価（エラーをデプロイ時に検知） |
| ハイブリッド | 重要な初期化は先行・オプション的な処理は遅延 |

---

### データの表現方式（付録A: データライフサイクル）

データをアプリケーションに読み込ませる方式には多くの選択肢があり、それぞれトレードオフが異なる。

| 方式 | 確定タイミング | 変更容易性 | 起動速度 | セキュリティ | 実装コスト |
|-----|------------|---------|--------|-----------|---------|
| 即値（リテラル） | ビルド時 | 低 | 最速 | 高（コードに埋め込み） | 最低 |
| 定数 | ビルド時 | 低 | 最速 | 高 | 低 |
| コマンドライン引数 | 起動時 | 中 | 速い | 低（履歴に残る） | 中 |
| 環境変数 | 起動時 | 高 | 速い | 中〜高 | 中 |
| 設定ファイル | 起動時 | 高 | やや遅い | 中 | 中 |
| ダウンロードコンテンツ | 起動時（ネットワーク） | 非常に高 | 遅い | 暗号化要 | 高 |
| オンラインDB | リアルタイム | 最高 | 遅い | 高い管理が必要 | 最高 |

**採用判断の基準:**

| 状況 | 推奨方式 |
|-----|--------|
| 変更されない定数（数学的定数、APIパスなど） | 即値 or 定数 |
| 環境ごとに切り替えが必要な設定 | 環境変数（12 Factor App推奨） |
| APIキー・シークレット | 環境変数またはシークレット管理サービス |
| 複雑な構造を持つ設定 | 設定ファイル |
| 頻繁に更新される設定（週次イベント、ゲームパラメーター） | ダウンロードコンテンツ or オンラインDB |
| リアルタイム更新が必要 | オンラインDB |

---

## よくある誤り

1. **「流行っているから」でフレームワーク採用**: チームの問題を解決しない採用は複雑さを増やすだけ

2. **一部だけリアクティブ化**: リアクティブAPIは全層への伝染を引き起こす。「境界」を設けない限り機能しない

3. **OOP言語で再帰を多用**: スタックサイズの制限を見落とすと、大量データで本番クラッシュする

4. **不変オブジェクトのコストを測定しない**: メモリ消費・GCへの影響を測定せずに全面採用は危険

5. **DIフレームワーク導入後の密結合**: フレームワークのアノテーションがコード全体に広がると、フレームワーク変更が不可能になる

6. **シークレットを即値でハードコード**: コードがリポジトリに入った瞬間に漏洩リスクが生まれる

7. **遅延初期化のエラーを見逃す**: デプロイ時に気づかず、全ノードにデプロイ完了後に問題が顕在化する

---

## 実践ガイドライン

### 新しいパラダイム採用の手順

```
1. 現在の問題を明確に定義する（「なんとなく古い」は理由にならない）
2. 新しいアプローチが、その問題を解決することを確認する
3. 導入による複雑さ（学習コスト・移行コスト）を定量化する
4. 「複雑さのコスト < 問題解決のメリット」であれば採用
5. 小規模なPoCで効果と副作用を確認してから全面導入
```

### データ表現方式の選択原則

- **単純さを優先**: 動的変更が不要なら即値や定数で十分
- **セキュリティ情報は環境変数以上**: シークレットをコードやファイルに書かない
- **変更頻度に応じて柔軟性を決める**: 週次変更が必要なものをビルドに埋め込まない
- **ハイブリッドの検討**: 必須の設定は先行ロード、オプションは遅延ロードなど組み合わせる

---

## まとめ

- **問題を先に定義する**: 技術トレンドに飛びつく前に、解決すべき問題を明確にする
- **DIは最小限から始める**: 手作りDIで十分な場合が多い。フレームワークはコスト・メリットを慎重に評価する
- **リアクティブは全層か全廃か**: 一部だけのリアクティブ化は機能しない。全体設計を変えられる確信があるときだけ採用する
- **FPはOOP言語の制約を理解して使う**: 再帰・不変性はOOP言語ではコストを伴う。標準ライブラリの関数型APIを活用する
- **遅延 vs 先行はSLAで決める**: 初回リクエストのSLAが厳しければ先行評価、起動速度が重要なら遅延評価
- **データ表現はシンプルさから始める**: 必要な柔軟性に応じてリテラルから動的DBまで段階的に選択する
