# 分散システムのデータ配信

## 概要

分散システムでのデータ配信設計は「確実さ」と「パフォーマンス」のトレードオフだ。サービス間を直接接続する同期型アーキテクチャはシンプルだが、依存先の障害がカスケードし、システム全体が脆くなる。Pub-Sub（プロデューサー・コンシューマー）モデルを採用することでプロデューサーとコンシューマーを疎結合にし、障害の伝播を防ぐ耐障害性のある設計が実現できる。

中核となる設計判断は「どの配信セマンティクスを選ぶか」だ。at-least-once（最低1回）、at-most-once（最大1回）、effectively exactly-once（実質1回）の3つは、それぞれ異なるトレードオフを持ち、ユースケースに応じて選択しなければならない。

## トレードオフ分析

### アーキテクチャ選択：同期直接接続 vs Pub-Sub

| 観点 | 同期直接接続 | Pub-Subモデル |
|------|-------------|--------------|
| 実装複雑度 | 低い | 中〜高い |
| 耐障害性 | 低い（依存先の障害が伝播） | 高い（キューがバッファ） |
| 疎結合度 | 低い | 高い |
| レイテンシー | 低い（直接応答） | 高い（非同期） |
| スケーラビリティ | 接続数が爆発的に増大 | コンシューマーを独立スケール |
| 単一障害点 | 各依存先がSPOF | キューがSPOF（ただし冗長化可） |

### プロデューサー側：一貫性 vs 可用性の設定

| ACK設定 | 動作 | 一貫性 | 可用性 | 適用場面 |
|--------|------|--------|--------|---------|
| 全ブローカー確認（acks=all） | 全レプリカへの書き込みを確認 | 高い | 低い | 決済・金融取引 |
| リーダーのみ確認（acks=1） | リーダーの書き込みのみ確認 | 中程度 | 高い | 一般的なログ・メトリクス |
| 確認なし（acks=0） | 応答を待たない | 低い（ロスト多発） | 最高 | 火災報知器など損失許容型 |

### コンシューマー側：配信セマンティクス選択

| セマンティクス | コミットタイミング | 重複リスク | ロストリスク | 適用場面 |
|--------------|-------------------|-----------|------------|---------|
| at-least-once | 処理完了後 | あり（要重複排除） | なし | 決済、在庫更新 |
| at-most-once | 処理開始前 | なし | あり | アラート、非クリティカル通知 |
| effectively exactly-once | at-least-once＋重複排除 | なし（排除済み） | なし | 厳密な一貫性が必要な全処理 |

### コンシューマーの再起動戦略

| 戦略 | 動作 | 影響 | 適用場面 |
|------|------|------|---------|
| 最初のオフセットから再開 | 未コミットイベントを再処理 | at-least-once / 重複あり | 決済、在庫、正確性重視 |
| 最新のオフセットから再開 | 未処理イベントをスキップ | at-most-once / ロスあり | リアルタイム監視、タイムセンシティブ |

### キュー分割：モノリシックキュー vs 責務別分割

| 観点 | 単一キュー | 責務別複数キュー |
|------|-----------|----------------|
| 管理コスト | 低い | 高い |
| 単一障害点 | キュー全体がSPOF | 影響範囲を局所化 |
| チューニング柔軟性 | 低い | 高い（重要度別に設定変更可） |
| コスト最適化 | 難しい | 可能（非重要データのコスト削減） |

## よくある誤り

### 1. プロデューサーのリトライをデフォルトのまま使う

多くのメッセージングシステムではリトライがデフォルト有効だ。リトライを有効にする＝at-least-onceになると意識せず、コンシューマー側に重複排除を実装しないのは危険だ。

### 2. パーティション数を少なく設計し、後から増やそうとする

パーティション数は後から変更できても、パーティション内の順序保証は破られる。同じキーのイベントが別パーティションに分散すると、コンシューマー側で順序を再構築できなくなる。**パーティション数は性能テストに基づいて最初に正しく設定すること。**

### 3. コンシューマー数をパーティション数の倍数以外に設定する

コンシューマーがパーティション数の約数でない場合、特定のコンシューマーが他より多くのパーティションを担当し、処理に偏りが生じる。パーティション数 `P` に対し、コンシューマー数は `P` の約数（1, P/2, P など）にするのが基本だ。

### 4. トランザクション機能でexactly-onceが「完全保証」されると思い込む

メッセージングシステム内部のトランザクションは、そのシステム内のプロデューサー→コンシューマー間のみを保護する。外部HTTPリクエストや別システムからの入力には適用されない。パイプライン全体をカバーするには、各段階での重複排除が別途必要だ。

### 5. 余剰処理能力を確保せずにat-least-onceを採用する

コンシューマーのSLAがプロデューサーのスループットと等しい場合、一時的な障害後のバックログ解消ができない。コンシューマーは通常トラフィック＋バックログを同時処理できる余剰キャパシティが必要だ。

## 実践ガイドライン

### Pub-Sub設計の基本方針

1. **プロデューサーは送信先を知らない** — キューへの書き込みのみを責務とする
2. **コンシューマーは独立してスケール** — コンシューマーグループを利用してアプリ別に分離する
3. **キューはバッファ兼デカップリング** — コンシューマーの一時的な停止はキューで吸収する

### 配信セマンティクスの選択指針

```
ユースケースに重複があってはならない
AND データロストも許容できない
    → effectively exactly-once（at-least-once + 重複排除）

データロストは許容できるが重複は困る
    → at-most-once（処理前コミット）

重複は許容できるがデータロストは困る
    → at-least-once（処理後コミット）
```

### コンシューマーのオフセット管理

- **手動コミット推奨** — 自動コミットは障害発生タイミングによって重複/ロストが制御不能になる
- **同期コミット** — 確実だがスループットに影響。クリティカルな処理に
- **非同期コミット** — 高スループット。エラーハンドリングを丁寧に実装する

### 耐障害性設計のチェックリスト

- [ ] コンシューマーはプロデューサーの1.5〜2倍のスループット余裕を持つ
- [ ] 重要度の高いデータは専用のキューで分離する
- [ ] パーティション数は事前の性能テストで決定する
- [ ] コンシューマーのオフセットリセット戦略を明示的に選択する
- [ ] at-least-onceを使用する場合、コンシューマー側に重複排除を実装する

### effectively exactly-onceの実装パターン

```
// プロデューサー側
event_id = generate_unique_id()
send_with_retry(event, event_id)  // at-least-once

// コンシューマー側
if db.upsert_if_not_exists(event_id):
    process(event)
    // 処理完了後にオフセットコミット
```

外部システムへの接続が含まれる場合、そのシステムもべき等性を保証しているか確認する。

## まとめ

| ポイント | 内容 |
|---------|------|
| 疎結合の手段 | Pub-Subモデルで同期依存を排除する |
| 耐障害性の源泉 | キューがバッファとして機能し、コンシューマー停止の影響を吸収する |
| セマンティクスの選択 | ユースケースの「重複許容度」と「ロスト許容度」から逆算する |
| exactly-onceの現実 | システム内の全段階がべき等でなければ実現しない。at-least-once＋重複排除が現実的 |
| 見落としやすい落とし穴 | コンシューマーのキャパシティ不足でバックログが永遠に解消されない |
