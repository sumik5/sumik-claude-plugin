# エラーハンドリング戦略のトレードオフ

## 概要

コードはあらゆる状況で失敗しうる。エラーハンドリングの設計は「**どの失敗を呼び出し元に知らせるか**」と「**どのように知らせるか**」という2つの核心的な判断で構成される。この判断を誤ると、デバッグ困難なサイレントエラー、API境界からのサードパーティ例外の漏洩、または非同期処理での気づかれない失敗を招く。

重要な原則として、例外はコードのイレギュラーな振る舞いを示すために使うものであり、アプリケーションのフロー制御には使うべきではない。また「すべての例外を回復しようとする必要はない」という考え方（致命的な失敗はクラッシュさせてプロセスを再起動する方が良い場合もある）も状況によっては有効な選択肢だ。

---

## トレードオフ分析

### 検査例外 vs 非検査例外

| 比較軸 | 検査例外（宣言が必須） | 非検査例外（宣言不要） |
|--------|----------------------|----------------------|
| APIの明示性 | ✅ コンパイル時にエラー処理を強制 | ❌ 実行時に発覚、驚きが生じやすい |
| 呼び出し元の負担 | ❌ すべての呼び出しで処理が必要 | ✅ 不要な場合は無視できる |
| 使いどころ | 公開APIでの回復可能なエラー（I/O、ネットワーク等） | 引数不正・状態不正・プログラムのバグ |
| 関数型との相性 | ✅ Try型でのラップが容易（明示的なため） | ❌ どのメソッドから飛んでくるか不明 |

### 例外の粒度：すべて捕捉 vs きめ細かく処理

| 比較軸 | 基底例外型で一括捕捉 | 個別の例外型を明示的に捕捉 |
|--------|---------------------|--------------------------|
| コード量 | ✅ 少ない | ❌ 多い |
| 情報の保持 | ❌ 特定の例外型情報が失われる | ✅ 例外の種類ごとに対応できる |
| 意図しない例外の捕捉 | ❌ 関係のない例外まで捕捉するリスク | ✅ 想定外の例外は上位に伝播される |
| マルチキャッチによる妥協点 | `catch (ExceptionA \| ExceptionB e)` でコードを減らしながら型情報を保持 |

### オブジェクト指向（try-catch）vs 関数型（Tryモナド）

| 比較軸 | try-catchアプローチ | Tryモナドアプローチ |
|--------|--------------------|--------------------|
| エラーの可視性 | ⚠️ 暗黙的（例外が宣言されていれば明示的） | ✅ 戻り値の型としてエラーを表現 |
| コードの可読性 | ⚠️ ビジネスロジックとエラー処理が混在 | ✅ チェーン処理でロジックを分離 |
| 非検査例外の扱い | ⚠️ どこから飛んでくるかわからない | ❌ すべての呼び出しをラップする必要が生じやすい |
| 既存コードとの混在 | ✅ ほとんどの言語で標準的 | ❌ 関数型と非関数型の境界で変換コストが発生 |
| 適用条件 | 全体が例外ベースで統一されたコードベース | 全体が型安全なエラーハンドリングで統一されたコードベース |

### Promise（非同期）でのエラー処理：投げ直し vs Promiseにラップ

| 比較軸 | 非同期内で例外を投げ直す | Promiseオブジェクトに例外をラップ |
|--------|------------------------|----------------------------------|
| スタックトレース | ❌ 並行ライブラリの内部フレームが混入 | ✅ 実際の原因のみが含まれる |
| サイレントフェイラーのリスク | ❌ 結果を取得しない場合に気づかれない | ✅ Promiseを通じてエラーを伝播 |
| コードの複雑さ | ⚠️ 例外の変換レイヤーが必要 | ⚠️ Promise APIの理解が必要 |

---

## よくある誤り

### 1. 例外の握りつぶし（最も危険なアンチパターン）

```
// ❌ 絶対にやってはいけない
try {
  doSomething()
} catch (e) {
  // 何もしない（例外が起きたという情報が完全に消滅）
}
```

握りつぶされた例外はサイレントエラーとなり、システムが音もなく失敗し続ける。デバッグが極めて困難になる。少なくとも例外情報はログに記録する。

### 2. `printStackTrace()` でのロギング（標準出力は信頼できない）

標準出力は捕捉されなかったり、ログ収集基盤に入らないことがある。適切なロガーを使い、`logger.error("メッセージ: ", exception)` の形式でスタックトレースを記録する。

### 3. サードパーティライブラリ固有の例外をAPIの外に漏洩させる

```
// ❌ 内部実装の詳細が公開APIに漏れる
function getUser(): PersonInfo throws ThirdPartyLibraryException

// ✅ ドメイン固有の例外でラップする
function getUser(): PersonInfo throws UserCatalogException
```

ライブラリ固有の例外を公開APIから伝播させると、ライブラリを変更するたびにAPIのシグネチャが変わり、呼び出し元のコードが壊れる。ドメイン固有の例外クラスで内部実装をラップし、APIの安定性を保つ。

### 4. アプリケーションフロー制御に例外を使う（goto的な使い方）

条件分岐の代わりに例外を使うコードは、呼び出し元が複雑な例外処理ロジックを組む必要が生じ、コードが読みにくくなる。例外は「例外的な状況」のみに使い、通常のフロー制御には戻り値や`Option`/`Result`型を使う。

### 5. 非同期処理でのサイレントフェイラー

fire-and-forgetで送信した非同期タスクが失敗しても、誰も気づかない。スレッドが終了し、スレッドプールが枯渇するリスクがある。

```
// ❌ 失敗が気づかれない
executor.execute(task)

// ✅ グローバル例外ハンドラーを登録する
thread.setUncaughtExceptionHandler((t, e) -> logger.error("スレッドで例外: " + t, e))

// ✅ または Promise/Future を使い結果を取得する
future = executor.submit(task)
result = future.get()  // 例外が伝播される
```

### 6. リソースのクローズ漏れ

例外発生時にリソースのクローズ処理がスキップされると、リソースリークが発生する。`try-with-resources` / `using` / コンテキストマネージャ / `defer` 等、言語固有のリソース管理機構を活用する。

```
// ✅ AutoCloseableなリソースは自動クローズを活用
try (resource = openResource()) {
  processRequests(resource)
}
// ブロックを抜けると例外発生時も含めてリソースが自動クローズされる
```

---

## 実践ガイドライン

### 例外設計の判断フロー

```
公開APIを設計している？
├── Yes → 検査例外（または明示的なエラー型）を使い契約を明示
│          呼び出し元が処理方法を決められるようにする
│
└── No（内部コンポーネント）→ 非検査例外で十分
                            呼び出し元と実装の両方を自分たちが所有しているため

エラーから回復できる？
├── Yes → 検査例外で明示的に通知（I/O、ネットワーク等）
└── No  → 非検査例外（引数不正、状態不正）またはクラッシュさせる（致命的なエラー）
```

### 非同期処理のエラーハンドリング指針

1. **可能な限りPromise/Futureを使う**：結果を受け取れるため、失敗を確実に検知できる
2. **fire-and-forgetを使う場合はグローバル例外ハンドラーを必ず登録する**
3. **Promiseに例外をラップして返す**：スタックトレースが汚染されず、エラーを安全に呼び出し元に伝播できる
4. **非同期処理の結果は必ず確認する**：受け取ったPromiseを使わずに捨てると気づかない失敗が生じる

### パフォーマンスへの影響（目安）

| 操作 | 相対コスト | 実態 |
|------|-----------|------|
| 例外の生成なし（ベースライン） | 1x | 最速 |
| 例外の投げ・捕捉 | ~100x | 実用上問題ない範囲 |
| Tryモナドで例外をラップ | ~100x | try-catchとほぼ同等 |
| スタックトレースの取得 | ~750x | 注意が必要 |
| ロガーで例外をロギング | ~3000x | I/O操作含む。高頻度パスでは避ける |

**注意点**：
- 例外処理のアプローチ（OOP vs 関数型）のパフォーマンス差はほぼない
- スタックトレース取得・ロギングが高コストな部分
- 例外を上位層に投げ直す場合、中間層ではロギングしない（上位層でまとめてロギングする）
- 高頻度・低レイテンシーなコードパス以外では、パフォーマンスより正確なエラー情報を優先する

### サードパーティライブラリの例外処理指針

1. 内部実装で使うライブラリ固有の例外はドメイン固有の例外クラスでラップする
2. ラップした例外には、元の例外（`cause`）を必ず含める（デバッグに不可欠）
3. ドメイン固有の例外名で呼び出し元が「何が・なぜ」失敗したかを推測できるようにする
4. 内部的にしか使われない非公開コンポーネントでは、ラップコストに見合わない場合はそのまま使ってもよい

---

## まとめ

- **例外はフロー制御ではなく異常通知のため**：通常の条件分岐に例外を使わない
- **公開APIでは明示的なエラー宣言を**：呼び出し元が自分でエラー処理方法を決められるようにする
- **サードパーティ例外は境界でラップ**：ライブラリ変更の影響を呼び出し元から遮断する
- **非同期処理の失敗は必ず検知する仕組みを作る**：サイレントフェイラーはデバッグが最も困難
- **スタックトレースのロギングコストに注意**：高頻度パスでは避け、必要な層でのみ行う
- **Tryモナドはコードベース全体で統一する場合に効果を発揮**：部分的な混在はかえって複雑さを増す
