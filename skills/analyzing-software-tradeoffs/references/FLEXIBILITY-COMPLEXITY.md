# 柔軟性と複雑性のバランス

## 概要

APIに柔軟性を与えるたびに、複雑性が増加する。これは避けられないトレードオフだ。重要なのは「複雑性がゼロになる」ことではなく、「複雑性がどこに移動するか」を意識することだ。

抽象化によって自コンポーネントの複雑性が下がっても、クライアント側に複雑性がアウトソースされる。フックAPIやリスナーAPIは高い拡張性をもたらすが、例外処理・スレッドモデル・イミュータビリティといった新たな問題を生み出す。

## トレードオフ分析

### 設計パターン別：柔軟性 vs 複雑性

| 設計パターン | 柔軟性 | コンポーネント複雑性 | クライアント複雑性 | 主なリスク |
|------------|--------|--------------------|--------------------|-----------|
| 固定実装（特定ライブラリ直接利用） | 低 | 低 | 低 | ライブラリ変更時の影響大 |
| インターフェイス抽象化（デフォルト実装なし） | 中 | 低 | 高 | クライアントごとに実装が必要 |
| インターフェイス抽象化（デフォルト実装あり） | 中 | 中 | 低〜中 | コードが若干増加する |
| フックAPI（同期） | 高 | 高 | 低 | ブロッキング・例外伝播リスク |
| フックAPI（非同期・スレッドプール） | 高 | 非常に高 | 低 | スレッド管理の複雑性増大 |
| リスナーAPI（非同期） | 高 | 高 | 低 | 状態改変・バックプレッシャーリスク |

### フックAPI vs リスナーAPI

| 観点 | フックAPI | リスナーAPI |
|------|-----------|-------------|
| コンポーネントの処理フローへの影響 | あり（happens-before関係） | なし（完全非同期） |
| クライアントのブロッキングによる影響 | 直接影響する | 別スレッドで処理するため影響なし |
| イミュータビリティの必要性 | 低（呼出し元でのみ使用） | 高（外部に状態を渡す） |
| 適切なユースケース | リクエスト加工・ヘッダー付与など | イベント通知・メトリクス収集など |

## よくある誤り

### 1. 複雑性の消滅を期待する

```
// ❌ 誤った認識
// 「インターフェイスを導入すれば複雑性が下がる」
// → 実際はクライアントに複雑性が移動するだけ

// ✅ 正しい認識
// 「複雑性の所在地をコントロールする」
// デフォルト実装を提供して、クライアント負担を軽減する
```

### 2. フックAPIの例外を考慮しない

```
// ❌ 危険：フックの例外が伝播しコンポーネント全体に影響する
for hook in hooks:
    hook.execute(request)  # 非検査例外がスローされるかもしれない

// ✅ 安全：例外をキャッチしてログ出力し、処理を継続する
for hook in hooks:
    try:
        hook.execute(request)
    except Exception as e:
        logger.error("Hook threw exception. Validate hook logic.", e)
        # ライフサイクルを停止しない
```

### 3. リスナーにミュータブルな状態を渡す

```
// ❌ 危険：リスナーが状態を改変できてしまう
for listener in listeners:
    listener.onEvent(retryStatuses)  # 内部リストへの参照を渡している

// ✅ 安全：イミュータブルなラッパーで包んで渡す
immutable_statuses = ImmutableList(retryStatuses)
for listener in listeners:
    listener.onEvent(immutable_statuses)
```

### 4. フックAPIのブロッキングリスクを無視する

フック内でI/O処理を行うクライアントが存在すると、コンポーネントのレイテンシーが劇的に増加する。

```
// フック1: 1,000ms のブロッキングI/O
// フック2: 1,000ms のブロッキングI/O
// 本来の処理: 300ms

// 逐次実行: 300 + 1,000 + 1,000 = 2,300ms（約8倍の劣化）
// 並列実行でも happens-before 関係のため: 300 + 1,000 = 1,300ms（約4倍の劣化）
```

## 実践ガイドライン

### サードパーティライブラリを抽象化する判断基準

| 状況 | 推奨アプローチ |
|------|--------------|
| 内部使用のみで、将来的に変更の可能性が低い | 直接利用（抽象化不要） |
| 複数チーム・クライアントが使用する | インターフェイスで抽象化 + デフォルト実装を提供 |
| クライアントが異なるライブラリを使いたい可能性がある | インターフェイス抽象化を優先 |

### 拡張性の導入タイミング

```
Step 1: 最小限の実装から始める（拡張ポイントなし）
         ↓ クライアントの利用パターンを観察
Step 2: 実証されたユースケースに基づいて拡張ポイントを追加
         ↓ 複雑性コストを試算
Step 3: フックAPI・リスナーAPIは最後の手段として検討
```

### フックAPIを導入する際のチェックリスト

- [ ] フックの例外を `try-catch` でラップしているか
- [ ] ブロッキングフックのためのスレッドプールを用意しているか
- [ ] スレッドプールのサイズ・キューサイズ・監視を設定しているか
- [ ] happens-before 関係とレイテンシーへの影響を計算したか
- [ ] 想定外の利用法（内部状態の改変等）を文書化したか

### リスナーAPIを導入する際のチェックリスト

- [ ] 渡すオブジェクトはイミュータブルか（または防衛的コピーを作成しているか）
- [ ] リスナーの実行は別スレッドプールで行われるか
- [ ] バックプレッシャーの仕組みはあるか
- [ ] トラフィック増大時のメモリー消費を試算したか

## まとめ

- **柔軟性と複雑性はトレードオフ**：設計の柔軟性を高めるほど、どこかに複雑性が生まれる
- **複雑性の所在地を選ぶ**：抽象化によってコンポーネントの複雑性を下げても、クライアントに移動するだけ。デフォルト実装の提供が折衷案となる
- **フックAPIの代償**：例外処理・スレッドプール管理・ブロッキングリスクというメンテナンス負荷を支払う
- **リスナーAPIのコスト**：状態のイミュータビリティ保証・バックプレッシャー設計が必要になる
- **拡張ポイントは実証に基づいて追加**：将来のユースケースを全て予測して設計しようとすると、オーバーエンジニアリングに陥る
