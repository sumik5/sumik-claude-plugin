# コードの重複 vs 疎結合

## 概要

DRY（Don't Repeat Yourself）原則はソフトウェア工学で最も広く知られるルールの一つだが、分散システムやマイクロサービス環境ではこの原則を盲目的に適用すると深刻なトレードオフが生じる。コードの重複を排除しようとする行為は、チーム間の**同期コスト増加**と**密結合**という代償を伴う。

重要な洞察は「コードの重複は常に悪ではない」という点だ。独立したコードベース間で共通コードが重複していても、チームが自律的に作業できる場合、重複は疎結合の実現手段として合理的な選択になりえる。コードの重複、コードの柔軟性、デリバリー速度という3つの要素は常にトレードオフの関係にある。

---

## トレードオフ分析

### コード共有の3つのアプローチ

| 比較軸 | コードの重複（各サービスに実装） | 共有ライブラリ | マイクロサービス抽出 |
|--------|----------------------------------|----------------|----------------------|
| チーム独立性 | ✅ 高い（同期不要） | ⚠️ 中程度（ライブラリ更新で調整が必要） | ⚠️ 中程度（APIバージョン管理が必要） |
| 開発速度 | ✅ 速い | ⚠️ 初期コスト高、以降は速い | ❌ 初期コスト最大 |
| バグ修正の波及 | ❌ 各箇所を個別修正 | ✅ 一箇所の修正で全利用者に波及 | ✅ 一箇所の修正で全利用者に波及 |
| 結合度 | ✅ 疎結合 | ⚠️ コード依存（推移的依存リスク） | ✅ API境界のみで結合 |
| 実行コスト | ✅ なし | ✅ なし | ❌ ネットワーク往復が追加発生 |
| 言語制約 | ✅ 各チームが自由に選択 | ❌ 同一言語・技術スタックが必要 | ✅ プロトコル互換であれば自由 |
| 保守コスト | ❌ 重複した保守作業 | ⚠️ ライブラリ保守チームが必要 | ❌ デプロイ・監視・アラート等が追加で必要 |

### 継承 vs コンポジション

| 比較軸 | 継承（Template Methodパターン） | コンポジション（Strategyパターン） |
|--------|--------------------------------|-----------------------------------|
| コード重複の削減 | ✅ 親クラスにロジック集約 | ✅ 独立した責務として分離 |
| 柔軟性 | ❌ 親クラスの変更が全子クラスに影響 | ✅ 任意の組み合わせで拡張可能 |
| 理解のしやすさ | ✅ シンプル（概念がひとつ） | ⚠️ 抽象化部品の数が増加 |
| 要件変化への対応 | ❌ 一部の子クラスだけ変更が困難 | ✅ 特定の振る舞いのみ差し替え可能 |
| カプセル化 | ❌ 親クラスが子クラス固有の詳細を知る必要が生じやすい | ✅ 責務ごとに適切にカプセル化 |

---

## よくある誤り

### 1. 偶然の重複を本質的な重複と混同する

2つのコンポーネントが現時点では同じコードを持っていても、それぞれが異なるビジネスドメインを解決していることがある。このケースでの性急な抽象化は、将来の要件変化時に深刻な問題を引き起こす。

```
❌ 悪い判断フロー:
「コードが同じ → すぐに共通ライブラリに抽出」

✅ 良い判断フロー:
「コードが同じ → ビジネス目的も同じ？ → 変化の方向性も同じ？ → 抽象化を検討」
```

### 2. 共有ライブラリに推移的依存を持ち込む

共有ライブラリが多数のサードパーティライブラリに依存すると、利用者側で依存関係の競合が発生する。ライブラリの依存関係は最小限に保つべきである。

```
問題パターン:
  共有ライブラリ → LibraryA v2.0
  利用サービス  → LibraryA v1.5 (別の依存経由)
  → バージョン競合でランタイムエラー

対策:
  共有ライブラリの外部依存を最小化する
  オープンソースの既存ライブラリを先に調査する
```

### 3. `instanceof`による型チェックで継承の密結合を回避しようとする

継承で生じた柔軟性の問題を、親クラス内で子クラスの型をチェックすることで解決しようとするパターン。これは「コードは共有されたが親子クラスが密結合になった」状態であり、継承を導入した目的に完全に反する。

### 4. サービス分離のコストを過小評価する

マイクロサービスへの抽出は、デプロイプロセス、監視、アラート、バージョン管理、SLA考慮（レイテンシー増加）、カスケード障害対策が必要になる。これらのインフラを持たない段階でのマイクロサービス化は、保守コストを大幅に増加させる。

---

## 実践ガイドライン

### コード共有手法の選択基準

```
┌─ セキュリティ・重要インフラ？
│   → はい: 共有ライブラリ必須（バグ修正の一元化が重要）
│
├─ 独立したビジネスドメインとして成立？ かつ チームが専任で保守可能？
│   → はい: マイクロサービス抽出を検討
│
├─ 同一技術スタック？ かつ 依存関係がシンプル？
│   → はい: 共有ライブラリ
│
└─ 上記いずれでもない、またはチーム独立性を優先：
    → しばらく重複を許容し、パターンが見えてから抽象化
```

### マイクロサービス化の前提条件チェックリスト

- [ ] デプロイパイプラインが整備されているか
- [ ] 監視・アラートの仕組みがあるか
- [ ] SLAへの影響（追加ネットワーク往復）を計測したか
- [ ] カスケード障害に対応する設計（Circuit Breaker、Exponential Backoff等）があるか
- [ ] 担当チームが保守を継続できるか

### 継承の使い時

- サブクラスごとの要件が明確に定まっており、将来も安定している場合
- 親クラスのロジック変更が全サブクラスに一様に適用されるべき場合

上記に当てはまらない場合は、コンポジション（依存性注入で責務を組み合わせる）を優先する。

### 重複を残す判断基準

アムダールの法則の考え方をチーム開発に適用すると、同期処理（チーム間調整）の割合が高いほどリソースを追加しても効率が上がらない。次の条件が揃う場合、コードの重複を意図的に維持することが合理的な選択となる。

1. 2つのチームが異なるスピードで独立して進化させたい
2. 変更の方向性が将来的に異なる可能性がある（偶然の重複）
3. 調整コストが重複コストを上回ると判断できる

---

## まとめ

- **DRY原則は文脈依存**：モノリシックシステムでは強力だが、分散システムでは密結合や開発速度低下のリスクを伴う
- **重複の種類を見極める**：本質的な重複（同じビジネス目的）は排除すべきだが、偶然の重複（現在たまたま同じ）は慎重に扱う
- **継承よりコンポジション**：要件が変化しやすい場合、継承は柔軟性を損なう
- **最初から抽象化しない**：独立したコンポーネントを作り、パターンが見えてから抽象化するタイミングを選ぶ
- **マイクロサービス化は慎重に**：追加コスト（デプロイ、監視、ネットワーク障害対策）を理解した上で判断する
