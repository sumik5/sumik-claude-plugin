# コードレビュー コアガイドライン

## 概要

このスキルはコードレビューの全工程を扱う。PRの作成から効果的なフィードバックの提供、チームプロセスの構築、そして問題パターンの回避まで、高品質なレビュー文化を築くための実践的な指針を提供する。

**サブファイル**:

| ファイル | 内容 |
|---------|------|
| [references/REVIEW-PROCESS.md](./references/REVIEW-PROCESS.md) | レビューワークフロー・プロセス設計・自動化・緊急対応 |
| [references/EFFECTIVE-COMMENTS.md](./references/EFFECTIVE-COMMENTS.md) | コメント技法（5P・MMG・Triple-R・Conventional Comments）詳細 |
| [references/TEAM-AGREEMENTS.md](./references/TEAM-AGREEMENTS.md) | チーム合意（TWA）の設計とテンプレート |
| [references/ANTI-PATTERNS.md](./references/ANTI-PATTERNS.md) | アンチパターン・遅延原因・プロセスの抜け穴 |

---

## コードレビューの価値

コードレビューは単なるバグ検出手段ではない。その本質的な価値は5つある:

1. **バグ発見**: 作者が見落とした論理エラー・境界値・副作用を検出する。
2. **保守性向上**: 可読性・命名・構造についてフィードバックし、将来の変更コストを下げる。
3. **知識共有**: コードの変更を通じてシステムの動作・設計意図をチーム全体に伝播させる。
4. **メンタリング**: 経験の浅いメンバーへの成長機会として機能する。
5. **記録の生成**: PRと議論は将来の意思決定の根拠となるドキュメントになる。

**重要な視点**: コードレビューは「欠陥を探す場」ではなく「コードを共同所有するプロセス」である。批判ではなく協力の姿勢で臨む。

**効果的なコードレビューが実現する状態**:
- バグが本番環境に到達する前にキャッチされる
- チームメンバー全員がシステムの全体像を理解している
- 「このコードは〇〇さんしか知らない」という知識のサイロが存在しない
- 新しいメンバーがコードベースを通じてチームのやり方を学べる
- コードに関する意思決定がPRの履歴として残り、将来参照できる

---

## PRの構成要素

### タイトル（What）

タイトルは「この変更が何をするか」を一行で伝える。

**基本ルール**:
- 80文字以内に収める
- カテゴリプレフィックスを付ける
- 動詞の原形で開始する（例: "Add", "Fix", "Remove"）

**カテゴリプレフィックス**:

| プレフィックス | 用途 | 例 |
|-------------|------|-----|
| `feat:` | 新機能追加 | `feat: Add user profile image upload` |
| `fix:` | バグ修正 | `fix: Resolve null pointer in auth flow` |
| `docs:` | ドキュメント変更のみ | `docs: Update API endpoint examples` |
| `refactor:` | 動作変更なしのリファクタリング | `refactor: Extract payment service class` |
| `test:` | テスト追加・修正 | `test: Add unit tests for order calculation` |
| `chore:` | ビルド設定・依存関係等 | `chore: Upgrade Jest to v30` |
| `breaking:` | 後方互換性を壊す変更 | `breaking: Remove deprecated /v1/users API` |
| `perf:` | パフォーマンス改善 | `perf: Add database index for query optimization` |

### 説明文（Why）

説明文は「なぜこの変更が必要か」を伝える。タイトルの補足ではなく、文脈と意図の説明である。

**必須要素**:
- **背景・問題**: なぜこの変更が必要になったか
- **解決策の説明**: どのようなアプローチを取り、なぜそれを選んだか
- **テスト方法**: レビュアーが動作確認するための手順
- **関連チケット**: IssueやタスクへのリンK
- **ドキュメント更新**: 変更に伴うドキュメント更新の有無

**推奨要素**:
- スクリーンショット・動画（UI変更の場合）
- Before/After の比較
- パフォーマンス測定結果（パフォーマンス改善の場合）
- マイグレーション手順（破壊的変更の場合）

**PRテンプレート例**:

```markdown
## 概要
<!-- この変更の目的と背景を記述 -->

## 変更内容
<!-- 主要な変更点をリスト形式で記述 -->

## テスト方法
<!-- レビュアーが動作確認する手順 -->
- [ ] 手順1
- [ ] 手順2

## 関連
<!-- Issue番号、ドキュメント等へのリンク -->
Closes #
```

### PRサイズ

**推奨サイズ**:
- 変更ファイル数: 20ファイル以下
- 変更行数: 500行以下（純増分）

大きなPRは次の問題を引き起こす:
- レビュー時間が指数的に増加する
- 問題を見落としやすくなる
- レビュアーの集中力が低下する
- フィードバックサイクルが長くなる

PRが大きくなりそうな場合は、フィーチャーフラグを使って機能単位・レイヤー単位に分割する。

### レビュー状態

| 状態 | 意味 | 次のアクション |
|------|------|--------------|
| Approved | 変更を承認。マージ可能 | PR作成者がマージ |
| Request Changes | 必須の修正がある。修正なしにマージ不可 | PR作成者が修正・再レビュー依頼 |
| Comment | 承認でも却下でもない情報提供 | PR作成者が任意で対応 |

### ドラフトPR

実装途中のPRを「Draft」状態で公開する仕組み。

**活用場面**:
- 設計の方向性について早期フィードバックを得たい場合
- 大きな変更を段階的にレビューしてもらいたい場合
- 依存する別PRのマージを待っている場合

**ドラフトのルール**:
- Draft状態のPRはレビュー依頼が発生していない（自発的に見る必要はない）
- ドラフトからReady for Reviewに変更したときにレビュー依頼が発生する
- ドラフトを使うことで、早期の設計議論をレビューサイクルと分離できる

---

## 効果的なコメントの3原則

### 原則1: 客観性（Objectivity）

感情や主観ではなく、コードの品質・保守性・正確性に基づいてコメントする。

**5Pプロセス（コメント前の自己チェック）**:
1. **Pause（一時停止）**: 反射的にコメントする前に一息つく
2. **Ponder（熟考）**: この変更は本当に問題か？代替案はあるか？
3. 次のいずれかを選ぶ:
   - **Pass（パス）**: 問題ではないと判断し、コメントしない
   - **Propose（提案）**: 具体的な改善案を添えてコメントする
   - **Postpone（延期）**: チームとして議論すべき問題として記録する

**MMGエクスチェンジ（中間地点の模索）**: レビュアーと作者で意見が対立したとき、どちらの案でもない「共通の最善策（Middle Ground）」を探す対話プロセス。勝ち負けではなく、最良のコードを共同で見つけることが目的。

### 原則2: 具体性（Specificity）

「これはダメ」ではなく、何を、どのように変えるべきかを明確に伝える。

**コメントシグナル**（コメントの種類を最初に明示する）:

| シグナル | 意味 | マージ影響 |
|---------|------|-----------|
| `needs change:` | この修正なしにマージ不可 | ブロッキング |
| `needs rework:` | 大幅な設計変更が必要 | ブロッキング |
| `align:` | チームの合意・標準との整合を確認 | 要議論 |
| `levelup:` | 学習・成長のための教育的コメント | 非ブロッキング |
| `nitpick:` | 軽微な改善（対応は任意） | 非ブロッキング |
| `praise:` | 優れた実装への称賛 | — |

**MoSCoW優先度**（複数の指摘がある場合に優先順位を明示する）:

| 優先度 | 意味 |
|--------|------|
| Must Have | 必須。マージ前に対応必要 |
| Should Have | 対応を強く推奨するが、マージはできる |
| Could Have | 時間があれば対応。しなくても問題ない |
| Won't Have | 将来のIssueとして別途管理 |

**Conventional Commentsフォーマット**:

```
<label> [(decorations)]: <subject>

[discussion]
```

例:
```
nitpick (non-blocking): 変数名 `d` は意図が不明瞭です

`daysSinceLastLogin` のような説明的な名前に変更することで、コードの意図が
明確になります。対応は任意です。
```

### 原則3: 明確なアウトカム（Focused Outcome）

コメントを受け取った相手が「次に何をすべきか」を明確に理解できるようにする。

**Triple-Rパターン**:
- **Request（依頼）**: 何を変えてほしいかを明確に述べる
- **Rationale（根拠）**: なぜその変更が必要かを説明する
- **Result（期待結果）**: 変更後にどうなることを期待するかを伝える

例:
```
needs change: このクエリにインデックスを追加してください

Request:  email列にデータベースインデックスを追加してください
Rationale: 現在、usersテーブルへのフルスキャンが発生しており、
           ユーザー数が増加すると応答時間が線形増加します
Result:   インデックスを貼ることで、検索がO(n)からO(log n)に改善されます
```

詳細は [references/EFFECTIVE-COMMENTS.md](./references/EFFECTIVE-COMMENTS.md) を参照。

---

## トーンの原則

コードレビューのコメントは内容だけでなく表現の仕方が重要。

**基本原則**:

1. **「あなた」ではなく「私たち」**: 個人への批判ではなく共同作業として表現する
   - ❌ 「あなたはここで例外処理を忘れています」
   - ✅ 「ここで例外が発生した場合の処理を追加できますか？」

2. **命令ではなく質問・提案**: 一方的に命じるのではなく、相手の思考を尊重する
   - ❌ 「この関数を分割してください」
   - ✅ 「この関数を2つに分けると、テストが書きやすくなると思いますが、いかがでしょうか？」

3. **コードへの批判、人への批判は禁止**: 「このコードは読みにくい」はOK。「あなたの書き方は読みにくい」はNG。

4. **コードコンプリメント**: 優れた実装、巧みな解決策、良い命名を見つけたときは積極的に称賛する
   - 「この非同期エラーハンドリング、とてもエレガントです！」
   - 批判だけでなく称賛も伝えることで、健全なレビュー文化が育つ

---

## レビュアーの姿勢

### コードを理解してからコメントする

コードを読み、変更の意図を理解した上でコメントする。文脈なしに「なぜこう書いたか？」と聞くのではなく、まずPRの説明文を読み、コードの全体像を把握してから疑問を提示する。

### ブロッキングとノンブロッキングを明示する

すべてのコメントが同じ優先度ではない。コメントシグナルやMoSCoWを使って、マージを阻止するものとそうでないものを明確に区別する。これにより作者は何から対応すべきかを即座に判断できる。

### レスポンスタイムを守る

レビュー依頼に対して、チームで合意した時間内（例: 営業日1日以内）に応答する。レビューできない場合は、その旨を依頼者に速やかに伝える。

### 指摘は一度にまとめて送る

細切れでコメントを送ることは避ける。最初のレビューで見えたすべての問題を一度に送ることで、修正→再レビューのサイクルを最小化する。

### レビューサイズに配慮する

大きすぎるPRを無言で受け取るのではなく、PRを分割するよう依頼することも重要なレビュアーの役割。サイズが適切なPRはレビューの質を高める。

### ルールではなく原則を理解する

「チームの標準だから」という理由だけでなく、なぜその標準が存在するかを理解した上でフィードバックする。背景を知らない場合は、自信を持ってコメントする前に確認する。

### レビューのスコープを意識する

このPRが「何を変えようとしているか」を念頭に置き、スコープ外の問題はノンブロッキングで伝えるか、別のIssueとして記録する。完璧なコードを求めるのではなく、このPRが既存よりも良い状態でマージできるかを基準にする。

### メンタリングの機会として活用する

`levelup:` コメントを使って、より良い書き方・デザインパターン・ベストプラクティスを共有する。コードレビューは経験の浅いメンバーが成長できる重要な機会。ただし、教育的コメントの量が多すぎると圧倒されるため、1回のレビューで2-3件程度に絞る。

---

## 著者（PR作成者）の姿勢

### 自己レビューを先に行う

PRを提出する前に、自分でコードを読み直す。開発中に見えなかった問題が、後から俯瞰することで見えることがある。コメントシグナルを使って自分でもブロッキング箇所を特定できる。

### PRを小さく保つ

「後でまとめてレビューしてもらう」という発想は避ける。小さな単位で頻繁にPRを出すことで、レビュアーの負荷を下げ、フィードバックサイクルを短くする。

### コンテキストを提供する

レビュアーはコードの文脈を知らない前提でPRを書く。「なぜこの変更が必要か」「なぜこのアプローチを選んだか」を説明文に含める。レビュアーの時間を節約することが、迅速なフィードバックにつながる。

### フィードバックを受け取る準備をする

コードレビューのフィードバックはコードへの改善提案であり、個人への批判ではない。防衛的にならず、まず理解しようとする姿勢を持つ。意見が異なる場合は、根拠を持って反論することは適切。

### 対応状況を明示する

各コメントへの対応状況（修正済み・別案で対応・却下した理由）を明示することで、レビュアーの再確認時間を短縮できる。無視したコメントには理由を添える。

### 設計の問題は早期に相談する

大きな変更を実装しきった後でレビューに出すと、設計の根本的な問題が発覚したとき手戻りが大きくなる。実装開始前にドラフトPRやRFC（Request for Comments）で設計を共有し、方向性の確認を取る。

### 変更の意図とトレードオフを説明する

「なぜこのアプローチを選んだか」「他の選択肢と比較してどの点で優れているか」「既知の制約や妥協点があるか」を説明文に含める。レビュアーがトレードオフを理解した上でフィードバックできるようになる。

---

## 自動化の活用

レビュアーの時間を本質的な判断に集中させるため、機械的にチェックできるものは自動化する。

**レビュー前（Pre-review）**:
- コードフォーマッター（Prettier, gofmt等）で体裁を統一
- Linterでスタイル・潜在的なバグを検出
- 静的解析で型エラー・セキュリティ問題を検出
- 自動テストでリグレッションを防止

**レビュー中（During-review）**:
- PRテンプレートで必要情報の記述を促す
- PR size checkerで大きすぎるPRを警告
- 自動アサインメントでレビュアーを自動指定
- 時間経過リマインダーでレビュー遅延を防止

詳細は [references/REVIEW-PROCESS.md](./references/REVIEW-PROCESS.md) を参照。

---

## ペアプログラミングとの関係

ペアプログラミングやモブプログラミングはコードレビューの代替ではなく、補完的な実践。

| 実践 | 効果 | 限界 |
|------|------|------|
| コードレビュー | 非同期・記録が残る・多様な目線 | リアルタイム対話がない |
| ペアプログラミング | リアルタイムフィードバック・知識転移が速い | 全変更をカバーできない |

**両立の考え方**:
- ペアで実装した変更もコードレビューに通す（第3者の視点を確保）
- 複雑な設計問題はペアまたはモブで解決し、その結果をPRの説明文に記録する
- ペアプログラミングで解決した問題は `levelup:` コメントの代わりに口頭で共有済みという前提で良い

---

## チーム合意（TWA）

チーム内のレビュープロセスに関する暗黙の期待を明文化する文書。以下を定義する:

- レスポンスタイム（レビュー依頼から初回応答まで）
- PRサイズの上限
- 最小承認者数
- ブロッキング・ノンブロッキング判断基準
- 緊急対応手順

**暗黙知を明文化することで得られるもの**:
- 新メンバーのオンボーディング効率が上がる
- 個人の解釈の違いによる摩擦が減る
- 問題が起きたときに「合意」を根拠に対話できる

詳細とテンプレートは [references/TEAM-AGREEMENTS.md](./references/TEAM-AGREEMENTS.md) を参照。

---

## アンチパターンの回避

**代表的なアンチパターン**:

| アンチパターン | 症状 | 対策 |
|-------------|------|------|
| LGTM症候群 | 内容を確認せず即承認 | チェックリスト・最小承認者数 |
| 意地悪レビュー | 批判的・攻撃的なコメント | TWAでトーン基準を定義 |
| 形変えレビュー | 承認後に新たな要求が出る | 指摘の優先度を明示する |
| 過剰厳格 | 完璧主義でいつまでも承認しない | ブロッキング基準を明文化 |
| ボトルネック | 一人のシニアに全依存 | レビュアーローテーション |
| PRの肥大化 | 巨大PRでレビューが滞る | PRサイズ上限をTWAに記載 |

詳細は [references/ANTI-PATTERNS.md](./references/ANTI-PATTERNS.md) を参照。

---

## AIツールとの連携

静的解析ツールやAIコードレビューツールの活用でレビュー効率が向上する。

**AIツールが得意なこと**:
- 構文エラー・型エラー・セキュリティパターンの自動検出
- コーディング規約の一貫したチェック
- PR規模のスケールに関係なく均一な品質でチェック

**AIツールが苦手なこと**:
- ビジネスロジックの正確性の検証
- チームの文脈・過去の意思決定の理解
- 設計の適切さやアーキテクチャの判断
- コミュニケーションのニュアンス

**推奨アプローチ**: AIツールをPre-review自動化（機械的なチェック）に活用し、人間のレビュアーは論理・設計・ビジネスロジックの確認に集中する。AIのコメントは参考情報として活用し、最終的な判断は人間が行う。

---

## サブファイル参照

| 参照先 | 読む場面 |
|--------|---------|
| [references/REVIEW-PROCESS.md](./references/REVIEW-PROCESS.md) | レビューワークフローの設計・自動化・緊急対応 |
| [references/EFFECTIVE-COMMENTS.md](./references/EFFECTIVE-COMMENTS.md) | コメント技法の詳細（5P・MMG・Triple-R・Conventional Comments） |
| [references/TEAM-AGREEMENTS.md](./references/TEAM-AGREEMENTS.md) | TWAの設計とテンプレート |
| [references/ANTI-PATTERNS.md](./references/ANTI-PATTERNS.md) | 問題パターンの診断と対策 |
