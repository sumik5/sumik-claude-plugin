# レビュープロセス・ワークフロー

## PRライフサイクル

### 1. 準備フェーズ（著者）

PRを提出する前に以下を完了する。

**セルフレビューチェックリスト**:
- [ ] コードが意図した動作をすることをローカルで確認した
- [ ] 既存のテストがすべて通る
- [ ] 新機能・バグ修正にはテストを追加した
- [ ] PRのサイズが適切か（20ファイル・500行以内が目安）
- [ ] タイトルと説明文が「何を」「なぜ」を明確に伝えている
- [ ] 自己レビューで明らかな問題を先に修正した

### 2. レビュー依頼フェーズ

**レビュアーの選定基準**:
- コードベースの関連領域に詳しい人
- 最近の変更履歴から自然なレビュアー候補
- チームの合意で定めたローテーション順

**依頼時の注意**:
- レビュアーに直接通知する（自動アサインのみに頼らない）
- 特に確認してほしい箇所があれば明示する
- レビュー期限が明確な場合は伝える

### 3. レビューフェーズ（レビュアー）

**レビューの進め方**:
1. まずPR説明文を読んで変更の背景・意図を把握する
2. 変更ファイルの全体を俯瞰する
3. 重要なロジックを持つファイルから詳細に読む
4. コメントはコメントシグナルとMoSCoWを使って優先度を明示する
5. 1回のレビューサイクルで気づいた指摘はまとめて送る（細切れ送信は避ける）

**レビュー時に確認する観点**:

| 観点 | 確認内容 |
|------|---------|
| 正確性 | ロジックは意図通り動くか？境界値・エッジケースは処理されているか？ |
| セキュリティ | 入力検証、認証・認可、機密情報の扱いは適切か？ |
| パフォーマンス | 不必要なN+1クエリ、大量データ処理時の問題はないか？ |
| 可読性 | 命名は明確か？コードの意図が読めるか？複雑な処理にはコメントがあるか？ |
| テスト | テストは適切なシナリオをカバーしているか？フレージーなテストはないか？ |
| 設計 | SRP・OCP等の設計原則に違反していないか？将来の拡張を阻害しないか？ |
| 互換性 | APIの後方互換性は維持されているか？マイグレーション手順があるか？ |

### 4. 修正・反復フェーズ（著者）

**フィードバック対応のルール**:
- 各コメントに対して対応状況を記録する（修正済み・別案・却下+理由）
- 設計に関する意見の相違は、コード上ではなく同期的なMTGで解決する
- すべてのブロッキングコメントを対応した後、Re-review依頼を出す

### 5. 承認・マージフェーズ

**マージ条件**:
- チームが合意した最小承認者数を満たす（例: 2名以上）
- すべてのブロッキングコメントが対応済み
- CIパイプラインが全通過

---

## プロセス設計

チームのレビュープロセスを構築する際の手順。

### Step 1: ゴールを定義する

レビューで何を達成したいかをチームで合意する。バグ防止・知識共有・コード品質維持など、優先順位をつける。優先すべきゴールによって、プロセスの重点が変わる。

### Step 2: ツールを選定する

- バージョン管理・PRツール（GitHub, GitLab, Bitbucket等）
- 自動化ツール（Linter, フォーマッター, CI/CD）
- コミュニケーションツール（コメント, Slack等）

### Step 3: ガイドラインを策定する

何がブロッキングで何がそうでないか、レスポンスタイム、PRサイズ上限などを明文化する（→ TWAとして文書化する）。

### Step 4: チームで試行する

ガイドラインを試験期間（1-2ヶ月）で適用し、定期的に振り返りを行う。完璧なルールを最初から作ろうとしない。

### Step 5: 継続的に改善する

振り返りの結果をガイドラインに反映し、プロセスを進化させる。定期的な見直しがプロセスを生きたものにする。

---

## 自動化戦略

### レビュー前自動化（Pre-review Automation）

レビュアーが見る前に機械的な問題を排除する。

| 自動化 | ツール例 | 効果 |
|--------|---------|------|
| コードフォーマット | Prettier, gofmt, black | スタイルの一貫性を確保。フォーマット指摘をゼロにする |
| Lint | ESLint, golangci-lint, flake8 | バグになりやすいパターンを事前検出 |
| 型チェック | TypeScript, mypy, go vet | 型エラーをコミット前に検出 |
| 静的解析 | SonarQube, Semgrep | セキュリティ問題・コードスメルを自動検出 |
| テスト自動実行 | CI/CD（GitHub Actions等） | リグレッションをPRマージ前に防止 |
| シークレット検出 | git-secrets, trufflehog | 機密情報のコミットを防止 |

**原則**: 自動化で検出できる問題をレビュアーに見させない。レビュアーの時間は、機械では判断できない問題に集中させる。

### レビュー中自動化（During-review Automation）

レビュープロセス自体を補助する。

| 自動化 | 内容 |
|--------|------|
| PRテンプレート | 必要情報の記述を促す定型フォーム |
| サイズチェッカー | 大きすぎるPRに自動コメント・警告 |
| レビュアー自動アサイン | CODEOWNERSや round-robin で自動指定 |
| CIゲート | テスト・Lintが通らないとマージを禁止 |
| リマインダー | 一定時間（例: 24時間）レビューがないと通知 |
| エスカレーション | 長期放置PRをチームリードに通知 |

**導入優先順位**:
1. フォーマッター + Lint（即効性が高い）
2. CI自動テスト（品質の下限を保証）
3. PRテンプレート（レビュー効率を上げる）
4. サイズチェッカー + リマインダー（プロセス問題を可視化）

---

## 緊急対応プレイブック

プロセスをスキップしてマージが必要な「緊急事態」への対応手順。

### 緊急事態の定義

以下のすべてを満たす場合のみ緊急と判断する:

- 本番システムに影響するインシデントが発生している、または48時間以内に発生する
- この変更なしには問題を解決できない
- 通常のレビュープロセスを待つ時間的余裕がない

**重要**: 「急いでいる」「期限が近い」だけでは緊急の定義を満たさない。

### 緊急対応手順

1. **判断**: 上記の緊急定義に照らし合わせる
2. **承認**: チームリードまたは権限者の口頭・Slack承認を得る
3. **最小限の変更**: 問題解決に必要な最小限のコードのみ変更する
4. **マージ**: 通常プロセスをスキップしてマージ
5. **事後レビュー**: マージ後24時間以内に通常のレビューを実施する
6. **記録**: EPER（緊急手順実行記録）を残す

### EPER（Emergency Procedure Execution Record）

緊急対応を行った際は、必ず以下の情報を記録する:

```markdown
# 緊急対応記録 (EPER)

日時: YYYY-MM-DD HH:MM
判断者: [名前]
承認者: [名前]
PR番号: #XXX

## 緊急と判断した理由
<!-- 上記3条件のどれに該当したか -->

## 変更の内容要約
<!-- 何を変更したか（1-3文） -->

## 事後レビュー
予定日: YYYY-MM-DD
実施日: YYYY-MM-DD（実施後に記入）
レビュア: [名前]
```

### 緊急プロセスの乱用防止

- 緊急対応の実施回数を月次でチームに報告する
- 月に一定回数を超えたらプロセスの問題を調査する
- 「緊急」に使える承認権限者を事前に限定する（TWAに記載）
- 事後レビューを必ず実施し、未実施のケースをトラッキングする
