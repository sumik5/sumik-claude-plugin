# コンピューティングパターン

## コンテナベースのSaaS

### コンテナとSaaSの相性
- プログラミングモデルの互換性（既存コードの移行容易）
- 動的スケーリング（Pod/ノードの柔軟な追加・削除）
- 豊富なデプロイツール（Helm, Argo, Flux等）
- Namespace等のグルーピング構造
- コミュニティ主導の活発なエコシステム

### デプロイパターン
| パターン | 構造 | 適用場面 |
|---------|------|---------|
| プールデプロイ | 共有Namespace、全テナントが同一Pod | コスト効率重視 |
| サイロデプロイ | テナントごとのNamespace | 分離要件、ノイジーネイバー対策 |
| 混合デプロイ | ティア別にプール/サイロ | ティアリング対応 |

### ルーティング
- Ingress Controller / API Gatewayによるテナントルーティング
- テナントコンテキストに基づくPod/Namespace振り分け

### オンボーディングとデプロイ自動化
- Helmチャートによるテナントリソースの定義
- GitOps（Argo CD, Flux）による継続的デプロイ
- テナントを意識したCI/CDパイプライン

### テナント分離（コンテナ環境）
- Namespace + NetworkPolicyによるネットワーク分離
- RBAC（ロールベースアクセス制御）
- サービスアカウントによるリソースアクセス制限
- サイドカーによる分離ポリシー注入

### ノードタイプの最適化
- テナントワークロードに応じたインスタンスタイプの選択
- ノードアフィニティ/テイントによるPod配置制御
- コスト最適化（スポットインスタンス等の活用）

## サーバーレスSaaS

### サーバーレスとSaaSの相性
- テナントアクティビティとインフラ使用量の自然な一致
- スケーリングポリシー不要（マネージドサービスが制御）
- 従量課金（アイドル時コストゼロ）
- きめ細かいデプロイ単位（関数単位）
- テナント別使用量の帰属が容易

### デプロイパターン
| パターン | 構造 | 適用場面 |
|---------|------|---------|
| プールデプロイ | 共有関数、テナントコンテキストで分岐 | コスト効率最大 |
| サイロデプロイ | テナントごとの関数セット | 分離、ティアリング |
| 混合デプロイ | ティア別にプール/サイロ | 階層型体験 |

### テナント分離（サーバーレス環境）
- 動的注入によるプール分離
  - リクエストごとにスコープ付きクレデンシャルを生成
  - テナントコンテキストに基づくリソースアクセス制限
- デプロイ時の分離
  - テナントごとの関数 + リソースポリシー

### 同時実行数とノイジーネイバー
- 予約済み同時実行数（Reserved Concurrency）による制御
- ティア別の同時実行数割り当て
- テナント単位のスロットリング

## コンピューティング選択の指針

| 考慮事項 | コンテナ | サーバーレス |
|---------|---------|------------|
| スケーリング制御 | ポリシーベース（自己管理） | マネージド（自動） |
| コスト効率 | 中〜高（最適化次第） | 高（従量課金） |
| デプロイ粒度 | Pod/コンテナ単位 | 関数単位 |
| 長時間処理 | ◎ 得意 | △ 制約あり |
| テナント分離 | Namespace/RBAC | IAMポリシー/動的注入 |
| 運用負荷 | 中（クラスター管理） | 低（マネージド） |
| エコシステム | 成熟、豊富なツール | 成長中 |

- 0か100かではなく、ワークロードに最適な組み合わせを選択
- サーバーレスが全体に適用できない場合、一部のみ採用も有効
