# オンボーディングとアイデンティティ

## ベースライン環境の構築

テナントオンボーディングを開始する前に、SaaS環境全体の基盤を整備する必要があります。これを「ベースライン環境」と呼びます。

### ベースライン環境に含まれるもの

| コンポーネント | 説明 | 目的 |
|--------------|------|------|
| **ネットワークインフラ** | 仮想ネットワーク、サブネット、ルーティング | セキュアな通信基盤 |
| **コントロールプレーン** | テナント管理、アイデンティティ、メトリクス、請求 | SaaS基盤サービス |
| **プール化リソース** | 共有アプリケーションサーバー、データベース | 初期テナント受け入れ準備 |
| **システム管理者アイデンティティ** | SaaS運用者のアカウント | 環境管理 |
| **管理コンソール** | シングルペインオブグラス | 統一された管理画面 |
| **監視・ロギング** | メトリクス収集、ログ集約 | 可観測性 |

### Infrastructure as Code（IaC）による構築

ベースライン環境は、DevOpsツールによって完全に自動化・再現可能な形で構築してください。

**推奨ツール:**
- Terraform
- Pulumi
- CloudFormation（AWS）
- ARM Templates（Azure）
- Kubernetes Operator

**重要な原則:**
- 手動での構築は禁止
- すべての構成をコードで管理
- 環境の完全な再現が可能
- バージョン管理でインフラの変更を追跡

### ベースライン環境のデプロイフロー

```
[IaCコード]
    ↓
[自動デプロイパイプライン]
    ↓
[ネットワーク構築]
    ↓
[コントロールプレーンデプロイ]
    ↓
[プール化リソースプロビジョニング]
    ↓
[管理コンソールセットアップ]
    ↓
[ベースライン環境完成]
```

## オンボーディング体験

### 基本原則

オンボーディングはSaaSの最初の一歩であり、顧客の第一印象を決定します。以下の原則を守ってください:

1. **サービスの一部として設計**
   - オンボーディングは付加的機能ではなく、SaaSの核心
   - 製品体験の延長として設計

2. **摩擦のない体験**
   - 最小限のステップ
   - 明確なガイダンス
   - 自動化された設定

3. **包括的な初期化**
   - テナント + ユーザー + アイデンティティ + アプリケーションリソースを一括で結びつける

### オンボーディングフローの要素

```
[テナント登録]
    ↓
[1. テナント作成]
   - 一意のテナントID割り当て
   - テナントメタデータ保存
    ↓
[2. テナント管理者ユーザー作成]
   - 初回ユーザーアカウント作成
   - 管理者権限付与
    ↓
[3. アイデンティティプロバイダー設定]
   - テナント用認証設定
   - JWT設定
    ↓
[4. テナントティア設定]
   - 選択されたティア（Free/Standard/Premium等）
   - 機能フラグ設定
    ↓
[5. アプリケーションリソースのプロビジョニング]
   - ティアに応じたリソース割り当て
   - データベース、ストレージ、コンピューティング
    ↓
[6. オンボーディング状態の追跡]
   - 進捗状況の可視化
   - エラーハンドリング
    ↓
[完了通知]
```

### セルフサービス vs 内部オンボーディング

| 方式 | 適用場面 | 特徴 |
|------|---------|------|
| **セルフサービス** | 低摩擦、大量テナント、フリーティア | ユーザーが自分で登録、即座に開始可能 |
| **内部オンボーディング** | エンタープライズ、カスタム設定、高ティア | 営業・CSチームが関与、カスタム構成 |

**セルフサービスの設計ポイント:**
- クレジットカード不要のトライアル
- 即座にアクセス可能
- プリセット構成
- ガイド付きツアー

**内部オンボーディングの設計ポイント:**
- 営業チーム向け管理コンソール
- カスタム構成オプション
- SLA設定
- カスタムドメイン設定

### ティアベースのオンボーディング

ティアに応じて異なるリソースとエクスペリエンスを提供します。

**例: 3ティアシステム**

| ティア | プロビジョニング内容 | オンボーディング方式 |
|--------|-------------------|-------------------|
| **Free** | プール化リソースのみ、機能制限あり | セルフサービス、即座に開始 |
| **Standard** | プール化リソース + 専用ストレージ | セルフサービス、5分以内に完了 |
| **Premium** | フルスタック・サイロ、すべての機能 | 内部オンボーディング、カスタム構成 |

**プロビジョニングロジック:**
```
[ティア判定]
    ↓
[Free] → 既存プールへのアクセス追加のみ
[Standard] → 専用DBプロビジョニング + プール接続
[Premium] → フルスタックインフラ構築（IaC実行）
```

### オンボーディング自動化パイプライン

```
[オンボーディングリクエスト]
    ↓
[テナント管理サービス]
   - テナント情報保存
   - テナントID生成
    ↓
[ティア判定エンジン]
    ↓
[プロビジョニングオーケストレーター]
   ├─ [コンピューティングプロビジョニング]
   ├─ [ストレージプロビジョニング]
   ├─ [ネットワーク構成]
   └─ [アイデンティティ設定]
    ↓
[ヘルスチェック]
    ↓
[完了通知 / エラーハンドリング]
```

### 障害対応とリトライ

オンボーディングは複雑なオーケストレーションであり、部分的な障害が発生する可能性があります。

**冪等性の確保:**
- 同じリクエストを複数回実行しても安全
- リソース作成前に存在チェック
- 一意性制約の活用

**ロールバック戦略:**
```
[オンボーディング開始]
    ↓
[ステップ1成功] → 進行
    ↓
[ステップ2失敗] → ロールバック開始
    ↓
[ステップ1のリソースを削除]
    ↓
[テナント状態を"失敗"に設定]
    ↓
[通知とログ]
```

**リトライポリシー:**
- 一時的な障害（ネットワーク、サービス一時停止等）は自動リトライ
- エクスポネンシャルバックオフ
- 最大リトライ回数の設定
- 永続的な障害（設定エラー等）は人間の介入が必要

### オンボーディング状態の追跡

**状態遷移:**
```
[PENDING] → オンボーディングリクエスト受付
    ↓
[PROVISIONING] → リソースプロビジョニング中
    ↓
[CONFIGURING] → 構成設定中
    ↓
[ACTIVE] → オンボーディング完了、利用可能
    ↓
[FAILED] → オンボーディング失敗
```

**可視化:**
- 管理コンソールでリアルタイム進捗表示
- 各ステップの完了状況
- エラーメッセージとトラブルシューティングガイド

## SaaSアイデンティティ

### テナントコンテキストの注入

SaaSアイデンティティの核心は、すべてのリクエストにテナントコンテキストを含めることです。

**JWTカスタムクレームの構造:**
```json
{
  "sub": "user-id-12345",
  "email": "user@example.com",
  "tenantId": "tenant-abc-123",
  "tier": "premium",
  "role": "admin",
  "features": ["feature-a", "feature-b"],
  "iat": 1609459200,
  "exp": 1609462800
}
```

**重要なクレーム:**

| クレーム | 説明 | 用途 |
|---------|------|------|
| `tenantId` | テナントの一意識別子 | データフィルタリング、分離 |
| `tier` | テナントティア | 機能制限、レート制限 |
| `role` | ユーザーロール | 認可、権限チェック |
| `features` | 有効な機能フラグ | 機能アクセス制御 |

**バックエンドでの活用:**
```typescript
// すべてのAPIリクエストでテナントコンテキストを取得
function getTenantContext(request): TenantContext {
  const token = extractJWT(request);
  const decoded = verifyAndDecode(token);
  return {
    tenantId: decoded.tenantId,
    tier: decoded.tier,
    role: decoded.role,
    features: decoded.features
  };
}

// データクエリ時に自動的にテナントフィルタを適用
function getOrders(tenantContext: TenantContext) {
  return db.query(
    "SELECT * FROM orders WHERE tenant_id = ?",
    [tenantContext.tenantId]
  );
}
```

### アイデンティティプロバイダー構成

SaaSでは、テナントの要件に応じて異なるアイデンティティプロバイダー構成を選択できます。

#### 1. 共有プール構成

**概要:**
- すべてのテナントが1つのアイデンティティプロバイダープールを共有
- テナント情報はカスタムクレームで区別

**適用場面:**
- シンプルなSaaS（SMB向け）
- セルフサービスオンボーディング
- 標準的な認証要件

**例（Cognito）:**
```
[Cognito User Pool]
  └─ すべてのテナントのユーザー
     ├─ user1@tenantA.com (tenantId: A)
     ├─ user2@tenantA.com (tenantId: A)
     ├─ user1@tenantB.com (tenantId: B)
     └─ user2@tenantB.com (tenantId: B)
```

#### 2. テナントごとのプール構成

**概要:**
- テナントごとに独立したユーザープールまたはグループ
- テナント分離が明確

**適用場面:**
- カスタム認証要件
- テナントごとに異なるパスワードポリシー
- 一部のテナントがフェデレーション要件

**例（Cognito）:**
```
[Cognito User Pool A] → TenantA
[Cognito User Pool B] → TenantB
[Cognito User Pool C] → TenantC
```

#### 3. 外部フェデレーション構成

**概要:**
- テナントが独自のIdP（SAML、OIDC）を使用
- SaaSはフェデレーション接続のみ

**適用場面:**
- エンタープライズテナント
- 既存のActive Directory、Okta、Auth0等との統合
- SSO（Single Sign-On）要件

**フロー:**
```
[ユーザー] → [SaaS] → [テナントのIdP（例: Okta）]
    ↓ SAML Assertion
[SaaS] → テナントコンテキスト注入 → [JWTトークン発行]
```

### テナントコンテキストとセキュリティ

**重要な原則:**
- **テナント認証 ≠ テナント分離**
- 認証はアクセス権の確認
- 分離はリソースアクセスの防止
- 両方が必要

**例: テナント分離の実装**

**✅ 正しい実装:**
```typescript
// JWTからテナントIDを取得
const tenantId = getTenantIdFromJWT(request);

// データベースクエリでテナントIDをフィルタ
const orders = await db.query(
  "SELECT * FROM orders WHERE tenant_id = ?",
  [tenantId]
);
```

**❌ 間違った実装:**
```typescript
// リクエストパラメータからテナントIDを取得（改ざん可能）
const tenantId = request.params.tenantId;

// テナントフィルタなしでクエリ（すべてのテナントのデータが漏洩）
const orders = await db.query("SELECT * FROM orders");
```

**セキュリティのベストプラクティス:**
- テナントコンテキストは常にJWTから取得
- すべてのデータクエリにテナントフィルタを適用
- Row-Level Security（RLS）をデータベースレベルで実装
- テナントコンテキストの改ざん防止
- 定期的なセキュリティ監査

## テナント管理

### テナント管理サービスの責務

テナント管理サービスは、コントロールプレーンの中核です。

**主要な機能:**

| 機能 | 説明 |
|------|------|
| **テナントCRUD** | テナントの作成、読み取り、更新、削除 |
| **構成管理** | ティア、機能フラグ、リソース制限の保存 |
| **状態管理** | アクティブ/無効/廃止状態の管理 |
| **メタデータ保存** | テナント名、連絡先、カスタムドメイン等 |
| **検索・フィルタ** | 管理コンソールでのテナント検索 |

**データモデル例:**
```json
{
  "tenantId": "tenant-abc-123",
  "name": "Acme Corporation",
  "tier": "premium",
  "status": "active",
  "createdAt": "2024-01-01T00:00:00Z",
  "config": {
    "customDomain": "acme.example.com",
    "features": ["advanced-analytics", "api-access"],
    "limits": {
      "maxUsers": 100,
      "maxStorage": "1TB",
      "apiRateLimit": 10000
    }
  },
  "deploymentModel": "full-stack-silo",
  "resources": {
    "computeEndpoint": "https://tenant-abc-123.compute.example.com",
    "databaseId": "db-tenant-abc-123"
  }
}
```

### テナントライフサイクル管理

#### 有効化/無効化

**有効化:**
- テナントを即座にアクティブ化
- すべてのリソースへのアクセスを許可

**無効化:**
- 一時的な停止（例: 支払い遅延）
- リソースは保持（再有効化可能）
- アクセス拒否（認証時にチェック）

**実装:**
```typescript
function authenticateUser(credentials) {
  const user = verifyCredentials(credentials);
  const tenant = getTenant(user.tenantId);

  if (tenant.status !== 'active') {
    throw new Error('Tenant is not active');
  }

  return generateJWT(user, tenant);
}
```

#### 廃止（Decommission）

テナント廃止は慎重に計画する必要があります。

**考慮事項:**

| 項目 | 説明 |
|------|------|
| **データ保持期間** | 法規制・契約に基づく保持期間（例: 90日間） |
| **データエクスポート** | テナントがデータをダウンロード可能にする |
| **リソース解放** | コンピューティング、ストレージの削除 |
| **アイデンティティクリーンアップ** | ユーザーアカウントの削除 |
| **請求の最終処理** | 未払い料金の清算 |
| **監査ログ保持** | セキュリティ・コンプライアンス目的で一定期間保持 |

**廃止フロー:**
```
[廃止リクエスト]
    ↓
[テナント状態を"DECOMMISSIONING"に設定]
    ↓
[アクセス無効化]
    ↓
[データエクスポート提供]
    ↓
[保持期間待機（例: 90日）]
    ↓
[データ削除]
    ↓
[リソース解放]
    ↓
[テナント状態を"DECOMMISSIONED"に設定]
```

#### ティア切り替え

テナントティアの変更は、リソースの動的再配置を伴います。

**アップグレード（例: Standard → Premium）:**
```
[ティア変更リクエスト]
    ↓
[新しいサイロリソースのプロビジョニング]
    ↓
[データ移行（プールからサイロへ）]
    ↓
[ルーティング切り替え]
    ↓
[旧リソースの解放]
    ↓
[テナント構成更新]
```

**ダウングレード（例: Premium → Standard）:**
```
[ティア変更リクエスト]
    ↓
[データ移行（サイロからプールへ）]
    ↓
[ルーティング切り替え]
    ↓
[サイロリソースの解放]
    ↓
[テナント構成更新]
```

**考慮事項:**
- ダウンタイム最小化
- データ整合性の保証
- ロールバック戦略
- テナントへの事前通知

## テナント認証とルーティング

### アクセスモデル

SaaSでは、テナントを識別するためのアクセスモデルを選択する必要があります。

#### 1. テナントサブドメインモデル

**構造:**
- `tenant1.app.com`
- `tenant2.app.com`
- `tenant3.app.com`

**利点:**
- テナント識別が容易（URLから直接判定）
- DNS設定で自動ルーティング
- ブラウザのクッキー分離が自然

**実装:**
```typescript
function extractTenantFromSubdomain(hostname: string): string {
  const parts = hostname.split('.');
  if (parts.length < 3) {
    throw new Error('Invalid subdomain');
  }
  return parts[0]; // "tenant1" from "tenant1.app.com"
}
```

#### 2. カスタムドメインモデル

**構造:**
- `tenant1.com`
- `tenant2.com`
- `tenant3.com`

**利点:**
- ブランディング対応
- ホワイトラベルSaaS
- エンタープライズテナントの要求に対応

**実装:**
- カスタムドメインとテナントIDのマッピングテーブル
- SSL証明書の動的生成（例: Let's Encrypt）
- DNS設定（CNAME）

#### 3. 単一ドメインモデル

**構造:**
- すべてのテナントが `app.com` を使用
- ログイン時にテナント識別子を入力

**利点:**
- シンプルなDNS設定
- SSL証明書管理が容易

**実装:**
```typescript
// ログイン画面でテナント識別子を入力
function login(tenantIdentifier: string, email: string, password: string) {
  const tenant = findTenantByIdentifier(tenantIdentifier);
  const user = authenticateUser(tenant, email, password);
  return generateJWT(user, tenant);
}
```

### 認証フローの実装

#### テナントサブドメインベースの認証

```
[1. ユーザーがアクセス]
   URL: tenant1.app.com
    ↓
[2. サブドメインからテナント特定]
   tenantId: "tenant-abc-123"
    ↓
[3. テナントのIdP設定取得]
   idpType: "cognito" / "saml" / "oidc"
    ↓
[4. 対応するIdPで認証]
    ↓
[5. JWTにテナントコンテキスト注入]
   {
     "tenantId": "tenant-abc-123",
     "tier": "premium",
     "role": "admin"
   }
    ↓
[6. JWTトークン発行]
```

#### カスタムドメインベースの認証

```
[1. ユーザーがアクセス]
   URL: tenant1.com
    ↓
[2. カスタムドメインからテナント特定]
   SELECT tenantId FROM domain_mappings WHERE domain = 'tenant1.com'
    ↓
[3. テナントのIdP設定取得]
    ↓
[4-6. 上記と同様]
```

### ルーティング戦略

ルーティングは、テナントコンテキストに基づいて適切なリソースにリクエストを転送します。

#### プール環境のルーティング

```
[API Gateway]
    ↓
[JWTからテナントID取得]
    ↓
[共通アプリケーションサーバーへルーティング]
    ↓
[アプリケーション層でテナントフィルタ適用]
```

#### サイロ環境のルーティング

```
[API Gateway]
    ↓
[JWTからテナントID取得]
    ↓
[テナントマッピングテーブル参照]
   tenantId → computeEndpoint
    ↓
[テナント専用サーバーへルーティング]
   例: https://tenant-abc-123.compute.internal
```

#### 混合環境のルーティング

```
[API Gateway]
    ↓
[JWTからテナントID取得]
    ↓
[テナント構成取得]
   tier: "premium" / "standard" / "free"
    ↓
[ティアに応じてルーティング先を分岐]
   ├─ premium → サイロ環境
   ├─ standard → ハイブリッド環境
   └─ free → プール環境
```

### ルーティングテーブルの管理

**データモデル例:**
```json
{
  "tenantId": "tenant-abc-123",
  "tier": "premium",
  "routes": {
    "api": "https://tenant-abc-123-api.internal",
    "database": "db-tenant-abc-123.rds.amazonaws.com",
    "storage": "s3://tenant-abc-123-bucket"
  }
}
```

**動的ルーティング:**
- ルーティングテーブルはキャッシュ（Redis等）
- テナント構成変更時にキャッシュ無効化
- フォールバック戦略（キャッシュミス時）

## まとめ

### オンボーディングの成功要因

- 完全な自動化
- 冪等性とエラーハンドリング
- ティアベースのプロビジョニング
- 状態追跡と可視化

### アイデンティティの成功要因

- テナントコンテキストの一貫した注入
- 認証と分離の両方を実装
- フェデレーション対応（エンタープライズ向け）
- セキュリティの多層防御

### テナント管理の成功要因

- 包括的なライフサイクル管理
- データ駆動のティア切り替え
- 柔軟なルーティング戦略
- 統一された管理コンソール
