# マルチテナントサービスの設計

## 従来のサービス設計との違い

### 単一顧客専用から複数テナント共有へ
- **単一顧客専用**: 特定の顧客のためにカスタマイズされたリソースとコンフィギュレーション
- **複数テナント共有**: 複数の顧客が同じリソースとサービスを共有
- 各テナントは独立したエンティティとして扱われる必要がある

### テナントのワークロードは予測不可能
- 各テナントの利用パターンは大きく異なる
- ピーク時間帯の違い
- リソース消費量の差
- 機能利用の偏り
- 成長速度の差異

### ノイジーネイバー問題の考慮が必須
- 特定テナントの過剰なリソース使用が他のテナントに影響
- パフォーマンスの低下
- 可用性の低下
- コストの増加
- 分離とスロットリングによる対策が必要

### テナントのオンボーディングが随時発生
- 新規テナントの追加が頻繁に発生
- 自動化されたプロビジョニングが必要
- スケーラブルなアーキテクチャが必須
- テナント間の干渉を最小化

---

## サービス分割の考慮事項

### ノイジーネイバーへの対応

#### 特定テナントによるリソース飽和の検出と防止
- リアルタイムモニタリング
- テナント別のリソース使用量追跡
- 異常検出アルゴリズム
- アラートと自動対応

#### スロットリング（流量制限）の適用
- テナント別のレート制限
- ティアベースの制限値
- バースト許容量の設定
- 優先度ベースのキューイング

#### サービスの一部をサイロ化する判断基準

| 条件 | サイロ化推奨度 | 理由 |
|------|-------------|------|
| 高スループット要件 | ◎ | 他テナントへの影響を回避 |
| テナント間のワークロード差が大 | ◎ | リソースの最適化 |
| コンプライアンス要件 | ◎ | データ分離の保証 |
| 厳格なSLA | ◎ | パフォーマンス保証 |
| 均一なワークロード | △ | プールで十分 |
| 小規模テナント | △ | コスト効率を優先 |

---

### コンピューティング技術の影響

#### コンテナ: Pod/Namespace単位での分離可能
- **Pod単位**: テナント専用のPodを起動
- **Namespace単位**: テナントごとのNamespaceで論理的分離
- リソースクォータの適用
- ネットワークポリシーによる分離

#### サーバーレス: 関数単位のきめ細かいデプロイ
- 関数ごとの独立したスケーリング
- コールドスタートの考慮
- 同時実行数の制御
- テナント別の関数バージョン

#### 技術選択がサービス分割粒度に影響
- モノリシック vs マイクロサービス
- コンテナ vs サーバーレス
- 同期 vs 非同期処理
- 分散トランザクションの考慮

---

## マルチテナントサービスの内部構造

### テナントコンテキストの抽出

#### 1. リクエスト受信（JWT付き）
```
HTTP Request
└─ Authorization: Bearer <JWT>
```

#### 2. JWTからテナント情報を抽出
```json
{
  "tenantId": "tenant-12345",
  "tier": "premium",
  "userId": "user-67890",
  "permissions": ["read", "write"],
  "exp": 1234567890
}
```

#### 3. テナントコンテキストオブジェクトを生成
```typescript
interface TenantContext {
  tenantId: string;
  tier: string;
  userId: string;
  permissions: string[];
  metadata?: Record<string, unknown>;
}
```

#### 4. 以降の処理でテナントコンテキストを伝播
- リクエストスコープでのコンテキスト保持
- 非同期処理への伝播
- マイクロサービス間の伝播（ヘッダー経由）
- ログへの自動付与

---

### テナントコンテキストを用いたログとメトリクス

#### 全ログにtenantIdを含める
```json
{
  "timestamp": "2025-01-01T12:00:00Z",
  "level": "INFO",
  "tenantId": "tenant-12345",
  "userId": "user-67890",
  "message": "Order created successfully",
  "orderId": "order-999"
}
```

#### テナント別のAPI呼び出し数、レイテンシー、エラー率を計測
- **API呼び出し数**: テナント別の総リクエスト数
- **レイテンシー**: P50, P95, P99のテナント別分布
- **エラー率**: テナント別の4xx/5xxエラーの割合
- **スループット**: テナント別のRPS（Requests Per Second）

#### テナント別のリソース使用量を追跡
- CPU使用率
- メモリ使用量
- ストレージ使用量
- ネットワーク帯域
- データベース接続数

#### ティアベースのメトリクス集約
- Freeティア全体のメトリクス
- Premiumティア全体のメトリクス
- Enterpriseティア全体のメトリクス
- ティア間の比較分析

---

### テナントコンテキストを用いたデータアクセス

#### テナントIDに基づくデータフィルタリング
```sql
SELECT * FROM orders
WHERE tenant_id = :tenantId
  AND status = 'pending';
```

#### ティアベースのテーブル/コレクション名生成
```typescript
function getTableName(tenantContext: TenantContext): string {
  if (tenantContext.tier === 'enterprise') {
    return `orders_${tenantContext.tenantId}`;
  }
  return 'orders_pool';
}
```

#### テナントスコープ付きクエリの自動適用
- ORMレベルでのテナントフィルター自動付与
- クエリビルダーへのテナントコンテキスト注入
- テナント境界を越えるクエリの防止
- 監査ログへの記録

---

### テナント分離のサポート

#### サービスコード内での分離ポリシー適用
```typescript
async function getOrder(orderId: string, tenantContext: TenantContext) {
  // 分離ポリシーの適用
  const credentials = await getScopedCredentials(tenantContext);

  // テナントスコープ付きでデータ取得
  const order = await database.getOrder(orderId, {
    tenantId: tenantContext.tenantId,
    credentials
  });

  return order;
}
```

#### テナントコンテキストに基づくリソースアクセス制限
- IAMロールの動的生成
- スコープ付き一時クレデンシャル
- リソースタグによるフィルタリング
- ポリシー条件の評価

#### 開発者がテナント境界を意図せず越えることを防止
- 型システムによる強制
- テナントコンテキストの必須化
- コードレビューチェックリスト
- 自動テストによる検証

---

## マルチテナント詳細の隠蔽と一元化

### 隠蔽の原則

#### サービス開発者がマルチテナントの詳細を意識しなくて済む設計
- 透過的なテナントコンテキスト管理
- 自動的な分離ポリシー適用
- 明示的なテナント処理の最小化
- 標準的なAPIパターン

#### 共通ライブラリ/フレームワークにマルチテナントロジックを集約
```typescript
// 開発者が書くコード（シンプル）
@TenantScoped
async function createOrder(data: OrderData) {
  return await orderRepository.create(data);
}

// フレームワークが自動的に行う処理
// - テナントコンテキストの取得
// - テナントIDの付与
// - 分離ポリシーの適用
// - ログへのテナント情報付与
```

#### テナントコンテキスト管理、分離、ログ、メトリクスをヘルパーに
- `TenantContextManager`: コンテキスト管理
- `IsolationEnforcer`: 分離ポリシー適用
- `TenantLogger`: テナント情報付きログ
- `TenantMetrics`: テナント別メトリクス

---

### 一元化のメリット

#### 一箇所の修正で全サービスに反映
- 分離ロジックの変更が容易
- テナントコンテキスト構造の変更に対応
- ログフォーマットの統一
- メトリクス収集方法の標準化

#### セキュリティポリシーの一貫した適用
- 全サービスで同じ分離メカニズム
- ポリシー違反の検出
- 監査ログの統一
- コンプライアンス要件への対応

#### 開発者体験の向上
- マルチテナントの複雑性を隠蔽
- 学習コストの削減
- 生産性の向上
- バグの減少

---

## 傍受ツールと戦略

| 手法 | 特徴 | 適用場面 | 実装例 |
|------|------|---------|--------|
| **アスペクト指向** | 横断的関心事の注入 | テナントコンテキスト、ログ | Java AOP, TypeScript Decorators |
| **サイドカー** | プロセス外の付随コンテナ | コンテナ環境での分離 | Istio, Linkerd |
| **ミドルウェア** | リクエストパイプラインへの挿入 | Webフレームワーク | Express middleware, Spring interceptors |
| **関数レイヤー/Extensions** | サーバーレス関数への拡張 | サーバーレス環境 | AWS Lambda Layers, Azure Functions Extensions |

### アスペクト指向の例
```typescript
// デコレーターによる自動的なテナントコンテキスト注入
@TenantScoped
@LogWithTenant
@MetricsWithTenant
async function processOrder(orderId: string) {
  // ビジネスロジックのみに集中
  const order = await orderService.get(orderId);
  return order.process();
}
```

### サイドカーの例
```yaml
# Kubernetes Pod定義
spec:
  containers:
  - name: app
    image: order-service:latest
  - name: tenant-proxy
    image: tenant-sidecar:latest
    # テナントコンテキスト抽出
    # 分離ポリシー適用
    # ログとメトリクス収集
```

### ミドルウェアの例
```typescript
// Express middleware
app.use(extractTenantContext);
app.use(enforceTenantIsolation);
app.use(logWithTenant);

app.get('/orders', async (req, res) => {
  // req.tenantContext が自動的に利用可能
  const orders = await getOrders(req.tenantContext);
  res.json(orders);
});
```

### 関数レイヤーの例
```typescript
// AWS Lambda Layer
// レイヤーが自動的に以下を実行:
// 1. イベントからJWTを抽出
// 2. テナントコンテキストを生成
// 3. 環境変数に設定
// 4. 関数ハンドラーを呼び出し

export const handler = async (event: APIGatewayEvent) => {
  // process.env.TENANT_ID が自動的に設定されている
  const tenantId = process.env.TENANT_ID;
  // ビジネスロジック
};
```

---

## サービス分割の実践例

### モノリシックアプローチ
- 単一のサービスで全テナントを処理
- シンプルな運用
- スケーリングの限界
- ノイジーネイバー問題のリスク

### マイクロサービスアプローチ
- 機能別にサービスを分割
- 独立したスケーリング
- テナントコンテキストの伝播が必要
- 分散トランザクションの考慮

### ハイブリッドアプローチ
- 重要な機能はサイロ化
- その他はプール化
- ティアベースのルーティング
- 柔軟な最適化

---

## パフォーマンスとスケーラビリティ

### テナント別のパフォーマンス監視
- レイテンシーの追跡
- スループットの測定
- エラー率の監視
- リソース使用量の追跡

### 自動スケーリング戦略
- テナント数に基づくスケーリング
- ワークロード予測
- プリウォーミング
- スケールイン/アウトの最適化

### キャッシュ戦略
- テナント別のキャッシュ
- 共有キャッシュとテナントキャッシュの使い分け
- キャッシュ無効化戦略
- キャッシュ容量の管理

---

## セキュリティの考慮事項

### 認証と認可
- テナント別のユーザー管理
- ロールベースアクセス制御（RBAC）
- テナント境界を越えた認可の防止
- トークンのスコープ管理

### データ暗号化
- 保存時の暗号化
- 転送時の暗号化
- テナント別の暗号化キー
- キーローテーション

### 監査ログ
- 全アクセスの記録
- テナント情報の付与
- 異常アクセスの検出
- コンプライアンスレポート

---

## テスト戦略

### ユニットテスト
- テナントコンテキストのモック
- 分離ロジックのテスト
- エッジケースの検証

### 統合テスト
- マルチテナント環境でのテスト
- テナント間の分離検証
- パフォーマンステスト

### カオステスト
- ノイジーネイバーのシミュレーション
- 障害時の影響範囲確認
- リカバリー手順の検証
