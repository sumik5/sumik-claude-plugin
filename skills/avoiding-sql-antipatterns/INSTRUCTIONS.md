# SQLアンチパターン回避ガイド

データベース設計・クエリ構築・アプリケーション開発における一般的な落とし穴を識別し、予防するための実践的ガイド。25の具体的なアンチパターンとその解決策を提供します。

## 使用タイミング

以下の状況でこのスキルを参照してください：

- **データベーススキーマ設計時**: 新しいテーブル構造を設計する際
- **SQLクエリ作成時**: SELECT/INSERT/UPDATE/DELETE文を記述する際
- **データモデルレビュー時**: 既存のER図やスキーマを評価する際
- **パフォーマンス問題調査時**: スロークエリや非効率なデータアクセスパターンの特定時
- **マイグレーション計画時**: データベース構造の変更や正規化を検討する際
- **コードレビュー時**: データベースアクセスコードをレビューする際

**注意**: このスキルはデータベース設計とSQL固有の問題を扱います。アプリケーションレベルのセキュリティ（入力検証、XSS対策、OWASP Top 10）については `securing-code` スキルを参照してください。

## ユーザー確認の原則（AskUserQuestion）

データベース設計には複数の正解が存在する場合があります。以下の状況では**必ずAskUserQuestionツールでユーザーに確認**してください：

### 1. パフォーマンスとデータ整合性のトレードオフ

```python
AskUserQuestion(
    questions=[{
        "question": "このケースでは非正規化によるパフォーマンス最適化が考えられます。どのアプローチを選択しますか？",
        "header": "設計アプローチ",
        "options": [
            {
                "label": "正規化優先（データ整合性重視）",
                "description": "第3正規形以上を維持。冗長性なし、更新異常なし"
            },
            {
                "label": "選択的非正規化（パフォーマンス重視）",
                "description": "頻繁なJOINを避けるため、計測済みボトルネックのみ非正規化"
            },
            {
                "label": "詳細な分析が必要",
                "description": "ベンチマークを実施してから判断"
            }
        ],
        "multiSelect": False
    }]
)
```

### 2. アンチパターンの正当な例外ケース

一部のアンチパターンは特定の状況で許容されます：

```python
AskUserQuestion(
    questions=[{
        "question": "EAVパターンの使用を検討していますが、以下のどれに該当しますか？",
        "header": "EAV使用の妥当性",
        "options": [
            {
                "label": "動的な属性セットが必要",
                "description": "エンティティごとに属性が大きく異なり、事前定義が不可能"
            },
            {
                "label": "標準的なテーブル設計が可能",
                "description": "属性は事前に定義可能。サブタイプモデリングで対応"
            },
            {
                "label": "判断できない",
                "description": "要件を再確認する必要がある"
            }
        ],
        "multiSelect": False
    }]
)
```

### 3. 複数の解決策が存在する場合

```python
AskUserQuestion(
    questions=[{
        "question": "階層構造の実装方法を選択してください。",
        "header": "ツリー実装戦略",
        "options": [
            {
                "label": "閉包テーブル（Closure Table）",
                "description": "クエリ高速、ストレージ消費大。祖先・子孫クエリが頻繁な場合に最適"
            },
            {
                "label": "経路列挙（Path Enumeration）",
                "description": "実装シンプル、パス検索高速。深さ制限あり"
            },
            {
                "label": "入れ子集合（Nested Sets）",
                "description": "サブツリー取得高速、更新コスト高。読み取り専用に近い場合に最適"
            },
            {
                "label": "比較検討が必要",
                "description": "アクセスパターンを分析してから決定"
            }
        ],
        "multiSelect": False
    }]
)
```

## クイックリファレンス：全25パターン

### 第Ⅰ部：論理設計のアンチパターン

| # | パターン名 | 問題 | 検出シグナル | 解決策 |
|---|-----------|------|------------|--------|
| 1 | ジェイウォーク<br>Jaywalking | カンマ区切りでリスト値を1列に格納 | `'123,456,789'` のような文字列、LIKE検索、文字列分割処理 | 交差テーブル（1行1値） |
| 2 | ナイーブツリー<br>Naive Trees | 隣接リストのみで階層を表現 | 再帰クエリ、深さ制限、サブツリー取得の複雑さ | 経路列挙/入れ子集合/閉包テーブル |
| 3 | IDリクワイアド<br>ID Required | 全テーブルに`id`列を無条件に追加 | 自然キーが存在するのに疑似キー使用、複合キーの回避 | 状況に応じた主キー選択 |
| 4 | キーレスエントリ<br>Keyless Entry | 外部キー制約を宣言しない | 孤児レコード、参照整合性チェックのアプリコード | `FOREIGN KEY`制約の宣言 |
| 5 | EAV<br>Entity-Attribute-Value | 汎用的な属性テーブルで全属性を格納 | `(entity_id, attr_name, attr_value)` 構造、型混在 | サブタイプモデリング/JSONB |
| 6 | ポリモーフィック関連<br>Polymorphic Associations | 1つのFKが複数テーブルを参照 | `object_type`+`object_id`列、参照整合性の欠如 | 交差テーブル分離/共通スーパータイプ |
| 7 | マルチカラムアトリビュート<br>Multicolumn Attributes | `tag1`, `tag2`, `tag3` のように列を複製 | 連番付き列名、検索時のOR条件羅列 | 従属テーブル（1行1値） |
| 8 | メタデータトリブル<br>Metadata Tribbles | テーブルや列を年度・カテゴリ別に分割 | `bugs_2023`, `bugs_2024` のようなテーブル | パーティショニング/単一テーブル |

### 第Ⅱ部：物理設計のアンチパターン

| # | パターン名 | 問題 | 検出シグナル | 解決策 |
|---|-----------|------|------------|--------|
| 9 | ラウンディングエラー<br>Rounding Errors | 浮動小数点型で通貨・精密値を格納 | `FLOAT`/`DOUBLE`使用、丸め誤差 | `NUMERIC`/`DECIMAL`固定小数点型 |
| 10 | サーティワンフレーバー<br>31 Flavors | `ENUM`/`CHECK`でコード値を固定 | DDL変更でしか値追加不可、値の説明不足 | 参照テーブル（ルックアップテーブル） |
| 11 | ファントムファイル<br>Phantom Files | ファイルパスのみDB格納、実体は外部 | 参照整合性なし、トランザクション対象外 | `BLOB`/オブジェクトストレージ+メタデータ |
| 12 | インデックスショットガン<br>Index Shotgun | 闇雲にインデックスを作成/削除 | インデックス過多、更新遅延、未使用インデックス | MENTOR原則（測定・説明・指名・検証・整理・再構築） |

### 第Ⅲ部：クエリのアンチパターン

| # | パターン名 | 問題 | 検出シグナル | 解決策 |
|---|-----------|------|------------|--------|
| 13 | フィア・オブ・ジ・アンノウン<br>Fear of the Unknown | `NULL`を避ける、誤った比較 | `NULL`の代わりに`-1`/`''`、`= NULL`使用 | `IS NULL`/`IS NOT NULL`/`COALESCE` |
| 14 | アンビギュアスグループ<br>Ambiguous Groups | `GROUP BY`に含まれない列を`SELECT` | 非決定的な集約結果、DBによってはエラー | 集約関数/`GROUP BY`追加/導出テーブル |
| 15 | ランダムセレクション<br>Random Selection | `ORDER BY RAND()`でランダム行取得 | 全行スキャン、ソート負荷 | オフセット法/キーベース法 |
| 16 | プアマンズ・サーチエンジン<br>Poor Man's Search Engine | `LIKE`/`REGEXP`で全文検索を実装 | パフォーマンス劣化、スコアリングなし | 全文検索インデックス/検索エンジン |
| 17 | スパゲッティクエリ<br>Spaghetti Query | 1つの巨大クエリで全処理を実装 | 数百行のSQL、多数のJOIN/サブクエリ | 分割統治、CTE、一時テーブル |
| 18 | インプリシットカラム<br>Implicit Columns | `SELECT *`/`INSERT`で列名省略 | 列順序依存、スキーマ変更で破綻 | 明示的な列名指定 |

### 第Ⅳ部：アプリケーション開発のアンチパターン

| # | パターン名 | 問題 | 検出シグナル | 解決策 |
|---|-----------|------|------------|--------|
| 19 | リーダブルパスワード<br>Readable Passwords | パスワードを平文/可逆暗号化で格納 | 復号可能、ソルトなし | ソルト付きハッシュ（bcrypt/Argon2） |
| 20 | SQLインジェクション<br>SQL Injection | SQL文字列を動的に連結 | `"SELECT * FROM users WHERE id=" + userId` | プリペアドステートメント/パラメータ化 |
| 21 | シュードキー・ニートフリーク<br>Pseudokey Neat-Freak | 疑似キーの欠番を詰める | `id`の連番保証ロジック、ギャップ検出・修正処理 | 欠番を許容、ビジネスキーと分離 |
| 22 | シー・ノー・エビル<br>See No Evil | データベースエラーを無視 | `try { ... } catch { }`空ブロック、エラーログなし | 適切なエラーハンドリング・ロギング |
| 23 | ディプロマティック・イミュニティ<br>Diplomatic Immunity | SQL文だけ品質基準を除外 | バージョン管理なし、テスト不足、コードレビュー対象外 | アプリコードと同等の品質基準適用 |
| 24 | マジックビーンズ<br>Magic Beans | ActiveRecordクラス=ドメインモデル | モデルクラスの肥大化、テストの困難さ | ドメインモデルとORMの分離 |
| 25 | 砂の城<br>Sand Castle | 本番環境の想定不足 | ベンチマークなし、バックアップ計画なし、単一障害点 | 容量計画/バックアップ/HA/DR戦略 |
| 26 | スタンダード・オペレーティング・プロシージャ<br>Standard Operating Procedure | ストアドプロシージャの盲目的使用 | 全SQLがストアドプロシージャ内、「いつもこうしてきた」 | 現代のアプリアーキテクチャ採用、負荷分散 |

## カテゴリ別判断フロー

### スキーマ設計時

```
1. テーブル構造は正規化されているか？
   → 第1-3正規形をチェック（NORMALIZATION.md参照）
   → パターン1,2,3,5,6,7,8に注意

2. 階層構造を扱うか？
   → パターン2（ナイーブツリー）を確認

3. 外部キー制約は宣言されているか？
   → パターン4（キーレスエントリ）を回避

4. データ型は適切か？
   → パターン9（浮動小数点）、10（ENUM）を確認
```

### クエリ作成時

```
1. SELECT文は明示的か？
   → パターン18（SELECT *禁止）

2. NULL処理は正しいか？
   → パターン13（IS NULL使用）

3. GROUP BYは適切か？
   → パターン14（全列を集約または選択）

4. パフォーマンスは許容範囲か？
   → パターン15,16,17（ランダム、全文検索、巨大クエリ）
```

### アプリケーション実装時

```
1. SQL文は安全か？
   → パターン20（SQLインジェクション）を最優先チェック

2. パスワードは安全に保存されているか？
   → パターン19（ハッシュ化）

3. エラーハンドリングは適切か？
   → パターン22（エラー無視禁止）

4. 本番環境への備えは十分か？
   → パターン25（ベンチマーク、バックアップ、HA）
```

## 詳細ガイド

各カテゴリの詳細な解説、コード例、例外ケースについては以下のファイルを参照してください：

- **[LOGICAL-DESIGN.md](./references/LOGICAL-DESIGN.md)**: 第Ⅰ部 論理設計（パターン1-8）
  - データモデリング、正規化、リレーションシップ設計

- **[PHYSICAL-DESIGN.md](./references/PHYSICAL-DESIGN.md)**: 第Ⅱ部 物理設計（パターン9-12）
  - データ型選択、インデックス戦略、ストレージ設計

- **[QUERY-PATTERNS.md](./references/QUERY-PATTERNS.md)**: 第Ⅲ部 クエリ（パターン13-18）
  - SQL文の書き方、パフォーマンス最適化

- **[APPLICATION-DEV.md](./references/APPLICATION-DEV.md)**: 第Ⅳ部 アプリケーション開発（パターン19-25）
  - セキュリティ、アーキテクチャ、運用設計

- **[NORMALIZATION.md](./references/NORMALIZATION.md)**: 付録 正規化ルール
  - 第1-5正規形、ボイスコッド正規形の詳細解説

- **[FOREIGN-KEYS.md](./references/FOREIGN-KEYS.md)**: ボーナス 外部キーのミニ・アンチパターン
  - 標準SQL/MySQL固有の外部キー制約の落とし穴集

## 実践ワークフロー

### 1. 新規スキーマ設計

```sql
-- ステップ1: エンティティと属性の識別
-- ステップ2: 正規化（NORMALIZATION.md参照）
-- ステップ3: 外部キー制約の宣言（パターン4回避）
-- ステップ4: 適切なデータ型選択（パターン9,10回避）

CREATE TABLE Products (
  product_id   SERIAL PRIMARY KEY,
  product_name VARCHAR(200) NOT NULL,
  price        NUMERIC(10,2) NOT NULL,  -- パターン9: FLOAT禁止
  status       VARCHAR(20) NOT NULL,     -- パターン10: ENUM避けて参照テーブル
  FOREIGN KEY (status) REFERENCES ProductStatus(status)
);
```

### 2. クエリレビューチェックリスト

- [ ] `SELECT *` を使用していない（パターン18）
- [ ] `NULL` 比較に `IS NULL` を使用（パターン13）
- [ ] `GROUP BY` に非集約列を含めていない（パターン14）
- [ ] プリペアドステートメント使用（パターン20）
- [ ] インデックスが適切に使用されている（パターン12）

### 3. リファクタリング優先順位

**Critical（即座に修正）**:
- パターン20: SQLインジェクション
- パターン19: 平文パスワード
- パターン4: 外部キー制約の欠如

**High（次回スプリントで修正）**:
- パターン1,5,7: データモデル正規化
- パターン9: 浮動小数点型の通貨データ
- パターン22: エラー処理の欠如

**Medium（計画的にリファクタリング）**:
- パターン2,8: テーブル構造の最適化
- パターン12,15,16,17: パフォーマンス問題

**Low（パフォーマンス計測後に判断）**:
- 非正規化の検討
- インデックスチューニング

## トラブルシューティング

### 症状: クエリが遅い

```
1. EXPLAIN/EXPLAIN ANALYZEで実行計画確認
2. インデックス使用状況を確認（パターン12）
3. 以下のパターンをチェック:
   - パターン15: ORDER BY RAND()使用
   - パターン16: LIKE '%keyword%'での全文検索
   - パターン17: 過度に複雑なJOIN
   - パターン1: カンマ区切りリストの検索
```

### 症状: データ不整合が発生

```
1. 外部キー制約の有無を確認（パターン4）
2. 正規化レベルをチェック（NORMALIZATION.md）
3. 以下のパターンをチェック:
   - パターン5: EAV構造
   - パターン6: ポリモーフィック関連
   - パターン7,8: 列の複製、テーブルの分割
```

### 症状: スキーマ変更が困難

```
1. メタデータの硬直性をチェック:
   - パターン8: 年度別テーブル分割
   - パターン10: ENUM型の使用
   - パターン3: 不適切な主キー設計
```

## セキュリティチェック（実装後必須）

データベース関連のコード実装完了後、以下を必ず実行してください：

```bash
# CodeGuardセキュリティチェック
/codeguard-security:software-security
```

特に以下の項目を重点的に確認：
- SQLインジェクション対策（パターン20）
- パスワード保存方式（パターン19）
- エラーハンドリング（パターン22）

## 参考資料

- **[NORMALIZATION.md](./references/NORMALIZATION.md)**: リレーショナル理論と正規形の詳細
- **securing-code**: アプリケーションレベルのセキュリティ（OWASP Top 10、入力検証、XSS対策）
- **testing-code**: データベーステストの戦略（トランザクションロールバック、テストデータ管理）
