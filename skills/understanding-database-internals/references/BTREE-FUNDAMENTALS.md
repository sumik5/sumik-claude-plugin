# Bツリーの基本

## 概要

このファイルでは、ディスク上のストレージ用に最適化された階層型データ構造である**Bツリー（B-tree）**とその基礎となる概念について解説します。Bツリーは、多くのデータベースシステム（PostgreSQL、MySQL InnoDB、SQLiteなど）のストレージエンジンの中核を成しています。

---

## 二分探索木（BST）からBツリーへの進化

### 二分探索木（Binary Search Tree, BST）

BSTは、ソートされたインメモリのデータ構造であり、効率的なキー検索に使用されます。

#### BSTの構造

- **各ノードは最大2つの子ノード（左・右）を持つ**
- **左側のサブツリー**: 親ノードより小さいキーを格納
- **右側のサブツリー**: 親ノードより大きいキーを格納

```
        5
       / \
      2   6
     / \   \
    1   4   7
       /
      3
```

#### BSTの計算量

- **検索・挿入・削除**: 平均 O(log N)、最悪 O(N)（バランスが崩れた場合）

#### BSTのディスクストレージ用ツリーへの課題

BSTをディスクに格納しようとすると、以下の問題が発生します：

- **深さが大きい**: ファンアウト（子ノードの数）が2なので、ツリーの高さが log₂(N) になり、ディスクシークの回数が増える
- **バランシングが複雑**: ディスク上での回転操作（AVLツリー等）は、ランダムI/Oを伴い非効率

### AVLツリー（平衡二分探索木）

AVLツリーは、BSTの欠点である「バランスの崩れ」を解消したツリーです。

#### AVLツリーの特徴

- **バランスが保たれたツリー**: 高さが O(log N) に保証される
- **バランス条件**: 左右のサブツリーの高さの差が最大1
- **回転操作**: ノードの挿入・削除時にバランスを維持

#### AVLツリーの制約

- **ファンアウトが小さい**: 依然として2つの子ノードしか持たない
- **ディスクI/Oが多い**: ツリーの高さが大きいため、シークの回数が O(log₂ N) のまま

### Bツリーの登場

Bツリーは、AVLツリーの制約を克服するために、**ファンアウトを大きくする**ことでディスクI/Oを削減します。

#### Bツリーの設計目標

1. **大きなファンアウト**: 各ノードが多数の子ノードを持つことで、ツリーの高さを log_k(N) に削減（kはファンアウト）
2. **バランスの維持**: すべてのリーフノードが同じ深さになるように自動調整
3. **ディスクI/Oの最小化**: ノードをディスクページに対応させ、1回のシークで多数のキーを検索

---

## ディスクの構造

Bツリーがディスク上でどのように機能するかを理解するには、ディスクの物理的特性を知る必要があります。

### ハードディスクドライブ（HDD）

従来のアルゴリズムの大半は、回転式ディスクもっとも広く普及していた永続的ストレージメディアであった時代に開発されました。

#### HDDの構造

- **プラッタ（円盤）**: データを磁気的に記録する回転する円盤
- **トラック**: プラッタ上の同心円状のデータ領域
- **セクタ**: トラックを分割した最小単位（通常512バイトまたは4KB）
- **ヘッド**: データを読み書きする磁気ヘッド

#### HDDのアクセス時間

| 操作 | 時間 |
|------|------|
| **シーク時間** | 数ミリ秒〜10ミリ秒（ヘッドの移動） |
| **回転遅延** | 数ミリ秒（ターゲットセクタの回転待ち） |
| **転送時間** | 数十〜数百MB/秒 |

**重要**: ランダムアクセスは非常に遅い（シーク + 回転遅延）。シーケンシャルアクセスは比較的高速。

### ソリッドステートドライブ（SSD）

SSDには機械的部品がありません。つまり、回転するディスクもありませんし、読み取りのために動かす必要があるヘッドもありません。

#### SSDの構造

- **ダイ（Die）**: 複数のプレーンを含む半導体チップ
- **プレーン（Plane）**: ブロックの集合
- **ブロック（Block）**: ページの集合（64個〜512個のページ）
- **ページ（Page）**: 読み書きの最小単位（4KB〜16KB）

#### SSDの特性

| 特性 | 説明 |
|------|------|
| **読み取り** | ページ単位で高速（マイクロ秒） |
| **書き込み** | ページ単位で実行（しかし、ブロック消去が必要） |
| **消去** | ブロック単位（ページより大きい単位） |
| **書き込み増幅** | ガベージコレクションにより、実際の書き込み量が増加 |

**フラッシュトランスレーションレイヤ（FTL）**: 論理アドレスを物理アドレスにマッピングし、ガベージコレクションの複雑さを隠蔽します。

### ディスク上のデータ構造の原則

メモリベースのストレージとディスクベースのストレージについて、一般的に議論されるデータ構造は、同じ反応に従います。ただし、メモリではポインタを比較的自由に使用できるのに対し、ディスクでは以下が必要です：

1. **ファンアウトを最大化**: 1回のディスクシークで多数のキー情報を取得
2. **ツリーの高さを最小化**: シーク回数を削減
3. **ノードをディスクブロックに対応**: ディスクの論理的な最小単位に合わせる

---

## ユビキタスBツリー

Bツリーは、古い固有値が広く、それらに**木より背りじょ**うにキーと目録をしたところができます。最初に適切なキャビネットを引き出し、次にその引き出しの中のカード目録を順番に参照して、探している資料を見つけ出します。

### Bツリーの階層

Bツリーは、複数のノードで構成される階層的なツリーです。各ノードは最大N個のキーと、子ノードに対するN+1個のポインタを保持します。

#### ノードの種類

| ノードタイプ | 説明 |
|-----------|------|
| **ルートノード** | 親がなく、ツリーの最上位になる |
| **リーフノード** | 最下層ノードで、子ノードがありません |
| **中間ノード** | その他すべてのノードで、ルートとリーフを結びます。通常は、中間ノードが1レベル以上存在します |

#### Bツリーのノード構成

```
ルート
ノード         [ ... | ... | ... ]

中間           [ ... | ... ]  [ ... | ... ]  [ ... | ... ]
ノード

リーフ         [   ]  [   ]   ...            [   ]  [   ]
ノード
```

### セパレータキー（Separator Key）

Bツリーのノードに格納されるキーは、**インデックスエントリ**または**セパレータキー**、または**分割セル**と呼ばれることもあります。

#### セパレータキーの役割

- **範囲の分割**: キーによって、サブツリーの範囲を示す
- **子ノードへのポインタ**: セパレータキーの間にあるポインタが、対応する範囲を持つ子ノードを指す

#### セパレータキーの例

```
K₁ | K₂ | K₃
 ↓   ↓   ↓   ↓

K_x < K₁  |  K₁ ≤ K_x < K₂  |  K₂ ≤ K_x < K₃  |  K₃ ≤ K_x
```

---

## Bツリーの階層構造

Bツリーはページ構成の技術として、固定長ページの構成および固定に使用されるので、本書ではノードとページという用語を、しばしば同じ意味で使用します。

### ファンアウトと高さの関係

Bツリーの高さは、そのファンアウト（各ノードの子の数）によって決まります。

#### ファンアウトの計算

ノードの容量とそのノードが実際に格納するキーの数の関係、利用可能なキーの数を**ファンアウト**と呼びます。

**例**: 40億（4 × 10⁹）の項目のうちから検索対象のキーを検出するには、約32回の比較が必要になります（これの話題については詳しくは、「2.3.3 Bツリーの検索の計算量」で詳しく説明します）。これらの比較1回ごとにディスクシークを1回行う必要があるとすると、処理時間が大幅に遅くなります。しかし、Bツリーのノードには数十個から、場合によっては数百個の項目が格納されます。したがって、1レベル移動するごとに行う必要があるディスクシークは1回のみです。

#### Bツリーの高さ

- **計算式**: 高さ ≈ log_k(N)（kはファンアウト、Nはキーの総数）
- **ファンアウトの利点**: kが大きいほど、ツリーの高さが低くなり、ディスクシーク回数が削減される

### ポイントクエリと範囲クエリ

Bツリーを使用すると、**ポイントクエリ**と**範囲クエリ**の両方を効率的に行えます。

#### ポイントクエリ

- **定義**: 特定のキーの値を検索
- **アルゴリズム**:
  1. ルートノードから開始
  2. キーと比較して、適切な子ノードへ移動
  3. リーフノードに到達したら、キーを検索

#### 範囲クエリ

- **定義**: キーの範囲に対するすべてのレコードを検索
- **アルゴリズム**:
  1. 範囲の開始キーまでポイントクエリで到達
  2. リーフノード間を横断して範囲終了キーまでスキャン

---

## Bツリーの検索アルゴリズム

### 検索の手順

1. **ルートノードから開始**
2. **二分探索を実行**: 検索対象キーを実行して、検索対象のキーと比較します。検索対象をK_Lより大きいセパレータキーが見つかるまで、これを繰り返します。すでに議論したように、インデックスオーバーは、2つの検索をキー間を境界として、ツリーをサブツリーに分割します
3. **子ノードへ移動**: キーをルートノードに格納されているキーと比較して検索対象のキーをルートノードに対してポインタをたどり（まずポイントクエリまたは範囲クエリをたどります）同じ検索プロセス（セパレータキーを見つけ出し、ポイントクエリたどります）をターゲットとなるリーフノードに到達するまで繰り返します。ターゲットとなるリーフノードでは、検索アルゴリズムによって使用されます
4. **各レベルで同じ処理を繰り返し**: ツリーのさらに詳細にセ共鳴し、キーがより正確で詳細になるレベルに降りていき、最終的にデータレコードのあるリーフに到達します
5. **リーフノードで検索**: ポイントクエリの場合には、検索対象のキーを見つけ出し、あるいはそれが存在しないことを確認します。範囲検索の場合には、もっとも近くて小さいキーをたどって複数のノードを指すポインタを追います

### キーのカウント

文献の中では、さまざまな方法でキーとオフセットのカウントが記明されているのを目にします。

- **一般的な慣例**: デバイスに依存した自然数で、最適なページサイズを表すk個単位います。
- **このファイルの場合**:
  - キーを順から2k個まで格納できますが、部分的に値が入るためにはk+1個から2k+1個まで格納できます
  - 子ノードへのポインタをなくとも k + 1個は保持することもあります

### セパレータキーと削除キー

別の資料では、**セパレータキー**を削除で説明されているキーとし、**ポインタを N + 1個**が保持されますます。これは、グラープFE11では、セパレータキー基N割を朝で、ポインタを N個を朝している場合があります。これらが指す補間した要素については、同時にこの話題に関するみ割します。

---

## Bツリーのノード分割とマージ

Bツリーに値を挿入するには、最初にターゲットとなるリーフを検索し、挿入位置を見つける必要があります。

### ノード分割（Node Split）

#### 分割が必要になる場合

- **リーフノード**: ノードがキーと値のペアをN個まで保持可能で、キーと値のペアが追加できない場合
- **リーフ以外のノード**: ノードがポインタを N + 1個まで保持可能なとき、1個挿入すると、その親を容量Nを超えるところに移動します

#### 分割の手順（リーフノードの場合）

1. **新しいノードを割り当てます**
2. **分割中のノードから新しいノードに要素の半分をコピーします**
3. **対応するノードに新しい要素を配置します**
4. **分割したノードの親ノードにセパレータキーと新しいノードへのポインタを追加します**

#### 分割の例

```
分割前:
[  18  |     |     |  ]

分割後:
[  13  |  18  |     ]
```

ここでは[キー 11]挿入時のリーフノードの分割を示しています。追加されたキーを反映して示されています。

### リーフ以外のノードの分割

リーフ以外のノードの分割は、常に下のレベルから伝播して来る分割が表れたものなので、次のレベルのノードに対応するキーと新しいノードへ移動します。

#### 分割が全体に伝播する場合

分割が行われた結位置のインデックスは、分割またはは親開始と呼ばれます。分割が実行されると常に、その結果である2つのノードとしそれぞれを子としてのツリー処置を行います。リーフ以外の場合には、だだちにルートを分割する必要があります。ルートノードが分割されると、分間点のキーを含む新しいルートが作成されています（含んじれはエントリのモ分のみを保持しています）。新しく作成された以前のルートレベルによってツリーの高さが1段階えます。ツリーが高く成長するのは、それらのノードに項目を追加します後のみです。

### ノードマージ（Node Merge）

開除を行うには、最初にターゲットとなるリーフを検索します。リーフを探し出すと、そのクエリクエリのセル除された情報が間除されることのないようにします。

#### マージが必要になる場合

隣接したノードに保持されている值がN枚以下しかない場合、つまり、それらの利用率が間除をるセパレータキーをり1含うならうに検討されます

#### マージの条件

- **リーフノード**: ノードがキーと値のペアをN個まで保持可能なとき、キーと値ぺでN個以下である場合
- **リーフ以外のノード**: ノードがポインタを N + 1個まで保持可能なとき、コリードのポインタの数がN以下である場合

#### マージの手順

1. **右側のノードから左側のノードに要素をすべてコピーします**
2. **右側のノードのポインタを親から削除します。または、リーフ以外のマージの場合には**接続**します**
3. **右側のノードを削除します**

---

## ファイルフォーマットとページ構造

Bツリーの実装を理解するには、バイナリデータの構成が必要です。

### モチベーション

ファイルフォーマットの作成は、管理対象外メモリモデルを全1つの言語でデータ構造を作成する方法と、多くの点で類似しています。

- **プリミティブな型**: データを固定長またはバリエーションまたは可変長の値として表現
- **固定長レコード**: レコード全体またはその構成要素が固定長の場合は効率的
- **可変長レコード**: 文字列やシーケンス、ブログフィールドは動的に管理

### バイナリエンコーディング

#### プリミティブ型

キーと値は、integer、date、string などの型を持ち、バイナリ形式のまま表現できます。

- **数値型**: 固定長として表現されます（byte は8ビット、short は2バイト、int は4バイト、long は8バイト）
- **エンディアンネス（Byte Order）**: ビットオーダーが最上位バイト（MSB）から始まり、その後に上位から下位へバイトが続きます
  - **ビッグエンディアン**: 最下位バイト（LSB）から始まり、その後に下位から上位へバイトが続きます
  - **リトルエンディアン**: 最下位バイト（LSB）から始まり、その後に下位から上位へバイトが続きます

#### 文字列と可変長のデータ

プリミティブな数値型は、すべて固定長です。それらをまとめてより複雑な構造を作成するのは、比較としてシリアライズできます。

文字列とその他の可変長のデータ型、たとえば固定長データ型の配列とは、数値として型リアライズできます。この数値は配列またはに文字列の長さを表し、その後にサイズが読み取られ逆シリアライズのフォーマット形式をえ表現してデータを再構成できます。

#### ビットパック化データ：ブール型と列挙型とフラグ

ブール型は、単一のバイトを使用するか、あるいは true と false を上とる0の値にエンコードすることができます。

**列挙型（Enum）**は、整数で表すことができ、多くの場合は1バイトやフルコントロールを使用します。別挙型は、頻繁に繰り返される値を表すために使用されます。

- **ビットマスク**: ビット単位の OR (|) とビット単位の排他的論理和 (<<) を使用してフラグをセット
- **ビットシフト**: ビット単位の AND (&) とビット単位の台定論理演算 (−) を使用してフラグを解除

---

## 一般的な原則

通常、ファイルフォーマットを設計するときには、アドレス情報をどのように行うかを認知に決定します。つまり、単一のブロックまたは複数の隣接しているブロックで長さまる向じレサイズのページにファイルを分割するかどうかを決めることになります。

### ファイルの構成

ファイルは、固定サイズのヘッダで始まり、固定長または可変長のトレーラで終わります。

```
ページ

  ●                    ●
  ↓                    ↓
ヘッダ                トレーラ
```

### ページベースのアプローチ

- **早くアクセスされる必要がある**: ファイルの残りの部分の必要にな実際な情報が格納されています
- **ファイルの残りの部分はページに分割されます**: このファイルの構成の概観を、図3-3に示します

#### ページの利点

多くのデータストアには、固定されたスキーマを持ち、テーブルに保持できるフィールドの数、幅序、およびス型を指定しています。固定されたスキーマを持つことは、ディスク上に格納されるデータの量を前適することに役立ちます。

### 固定長データ対固定長フィールドのフィールドを格納するには、オフセットを固定的を固定することができます。この場合の1は、任意の順辺データを利用できるからです。

#### 固定長のフィールドド

```
固定長のフィールド:
| (4 bytes) employee_id |
| (4 bytes) tax_number  |
| (3 bytes) date        |
| (1 byte) gender       |
| (2 bytes) first_name_length |
| (2 bytes) last_name_length  |

可変長:
| (first_name_length bytes) first_name |
| (last_name_length bytes) last_name   |
```

### スキーマの進化

さらに複雑な構成を検討するには、通常、障害を作成することが必要になります。たとえば、ブロティアでマイテインを格納し、セクション中リヂョンを構成するなどとします。この場合、厳密なルールがあるわけではなく、どのような種類のデータのフォーマットを作成する必要があるかによって決定されます。

---

## ページ構造

データベースシステムは、データレコードをデータファイルとインデックスファイルに格納します。これらのファイルは、ページと呼ばれる固定長のユニットに分割され、多くの場合、そのサイズは複数のファイルシステムブロックのサイズに相当します。ページのサイズは、通常は4 KBから16 KBに設定されます。

### 固定長レコードのページ構造

最初のBツリーの論文[BAYER72]では、固定長のデータレコードの車載ベースベージ構成が閉明されています。この論文によると、各ページは、図3-4に示すように、3つの要素が結合されたもので占されます。

```
p₀ | k₁ | v₁ | p₁ | k₂ | v₂ | ... | kₙ | vₙ | pₙ | 未使用
```

---

## スロット化ページ（Slotted Pages）

可変長レコードの格納関域には、空き領域の管理、たとえば、削除されたレコードが使用していた領域を回収する必要があります。

### スロット化ページの構造

ページを固定長のセグメントに分割することで、最終的に領域を無駄にすることなく可変長レコードを格納します。

#### スロット化ページのレイアウト

```
ヘッダ      ポインタ

              ●   ●   ●
              ↓   ↓   ↓
            ................
              ←   →
セル
```

### セクションの役割

このセクションのはじめに述べた問題が、このアプローチによっていかに解決されるかを確認します。

- **最小のオーバーヘッド**: スロット化ページによって付与される唯一のオーバーヘッドは、レコードが格納されている実際の場所へのオフセットを保持するポインタ配列のみです
- **領域の回収**: ページのデフラグメ書き換むことで、領域を回収できます
- **動的なレイアウト**: ページの外部からスロットはそのIDによって無効にされるので、実際の配置はページ内で自由に組み替えることができます

---

## セルのレイアウト

フラグ、列挙型、およびプリミティブ型の値を使用してセルのレイアウトの設計からはじめて、次にセルを格納させページにし、ページからツリーを構成できます。

### キーセルとキーバリューセル

**固定長のキーセルのレイアウト**:

```
0       4       8 ...
+-------+-------+----------------+
| [int] key_size | [int] page_id | [bytes] key |
+-------+-------+----------------+
```

**キーバリューセルの例**:

```
0   1       5 ... + key_size
+---+-------+-----------------+--------------------+
| [byte] flags | [int] key_size | [bytes] key | [bytes] data record |
+---+-------+-----------------+--------------------+
```

---

## 可変長データの管理

ページから項目を削除しても、実際のセルを削除して、その他のものを同じ場所に書き込むことがなく、大きな努力を必要とすることなく、セルをページに追加することができます。

### 利用可能リスト（Free List）

削除されたセルは、ページからマークされてなくなります。新しいはいセルをフィットするだけの十分な削減されたため利用可能リストは、新しいセルが追加可能になるバイトから1分かる場合には、有効なセルの減み取りと書き込みのための領域を確保します。

#### ファーストフィット vs ベストフィット

- **ファーストフィット**: より大きなオーバーヘッドを引き起こす可能性があります
- **ベストフィット**: 挿入によって残される領域がもっとも小さくなるセグメントを探します

---

## バージョン管理

データベースシステムは継ぎ予進化しており、開発者は機能を追加し、バグやパフォーマンスの問題を解決するために作業を続けています。

### ファイルフォーマットのバージョン管理

- **後方互換性**: 古いバージョンで読み取れる形式を維持
- **バージョン番号の管理**: ファイルヘッダにバージョン情報を格納

---

## チェックサム

ディスク上のファイルは、ソフトウェアのバグやハードウェアの障害によって破損したりするおそれがあります。これらの問題を留め特定し、破損したデータが他のサブシステムや、場合によってはノードに伝播するのを防止するために、チェックサムと巡回冗長検査（CRC）を使用できます。

### チェックサムの種類

| 種類 | 説明 |
|------|------|
| **ハッシュ関数** | CRC、MD5、SHA等 |
| **パリティビット** | 単純な誤り検出（誤りの訂正はできない） |

#### チェックサムの配置

- **ページごとのチェックサム**: ページ単位での整合性確認
- **ファイル全体のチェックサム**: ファイル単位での検証

---

## まとめ

この章では、Bツリーのファイルフォーマットとページ構造の基礎について解説しました。

### キーポイント

1. **BST → AVL → Bツリーの進化**: ファンアウト拡大によるディスクI/O削減
2. **ディスクの構造**: HDD（シーク時間）とSSD（ページ/ブロック単位）
3. **Bツリーの階層**: ルート、中間、リーフノードの役割とセパレータキー
4. **検索・挿入・削除アルゴリズム**: O(log_k N)の計算量
5. **ファイルフォーマット**: バイナリエンコーディング、ページ構造、スロット化ページ
6. **セルのレイアウト**: 固定長データと可変長データの管理
7. **バージョン管理とチェックサム**: データ整合性の保証

次章では、Bツリーの実装詳細（ページヘッダ、二分探索、スプリット/マージ、圧縮、バキューム）について深掘りします。
