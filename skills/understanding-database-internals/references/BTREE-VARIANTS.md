# Bツリーの亜種

Bツリーの亜種には共通点がある。ツリー構造、スプリットとマージによるバランシング、検索と削除のアルゴリズムなどである。同時実行性に関連する詳細、ディスク上でのページの表現、兄弟ノード間のリンク、メンテナンスプロセスなどは実装ごとに異なる。

---

## コピーオンライトBツリー

### 基本原理

複雑なラッチの仕組みを構築する代わりに、コピーオンライト（Copy-on-write）の技術を用いて並行操作時のデータ整合性を保証する方式。

**動作メカニズム:**

- ページの変更が行われるとき、必ずその内容がコピーされる
- もとのページの代わりにコピーされたページが変更され、相似したツリー階層が作成される
- 古いツリーは書き込みプロセスと並行して読み込みプロセスからアクセス可能
- 新しいページ階層が作成された後、最上位ページへのポインタがアトミックに更新される
- 操作に関連しなかったページは再利用される

**利点:**

- 書き込まれたページはイミュータブルで、ラッチを追加しなくてもアクセスできる
- 読み取りは同期を必要としない
- 書き込みはコピーされたページに対して実行されるので、読み込みプロセスをブロックしない
- 不完全な状態のページは見えず、クラッシュしてもページが破損した状態で残されない（最上位のポインタが切り替えられるのは、すべてのページの変更が完了したときに限られる）

**欠点:**

- ページの内容全体をコピーする必要があり、より多くの領域とプロセッサ時間を必要とする
- ただしBツリーの高さは一般に低く、このアプローチの単純さと利点が多くの場合その欠点を上回る

### LMDB

OpenLDAPプロジェクトで使用されているキーバリューストア LMDB（Lightning Memory-Mapped Database）は、コピーオンライトを使用しているストレージエンジンの代表例。

**アーキテクチャの特徴:**

- ページキャッシュ、ログ先行書き込み、チェックポイント、圧縮を必要としない
- 単一レベルのデータストアとして実装される
- 読み取り操作と書き込み操作がメモリマップを介して直接行われる
- アプリケーションレベルで追加のキャッシュが不要
- ページの追加の実体化を行う必要がなく、中間バッファにコピーせずに直接メモリマップからデータの読み込みができる

**更新の仕組み:**

- 更新時にはルートからターゲットとなるリーフまでの経路上のブランチノードがすべてコピーされ、変更される可能性がある
- 更新が伝播するノードは変更され、それ以外のノードはもとのままの状態に保たれる
- ルートノードのバージョンを2つのみ保持（最新のバージョンと新しい変更がコミットされようとしているバージョン）
- すべての書き込みはルートノードを介して行う必要がある

**MVCCとの関係:**

- コピーされたノードに古くなったデータを残しておくのは実用的ではないが、MVCCに使用可能
- 実行中の読み取りトランザクションの要求に応じられるコピーがすでに存在している
- データベース構造は本質的にマルチバージョン化されており、読み取りはロックなしで実行できる

---

## ノード更新の抽象化

ディスク上のページを更新するには、まずメモリ内の状態を更新する必要がある。メモリ内でノードを実装する方法はいくつかある。

### 3つのアプローチ

**1. ネイティブバイナリ操作（管理されていないメモリモデル）**

- Bツリーのノードに格納されたバイナリのままのデータを再解釈
- ネイティブポインタを使用してデータを操作
- ノードは構造体として定義され、ポインタとランタイムによるキャストの背後でバイナリのままデータが使用される

**2. ネイティブオブジェクト/構造体**

- 言語にネイティブなオブジェクトまたは構造として具現化
- 変更がメモリ内のページに適用され、その後ディスク上にも適用される
- 中間オブジェクトへのアクセスから並行アクセスを単純化できる利点がある
- 同じページの2つのバージョン（バイナリと言語固有）をメモリ内に保管する必要があり、メモリのオーバーヘッドが大きい

**3. ラッパーオブジェクト**

- 即座にそれらの変更を実体化するラッパーオブジェクトを介してノードの背後にあるバッファへのアクセスを提供
- 管理されたメモリモデルを持つ言語でよく使用される
- ディスク上のページ、キャッシュされたバージョン、メモリ内の実装を別々に管理することで、それぞれが異なるライフサイクルを持つことを可能にする
- 挿入、更新、削除の各操作をバッファリングし、メモリ内で行われた変更を読み取り時にもディスク上のバージョンと照合することができる

---

## 遅延Bツリー

更新をバッファリングすることで、後続の同ビノードへの書き込みでI/O要求を削減する方式。更新に適したメモリ構造を使用して、更新をバッファリングし、遅延を伴ってそれらを伝播させる。

### WiredTiger

MongoDBのデフォルトになっているストレージエンジンWiredTigerで採用されている、遅延Bツリーの行ストアの実装。

**構造:**

- メモリ内のページとディスク上のページに異なるフォーマットが使用される
- クリーンなページはインデックスのみで構成され、最初はディスク上のページイメージから構築される
- 更新はまず**更新バッファ**に保存される

**読み取り時の動作:**

- 更新バッファは読み取り時にアクセスされる
- ディスク上のもとのページ内容とマージされて、最新のデータが返される

**フラッシュ時の動作:**

- ページがフラッシュされると、更新バッファの内容はページの内容と調停が行われ、ディスクに永続化される
- もとのページは上書きされる
- 調停結果のページサイズが最大サイズより大きい場合には、複数のページにスプリットされる

**更新バッファの実装:**

- スキップリストを使用して実装
- 検索ツリーと類似した複雑性を持つが、より優れた同時実行の特性を持つ

**主要な利点:**

- ページの更新と構造の変更（スプリットとマージ）がバックグラウンドのスレッドで実行される
- 読み取り/書き込みプロセスはそれらが完了するのを待つ必要がない

### 遅延適応ツリー（LAツリー）

個々のノードへの更新をバッファリングするのではなく、ノードをサブツリーにグループ化し、操作を一括処理するための更新バッファを**各サブツリー**に関連付ける方式。

**動作メカニズム:**

1. データレコードを挿入するとき、最初に新しいエントリがルートノードの更新バッファに追加される
2. バッファが一杯になると、下位のツリーレベル内のバッファに変更をコピーして伝播する
3. この操作は再帰的に続けられ、最終的にリーフノードに到達するまで繰り返される
4. 更新がリーフレベルに到達すると、ツリーの内容とその構造に一度に適用される
5. ページをたった一度の実行で更新できるので、必要なディスクアクセスと構造変更の回数が削減される
6. スプリットとマージも一括処理で上位レベルに伝播される

---

## FDツリー

バッファリングに対して、追記型のストレージとマージプロセスを使用して異なるノードを対象とする更新をグループ化する方式。フラッシュディスクツリー（FD-Tree）と呼ばれる。

### 構造

- 小規模でミュータブルなヘッドツリーと複数のイミュータブルなソート済みの配列からなる
- ランダムな書き込みI/Oが必要な箇所がヘッドツリーに制限される
- 小さなBツリーによって更新がバッファリングされる
- ヘッドツリーが一杯になると、すぐにその内容がイミュータブルな**配列**へ転送される
- 新しく書き込まれた配列のサイズが閾値を上回った場合、その内容は次のレベルとマージされる
- データレコードが上位レベルから下位レベルへと徐々に伝播される（LSMツリーにおけるコンパクションに類似）

### フラクショナルカスケーディング

レベル間のポインタを管理するためにフラクショナルカスケーディング（fractional cascading）が使用される。

**基本原理:**

- ソートされた配列から項目を順番に検索するコストを削減するために有効
- 最初の配列では検索対象の項目を見つけるために log n のステップが実行される
- それ以降の検索ではコストは大幅に低減される（前のレベルで検索がマッチした、もっとも近い場所から開始される）

**ブリッジの構築:**

- ギャップを最小にするために、隣接するレベルの配列間にブリッジを構築する
- 上位レベルからのポインタがない要素グループ（ブリッジ）を作成
- 下位レベルの配列から要素を上位レベルに引き上げることで作成される

### 対数的な配列

- フラクショナルカスケーディングが**対数的にサイズ設定されたソート済みの配列**と結合される
- kを因数として増加するサイズを持つイミュータブルなソート済みの配列であり、以前のレベルとマージすることで作成される
- 最上位レベルの配列はヘッドツリーが一杯になると作成される

### 削除の扱い

- ページを上書きせず、同じキーのデータレコードが複数のレベルに存在することもあり得る
- **墓石**（tombstone、FDツリーの論文ではフィルタエントリ）を挿入して削除を表現
- 墓石は対応するキーと関連付けられたデータレコードに削除のマークを付け、下位レベルにあるそのキーのデータレコードをすべて破棄する必要があることを表す
- 墓石が最下位レベルまで伝播すると、無効化できる項目はそれ以上存在しないことが保証されるので、墓石を破棄できる

---

## Bwツリー

書き込みの増幅、利用領域の増幅、同時実行性の問題という3つの問題を同時に解決するために設計されたバズワードツリー（Bw-Tree）。

### アップデートチェーン

**基本構造:**

- Bwツリーは変更をベースノードとは別に書き込む
- 変更（**デルタノード**）はチェーンを形成する
- 最新の変更からのリンクされたリストで、古い変更を経由し、末尾にベースノードが付く
- デルタノードは挿入、更新（挿入と区別できない）、または削除を表すことができる

**ノードの特性:**

- ベースノードとデルタノードのサイズはページと捉うことはほとんどないので、それらを連結して格納することは理にかなっている
- ベースノードとデルタノードはどちらも更新時に変更されることがないので（すべての変更は既存のリンクされたリストにノードを追加するだけ）、余分な領域を確保する必要はない
- ノードを物理的ではなく**論理的な実体**として保持する（ノードが固定サイズになるように要求したり、連続するメモリセグメントに保持したりする必要はない）

### コンペアアンドスワップによる同時実行性の制御

- Bwツリーのノードは**論理的なID**を持ち、それらのIDからディスク上のそれらの場所へのメモリ内のマッピングテーブルを使用する
- ラッチを不要にする点でも役立つ
- 書き込み時に排他的な所有権を取得する代わりに、マッピングテーブル内の物理的なオフセットに対してコンペアアンドスワップ操作を使用する

**ノード更新のアルゴリズム:**

1. ターゲットとなる論理的なリーフノードが、ツリーをルートからリーフへたどることで特定される。マッピングテーブルには更新チェーン内でベースノードまたは最新のデルタノードをターゲットとする仮想リンクが含まれる
2. 新しいデルタノードが、ステップ1で特定されたベースノード、または最新のデルタノードへのポインタを使用して作成される
3. マッピングテーブルが、ステップ2で作成された新しいデルタノードへのポインタを使用して更新される

**並行制御の仕組み:**

- ステップ3における更新操作はコンペアアンドスワップを使用して実行できる（アトミックな操作）
- 読み手または書き手のどちらもブロックしない
- 2つのスレッドが同じ論理ノードに新しいデルタノードをインストールしようとした場合、それらのうち1つのみが成功でき、もう1つは操作を再試行する必要がある

### 構造を変更する操作（SMO）

Bwツリーの論理的な構造はBツリーと類似しており、ノードが大きくなりすぎたり（オーバーフロー）、縮小してほぼ空になったり（アンダーフロー）して、スプリットとマージのような構造を変更する操作（Structure Modification Operations, SMO）が必要になる。

**スプリットのプロセス（2ステップ）:**

1. **スプリット** -- 特別な**スプリットデルタ**が分割されるノードに追加される。分割するノード内のレコードを無効にするためのセパレータキー、新しい論理的な兄弟ノードへのリンクが保持される
2. **親ノードの更新** -- スプリットされたデルタノードのポインタを介してノードにアクセス可能だが、ノードはまだ親から参照されない。読み手が新しく作成された兄弟ノードにアクセスするには古いノードを経由して兄弟ノードのポインタをたどる必要がある

**マージのプロセス（3ステップ）:**

1. **兄弟ノードへのリンクの削除** -- 特別な削除デルタノードが作成され、**右側**の兄弟ノードとして追加される
2. **マージ** -- 右側の兄弟ノードの内容をポイントするために、マージデルタが**左側**の兄弟ノードに作成され、その論理的な一部となるようにする
3. **親ノードの更新** -- 右側の兄弟ノードの内容は左側の兄弟ノードからアクセス可能。マージプロセスを終了するには、右側の兄弟ノードへのリンクを親から削除する

**中断デルタ:**

- 並行して実行されるSMOでは、スプリットとマージの同時実行を防止するために**中断デルタ**（abort delta）ノードを追加で親にインストールする必要がある
- 書き込みロックと似た働きをし、書き込みアクセスを取得できるスレッドは一度に1つのみ

### 統合とガベージコレクション

デルタチェーンが長くなると読み取りのコストも高くなるので、チェーンの長さを合理的な制限内に抑える必要がある。

**統合プロセス:**

- 設定可能な閾値に達したときにベースノードの内容をすべてのデルタとマージし、1つの新しいベースノードに統合する
- 新しいノードはディスク上の新しい場所に書き込まれ、マッピングテーブル内のノードのポインタが更新される
- 基盤となっているログ構造化ストレージがガベージコレクション、ノード統合、再配置を行う機能を提供する

**エポックベースの回収:**

- 特定のノードを通った可能性のあるスレッドと、その可能性がないスレッドを分離するために**エポックベースの回収**を使用
- 特定のエポックの間に統合によって置き換えられたノードとデルタが削除される場合には、同じエポック、またはその前のエポックの間に開始された読み取りがすべて終了するまで、もとのノードは保持される
- その後でガベージコレクションを安全に実行できる

---

## キャッシュオブリビアスBツリー

### 基本概念

ブロックサイズ、ノードサイズ、キャッシュラインのアラインメントなどの設定可能なパラメータがBツリーのパフォーマンスを左右する。**キャッシュオブリビアス**（cache-oblivious）な構造は、基底となるメモリ階層やこれらのパラメータ調整の必要がなく、漸近的に最適なパフォーマンスをもたらす。

**設計思想:**

- キャッシュライン、ファイルシステムのブロック、ディスクページのサイズを知る必要がない（obliviousは「気づかない」という意味）
- 設定が異なるコンピュータ上で変更なしで良好なパフォーマンスを発揮できるように設計
- 2レベルのメモリモデルの観点からデータ構造を推論でき、複数レベルの階層モデルの利点を提供する
- 任意の2レベルのメモリ階層に対して最適化されている場合には、2つの**隣接する階層レベル**にとっても最適に動作する

### キャッシュを意識したアプローチとの比較

- 階層の2つのレベルは**ページキャッシュ**（高速だが容量に制限あり）と**ディスク**（一般的に低速だが大きな容量を持つ）
- パラメータは2つしかないため、アルゴリズムの設計がかなり簡単になる
- ディスクはブロックに分割され、データはブロック単位でディスクとキャッシュの間でやり取りされる
- キャッシュを意識した（cache-aware）アプローチでは、ブロック全体をロードしなければならない

### van Emde Boasレイアウト

キャッシュオブリビアスBツリーは、静的なBツリーとパック配列で構成される。

**静的Bツリーの構築:**

- van Emde Boasレイアウトを使用して作成される
- ツリーを辺の中間レベルで分割し、各サブツリーを同じ方法で再帰的に分割する
- 結果的にサイズが sqrt(N) のサブツリーが生成される
- 再帰的なツリーはメモリの連続したブロックに格納される

### パック配列

データ構造を動的にする（挿入、更新、削除を許容する）手段として、キャッシュオブリビアスツリーでは**パック配列**のデータ構造を利用する。

- 要素の保持に連続するメモリセグメントが使用されるが、将来挿入される要素のために予約されたギャップがその中に含まれる
- ギャップは**密度の閾値**に基づいて間隔が空けられている
- 項目をツリーに挿入する際の再配置を比較的少なくできる

**再構築の条件:**

- パック配列の密度が高くなりすぎたり低くなりすぎたりしたときには、配列を拡張または縮小するために再構築が必要

### 実用上の課題

- 研究開発用以外のキャッシュオブリビアスBツリーの実装は見られない
- キャッシュのロードを抽象化して、データがブロック単位でロードされてから書き戻される際に、ページングと退避がネガティブな影響をもたらすという予想がある
- ブロック転送の観点から見て、キャッシュオブリビアスBツリーの複雑さはキャッシュを意識したBツリーと変わらない

---

## まとめ

| 亜種 | 書き込みの増幅 | 利用領域の増幅 | 同時実行性 | 代表的な実装 |
|------|-----------|-----------|---------|---------|
| コピーオンライトBツリー | ルートまでの経路全コピー | 中程度 | ラッチ不要（イミュータブル） | LMDB |
| 遅延Bツリー | バッファリングで削減 | 中程度 | バックグラウンド処理 | WiredTiger（MongoDB） |
| FDツリー | イミュータブル配列で削減 | サイズ制限あり | フラクショナルカスケーディング | -- |
| Bwツリー | デルタノードで削減 | ログ構造化ストアで削減 | ラッチフリー（CAS） | Sled, OpenBw-Tree |
| キャッシュオブリビアス | パラメータ不要 | パック配列 | 研究段階 | -- |

**共通する設計上のトレードオフ:**

- 書き込みの増幅はバッファリングを使用することで削減できる（WiredTiger、LAツリーではメモリ内のバッファを個々のノードまたはノードのグループに割り当て）
- 利用領域の増幅を削減するためにFDツリーではイミュータビリティを使用する。Bwツリーでもイミュータビリティを使用することで利用領域の増幅を解決する
- Bwツリーでは論理ノード間の仮想ポインタがメモリ内に保持されるので、並行して実行されるアクセスからページを保護するためのラッチを必要としない
