# トランザクション処理とリカバリ

データベースにおけるトランザクションの概念、バッファ管理、ログ先行書き込み（WAL）、ARIESリカバリアルゴリズム、同時実行制御、分離レベル、およびマルチバージョン同時実行制御（MVCC）をまとめる。

---

## 1. ACID特性

トランザクションはデータベース管理システムにおける動作の分割不可能な論理単位であり、読み取りと書き込みが含まれる。4つの特性は一般的に**ACID**と呼ばれる。

| 特性 | 説明 |
|------|------|
| **原子性（Atomicity）** | トランザクションのステップは分割不可能。すべてが成功するか、そのいずれも成功しない。各トランザクションはコミット（変更を可視化）または中断（副作用をすべて戻す）のいずれかを行う |
| **一貫性（Consistency）** | データベースのすべての特性（制約、参照整合性など）を維持したまま、ある有効な状態から別の有効な状態に変えること。もっとも定義の弱い特性で、ユーザーによっても制御される |
| **分離性（Isolation）** | 並行して実行される複数のトランザクションは、干渉を受けずに実行できる必要がある。多くのデータベースではパフォーマンス上の理由から、指定された分離性の定義より弱い分離レベルを使用する |
| **永続性（Durability）** | トランザクションがコミットされると、すべての変更をディスク上に永続化する必要がある。電源やシステムの障害、クラッシュなどに耐えられるようにしなければならない |

---

## 2. バッファ管理

大半のデータベースは2つのレベルの記憶階層を使用して構築されている。比較的低速な永続ストレージ（ディスク）と高速なメインメモリ（RAM）である。

### 2.1 ページキャッシュ（バッファプール）

永続ストレージ（ディスク）とストレージエンジンの残りの部分との間で仲介の役割を果たす。メインメモリ内の状態変化を段階的に行い、永続ストレージと同期されていないページのキャッシュとして機能する。

**主要な機能:**
- キャッシュされたページの内容をメモリ内に保持する
- ディスク上のページに対する変更をまとめてバッファリングし、キャッシュされたバージョンに対して変更を適用する
- 要求されたページがメモリ内に存在しない場合は、ページキャッシュにページインされ、そのキャッシュされたバージョンが返される
- すでにキャッシュされているページが要求された場合は、そのキャッシュされているバージョンが返される
- 新しいページに十分な空き容量がない場合には、いずれかのページの内容をディスクにフラッシュし、そのページを**退避**させる

**カーネルページキャッシュのバイパス**: 多くのデータベースシステムは `O_DIRECT` フラグを使用してファイルを開き、I/Oシステムコールでカーネルのページキャッシュをバイパスして、ディスクに直接アクセスし、データベース固有のバッファ管理を使用する。

### 2.2 キャッシュの概要

- バッファに加えられたすべての変更は、最終的にディスクに書き戻されるまでメモリ内に保持される
- メモリからディスクへの一方通行の同期プロセスとなる（逆はない）
- ページキャッシュにより、ディスクアクセスを抽象化し、物理的な書き込み操作から論理的な書き込み操作を分離する
- ページが返されると、そのページの内容が含まれるバッファは**参照済み（referenced）**となり、ページを**ピン留め**することで退避させないように指定できる
- ページが変更されると**ダーティ**フラグが設定され、その内容がディスクと同期していないことを示す

### 2.3 キャッシュの退避

ページキャッシュは容量に限りがあるので、新しいページをページインするには古いページの退避が必要になる。

**退避の条件:**
- ページの内容がディスクと同期している場合（フラッシュ済み、変更なし、ピン留め/参照なし）は即座に退避させられる
- ダーティなページを退避させるには、その前にフラッシュする必要がある
- 参照されているページは、他のスレッドで使用されている間は退避させるべきではない

**永続性の確保**: フラッシュはチェックポイントプロセスと協調して動作する。チェックポイントプロセスはログ先行書き込み（WAL）とページキャッシュを制御し、それらが連携して動くようにする。WALから廃棄できるのは、フラッシュされたキャッシュ済みのページに適用された操作に関連するログレコードのみ。

### 2.4 キャッシュにおけるページのロック

Bツリーは上に向かうほど狭くなるので、上位レベルのノード（ルートに近いノード）は大半の読み取りでヒットする。少なくとも、キャッシュされることで大きな利益を得られるツリーの一部が、常に存在するということである。

**ピン留め**: 近い将来に特定のページを使用する見込みが高い場合には、キャッシュ内のページをロック（ピン留め）する。ピン留めされたページは通常より長い時間メモリ内に保持され、ディスクアクセスの回数を削減し、パフォーマンスの改善に役立つ。

Bツリーの各下位ノードレベルでは、上位のノードレベルよりノードの数が著しく多くなっている。上位レベルのノードはツリーのごく一部を表すにすぎないので、ツリーのこの部分はメモリ内に常駐させられる。

### 2.5 ページの置換

ページキャッシュの容量限界に達したときに、新しいページをロードするには古いページを退避させる必要がある。**退避ポリシー**（ページ置換ポリシー）に従って、すぐに再アクセスされる可能性のもっとも低いページの検出が試みられる。

#### FIFO

もっとも単純な置換戦略は**先入れ先出し（FIFO）**。ページIDのキューをページの挿入順で維持し、新しいページをキューの末尾に追加する。後続のページアクセスを考慮しておらず、ほとんどの現実世界のシステムで実用的ではない。

#### LRU（Least Recently Used）

FIFOの自然な拡張として生まれた**もっとも長い間使われていない**ページを退避する戦略。退避候補のキューが挿入順で維持されるが、ページが繰り返しアクセスされたときにキューの末尾に戻すことが可能。ただし、アクセスされるごとに参照を更新しノードを再リンクするため、並行実行される環境ではコストが高くなる。

LRUの亜種:
- **2Q（Two-Queue LRU）**: 2つのキューを管理し、初めてアクセスされたときには第一のキューにページを入れ、それ以降にアクセスされたときには第二のホットキューに移動して、最近アクセスされたページと頻繁にアクセスされたページの区別を可能にする
- **LRU-K**: 最新のKアクセスを記録し、ページ単位でのアクセス回数を見積もることで頻繁に参照されるページを識別する

#### CLOCK

CLOCKアルゴリズムはLRUの亜種で、コンパクトでキャッシュを有効活用でき、LRUに対する並行性を持つ代替手段。ページへの参照とアクセスビットを循環バッファに保持する。

動作原理:
1. アクセスビットが1で、ページが参照されていない場合、アクセスビットを0に設定し、次のページを検査
2. アクセスビットがすでに0になっている場合、そのページは候補になり、退避が予定される
3. ページが現在参照されている場合、そのアクセスビットは変更されずに維持される（退避されにくくなる）

#### LFU（Least-Frequent Used）

ページインのイベントではなく**ページ参照イベント**を考慮し、使用頻度がもっとも低いページを追跡する。

**TinyLFU**: ページの最新性に基づいてページを退避させる代わりに、**使用頻度**に従って退避させる。頻度ヒストグラムを使用してコンパクトなキャッシュアクセス履歴を保持する。要素は以下3つのキューに分類:
- **入場（admission）**: 新しく追加された要素を管理。LRUポリシーで実装
- **保護観察（probation）**: 退避させられる可能性が高い要素を保持
- **保護対象（protected）**: 長時間キュー内に置いておく予定の要素を保持

---

## 3. リカバリ

データベースシステムは複数のハードウェアとソフトウェアのレイヤ上に構築されており、それぞれに安定性と信頼性の問題がある。書き込みが**約束された**データは、実際に書き込まれるようにしなければならない。

### 3.1 ログ先行書き込み（WAL）

**ログ先行書き込み**（Write Ahead Logging、WALまたはコミットログ）は、クラッシュおよびトランザクションリカバリに使用される追記型の補助的なディスク上の構造。

**主要な機能:**
- データベースシステム全体として永続性を保証しつつ、ディスク上のページへの更新をページキャッシュでバッファリングすることを可能にする
- データベースの状態を変更するすべての操作は、関連するページの内容を変更する**前に**、ディスク上のログに記録される必要がある
- クラッシュが発生した場合に、失われたメモリ内の変更が操作ログから再構築できるようにする
- 中断されたトランザクションによって行われた変更のundo（もとに戻す）のためにも使用される

### 3.2 ログの概要

WALは追記型のイミュータブルなデータ構造。すべてのレコードは、ユニークで単調に増加する**ログシーケンス番号（LSN）**を持つ。LSNは内部カウンタまたはタイムスタンプで表される。

- ログレコードは必ずしも1つのディスクブロック全体を使用するとは限らないので、その内容は**ログバッファ**にキャッシュされる
- **強制的な書き込み（force）** は、ログバッファが一杯になったときに実行され、トランザクションマネージャやページキャッシュから要求することもできる
- すべてのログレコードはLSNの順序でディスクにフラッシュされなければならない
- トランザクションは、そのコミットレコードのLSNまでログが強制されない限り、コミットされたとはみなされない

**補償ログレコード（CLR）**: ロールバック時やリカバリ時にundoを行うときに使用し、それらをログに格納する。

**チェックポイント**: 特定のマークまでのログレコードが完全に永続化され、それ以降必要とされないことをログが認識するための手段。データベースの起動時に必要な作業量が大幅に削減される。

#### 同期チェックポイントとファジーチェックポイント

- **同期チェックポイント**: すべてのダーティページを強制的にディスクにフラッシュするプロセス。すべての実行中の操作を一時停止させることになるため現実的ではない
- **ファジーチェックポイント**: `begin_checkpoint` という特別なログレコードで始まり、`end_checkpoint` ログレコードで終了する。`end_checkpoint` にはダーティページ、トランザクションテーブルの内容に関する情報が含まれる。ページは非同期にフラッシュされ、完了すると `last_checkpoint` レコードが `begin_checkpoint` レコードのLSNで更新される

### 3.3 操作とデータログ

データベースの中には、**シャドウページング**を使用するものがある。データの永続性とトランザクションの原子性を保証するコピーオンライトのテクニックで、新しい内容は新しい未公開のシャドウページに置かれ、ポインタのフリップを使用して古いページから更新済みの内容が保持されているページに切り替えて可視化する。

**更新前イメージと更新後イメージ:**
- 更新前イメージにredoを適用すると、更新後イメージが生成される
- 更新後イメージにundoを適用すると、更新前イメージが生成される

**物理ログと論理ログ:**
- **物理ログ**: 完全なページの状態またはそれに対するバイト単位の変更が格納される。redo時にはページ全体が必要
- **論理ログ**: 現在の状態に対して実行する必要のある操作が格納される。ページにどの操作を適用するかが指定される

実際のところ、多くのデータベースシステムはこれら2つのアプローチを組み合わせて使用する。論理ログを使用して同時実行性とパフォーマンスのためにundoを実行し、物理ログを使用してリカバリ時間を改善するためにredoを実行する。

### 3.4 stealポリシーとforceポリシー

メモリ内で行われた変更をいつディスクにフラッシュすべきかを決定するために、steal/no-stealポリシーとforce/no-forceポリシーを定義する。

| ポリシー | 説明 |
|---------|------|
| **steal** | トランザクションによって変更されたページのフラッシュを、そのトランザクションがコミットされる前であっても許容する |
| **no-steal** | コミットされていないトランザクションの内容をディスクにフラッシュすることを許容しない |
| **force** | トランザクションがコミットされる前に、変更されたすべてのページをディスクにフラッシュする必要がある |
| **no-force** | トランザクションの間に変更されたページの中にまだディスク上にフラッシュされていないページがあったとしても、トランザクションをコミットすることを許容する |

- **no-steal** を使用すると、redoのエントリのみを使用したリカバリの実装が可能になる
- **no-force** を使用すると、ページに対するいくつかの更新を遅延させバッファリングできるが、より大きなページキャッシュが必要になる可能性がある
- **force** を使用すると、クラッシュリカバリにおいて追加作業を行わなくても、コミット済みのトランザクションの結果を再構築できる

### 3.5 ARIES

ARIESで採用されているリカバリのアルゴリズムは **steal/no-force** である。物理的なredoを使用してリカバリ時の変更をより速く反映させパフォーマンスを改善する一方、論理的なundoを使用することで独立してページに適用でき、同時実行性を改善する。WALレコードを用い、undoするための補償ログレコードを作成する。

データベースシステムがクラッシュの後で再起動されると、リカバリは以下の**3つのフェーズ**で進められる:

1. **分析フェーズ**: クラッシュ時にページキャッシュ内でダーティだったページと進行中だったトランザクションを特定する。ダーティページに関する情報はredoフェーズの開始点を特定するために使用される。進行中のトランザクションのリストは不完全なトランザクションをロールバックするためにundoフェーズで使用される

2. **redoフェーズ**: クラッシュした箇所まで履歴を繰り返し処理し、データベースを以前の状態に復元する。不完全なトランザクションだけでなく、コミットはされたが内容が永続ストレージにフラッシュされなかったトランザクションに対しても実行される

3. **undoフェーズ**: 不完全なトランザクションをすべてロールバックし、データベースを最新の一貫性の取れた状態に復元する。すべての操作が時間的に順序を逆にしてロールバックされる。リカバリ中にデータベースが再度クラッシュしてしまう場合に備えて、undoが繰り返されることを避けるために、トランザクションをundoする操作もログに記録される

ARIESでは、ログレコードの識別にLSNが使用され、ダーティページテーブルでトランザクションの実行で変更されたページを記録し、物理的なredo、論理的なundo、およびファジーチェックポイントが使用される。

---

## 4. 同時実行制御

並行して実行されているトランザクション間の相互作用を処理するための一連の技術。おおよそ以下のカテゴリにグループ化できる。

| カテゴリ | 説明 |
|---------|------|
| **楽観的同時実行制御（OCC）** | 読み取りと書き込みを並行して実行し、結合された実行の結果が直列化可能であるかどうかを判断する。競合が発生する場合には、競合しているトランザクションの一方が中断させられる |
| **マルチバージョン同時実行制御（MVCC）** | レコードのタイムスタンプ付きのバージョンが複数存在するのを許容し、タイムスタンプによって識別される過去のある時点におけるデータベースの一貫性のビューを保証する |
| **悲観的同時実行制御（PCC）** | ロックベースとロックなしの保守的な手法。実行中にトランザクションの競合を特定して、それらの実行をブロックまたは中断する |

### 4.1 直列化可能性

**スケジュール**は、データベースシステムの観点から見たときに一連のトランザクションを実行するために必要な操作のリスト。スケジュールがその中のトランザクションが完全に独立して、インターリーブなしで実行されるとき**シリアル**であると言われる。

複数のトランザクション操作を並行して実行し、その一方でシリアルなスケジュールの正確性と単純性を維持する方法を見い出すことが必要。スケジュールが直列化可能になるのは、同じ一連のトランザクションに対する特定のシリアルなスケジュールと完全に等価な場合。

### 4.2 トランザクションの分離

**分離レベル**は、いつ、どのようにしてトランザクションの各部分を他のトランザクションに対して可視化できるか、および可視化すべきかを指定する。分離を達成するにはコストがかかり、不完全な書き込みや一時的な書き込みがトランザクションの境界を超えて伝播するのを防ぐために、調整と同期が必要になり、パフォーマンスに悪影響をおよぼす。

### 4.3 読み取りと書き込みのアノマリー

SQL標準では、並行トランザクションの実行時に発生する**読み取りのアノマリー**（ダーティリード、ノンリピータブルリード、ファントムリード）と**書き込みのアノマリー**（ロストアップデート、ダーティライト、ライトスキュー）が定義されている。

| アノマリー | 説明 |
|---------|------|
| **ダーティリード** | 他のトランザクションのまだコミットされていない変更をトランザクションが読み取る可能性のある状況 |
| **ノンリピータブルリード** | 同じ行への問い合わせを2回行い、異なる結果を得る場合。T1が読み取り、T2がその行を修正しコミットした後、T1が再度要求した場合に結果が前回と異なる |
| **ファントムリード** | 範囲読み取りを使用した場合に、単一レコードではなく一定の範囲のレコードを読み取る場合に発生する。T1が同じ行のセットを2度要求し、異なる結果を受け取った場合。範囲に対するクエリになる |
| **ロストアップデート** | T1とT2がVの値の更新を試みたとき、T1がVを更新してコミットし、その後でT2もVを更新して同様にコミットする。両方のコミットが許容されれば、T1の結果はT2の結果で上書きされ、T1による更新は失われる |
| **ダーティライト** | トランザクションの1つがコミットされていない値を受け取って、ダーティリードして、それを変更してから保存した状況 |
| **ライトスキュー** | 必要とされる要件を個々のトランザクションは順守しているが、その組み合わせがこれらの要件を満たさなくなる場合に発生する |

### 4.4 分離レベル

| 分離レベル | ダーティリード | ノンリピータブルリード | ファントムリード |
|---------|---------|---------|---------|
| **read uncommitted** | 許容 | 許容 | 許容 |
| **read committed** | - | 許容 | 許容 |
| **repeatable read** | - | - | 許容 |
| **serializability** | - | - | - |

- **read uncommitted**: もっとも低い分離レベル。あるトランザクションから他の並行トランザクションのコミットされていない変更を見ることが許容される（ダーティリードが許容される）
- **read committed**: 特定のトランザクションによってすでにコミットされた変更のみを読み取るようにすることが可能。ダーティリードは許容されないが、ファントムリードとノンリピータブルリードは許容される
- **repeatable read**: ノンリピータブルリードを許容しない。ファントムリードは許容される
- **serializability**: もっとも強い分離レベル。複数のトランザクションがシリアルに、つまり時間的な重なりがない状態で実行されたかのように、トランザクションの結果が特定の順序で現れることが保証される

### 4.5 スナップショット分離

データベースの中には**スナップショット分離**を使用するものがある。スナップショット分離においてトランザクションは、それが開始された時点までにコミットされたすべてのトランザクションによる状態変更を見ることができる。それぞれのトランザクションはデータのスナップショットを取得し、そのスナップショットに対してクエリを実行する。

- トランザクションの実行中にはスナップショットは変更できない
- その実行中に自身が変更した値が他に変更されていない場合に限ってコミットする。それ以外の場合には中断されてロールバックされる
- これにより**ロストアップデート**のアノマリーを排除する
- ただし、スナップショット分離のもとでは**ライトスキュー**のアノマリーが発生する可能性がある

---

## 5. 楽観的同時実行制御（OCC）

トランザクションの競合はめったに発生しないことを前提とし、ロックを使用してトランザクションの実行をブロックする代わりにトランザクションを検証する。トランザクションの実行は以下**3つのフェーズ**に分割される:

| フェーズ | 説明 |
|---------|------|
| **読み取りフェーズ** | トランザクションはプライベートなコンテキストの中で実行し、他のトランザクションに対してその変更を可視化しない。このステップで書き込みセットと読み取りセットが認識される |
| **検証フェーズ** | 操作間に直列化可能性に違反するかもしれない競合の存在について、並行トランザクションの読み取りセットと書き込みセットが検査される。競合がなければコミット |
| **書き込みフェーズ** | 検証フェーズで競合だと判断されなかった場合、書き込みセットをプライベートなコンテキストからデータベースに反映しコミットできる |

検証は、すでにコミットされているトランザクションと競合があるか（後方指向）、あるいは現在検証フェーズにあるトランザクションと競合があるか（前方指向）を確認することで行われる。

楽観的な同時実行には、まだ**クリティカルセクション**が存在する。このセクションでは同時に1つのトランザクションしか入れない。別のアプローチとして、非排他的な所有権をいくつかの操作に許容する場合には、**readers-writerロック**（複数の読み手に共有アクセスを許容）とアップグレード可能なロック（共有ロックの排他的操作への変更を必要に応じて許容）を使用する。

---

## 6. マルチバージョン同時実行制御（MVCC）

複数のレコードバージョンを許容し、単調に増加するトランザクションIDまたはタイムスタンプを使用することで、データベース管理システムでトランザクションの一貫性を達成する方法。ストレージレベルで最低限の調整を行うだけで読み取りと書き込みが進行するのを許容し、新しい値がコミットされるまで読み取りが古い値にアクセスし続けることができる。

**主な特徴:**
- コミットされたバージョンとコミットされていないバージョンを区別する
- 最後にコミットされた値のバージョンが現在の値であると想定される
- トランザクションマネージャの目的は、その時点において最大でも1つの未コミットの値を持つこと
- データベースシステムによって実装された分離レベルに応じて、読み取り操作は未コミットの値へのアクセスが許容される場合と許容されない場合がある

MVCCの主要なユースケースの1つは**スナップショット分離**の実装。マルチバージョンな同時実行では、ロック機能、スケジュール機能、および競合解決技術（たとえば二相ロックなど）、またはタイムスタンプによる順序付けを使用して実装できる。

---

## 7. 悲観的同時実行制御

楽観的同時実行制御より保守的なアプローチ。実行中にトランザクションの競合を特定して、それらの実行をブロックまたは中断する。

### 7.1 タイムスタンプによる順序付け

もっとも単純な悲観的（ロックフリー）同時実行制御の考え方の1つ。トランザクションはそれぞれタイムスタンプを持つ。トランザクション操作を実行できるかどうかは、より早いタイムスタンプを持つトランザクションがすでにコミットされているかどうかによって決定される。

トランザクションマネージャは値ごとに `max_read_timestamp` と `max_write_timestamp` を管理する必要がある。これは**トーマスの書き込みルール**呼ばれ、読み取り操作または書き込み操作が実行されると、すぐに対応するタイムスタンプの最大値が更新される。

### 7.2 ロックベースの同時実行制御

データベースオブジェクトに対して明示的なロックを使用する。もっとも広く普及しているロックベースの技術の1つは、**二相ロック（2PL）**。

**2PLの2つのフェーズ:**
- **成長フェーズ（拡張フェーズ）**: トランザクションによって要求されたロックがすべて獲得され、解放されるロックがない期間
- **縮退フェーズ**: 成長フェーズの間に獲得されたロックがすべて解放される期間

重要な点として、これらのフェーズのどちらの間においてもトランザクションがステップを実行することを2PLは妨げない。

### 7.3 デッドロック

2つのトランザクションが実行を進めるために必要なロックの獲得を試みている間に、それぞれが保持しているロックの解放をお互いに待機しなければならない状況。

**対処方法:**
- **タイムアウト**: 長時間実行されているトランザクションを中止する
- **保守的な2PL（C2PL）**: トランザクションが操作を実行するには、その前にすべてのロックを獲得することが必要とされる
- **waits-forグラフ**: 実行中のトランザクション間の関係を追跡し、循環が見つかれば最後にロックの獲得を試みたトランザクションを中止する

**デッドロック回避のための優先順位制約:**
- **Wait-die**: T1がブロックしてロックを待機することを許可する。それ以外の場合、T1は中止され再起動される。トランザクションは、より高いタイムスタンプを持つトランザクションによってのみブロックされる
- **Wound-wait**: T2が中止され再起動される（T1がT2を傷つける）。T2がT1より前に開始されていた場合、T1は待機することが許可される。トランザクションは、より低いタイムスタンプを持つトランザクションによってのみブロックされる

### 7.4 ロックとラッチ

トランザクション処理では、論理的なデータの整合性を保護する仕組みと物理的なデータの整合性を保護する仕組みは区別されている。

| 概念 | 目的 | スコープ |
|------|------|------|
| **ロック（錠）** | 重複しているトランザクションを分離してスケジュールし、データベースの内容を管理する | キーに基づいて行われ、ツリーの実装の外部で保持および管理される。トランザクションの持続期間に渡って保持 |
| **ラッチ（掛け金）** | リーフページの内容が挿入、更新、および削除の操作の間に変更されるのを保護する | ページレベルで獲得される。物理的なツリー構造（ページの内容とツリー構成）を保護 |

### 7.5 readers-writerロック

**RWロック（readers-writer ロック）** を使用して、複数の並行する書き込みプロセスが重複しないようにすること、および読み取りプロセスが書き込みプロセスと重複しないようにすることを実現する。

| | 読み取りプロセス | 書き込みプロセス |
|---|---|---|
| **読み取りプロセス** | 共有 | 排他 |
| **書き込みプロセス** | 排他 | 排他 |

読み取りプロセスのみがロックの所有権を共有できるが、それ以外の読み取りプロセスと書き込みプロセスの組み合わせでは、排他的な所有権を取得する必要がある。

### 7.6 ラッチクラビング

ラッチを取得するためのもっとも単純なアプローチは、ルートからターゲットリーフまでの経路上のラッチをすべて獲得すること。しかしこれは並行性のボトルネックとなるため、ラッチが保持される時間を最小化する**ラッチクラビング**（ラッチカップリング）が使用される。

- ラッチを保持する時間をなるべく短くし、操作の実行にそれらが必要ではないことが明らかになった時点で即座に解放する
- 読み取り経路では子ノードが特定され、そのラッチが取得されたら、即座に親ノードのラッチを解放できる
- 挿入処理では、親ノードに伝播される構造的な変更をもたらさないことが保証された場合に、親ノードのラッチを解放できる（子ノードが一杯でない場合）

このアプローチは楽観的である。大半の挿入と削除の操作では、複数の上位レベルに伝播するような構造的な変更が発生しないため、ほとんどの操作でラッチが必要になるのはターゲットのノードのみ。

### 7.7 Blinkツリー

B^linkツリーはBツリーのリバランシングの上に構築され、**ハイキー**（Node High Key）と**兄弟ノードへのリンクポインタ**を追加する。ルート以外のすべてのノードは2つのポインタを持つ: 親から下降していく子ポインタと、同じレベルに存在する左隣のノードからの兄弟ノードリンク。

- **ハーフスプリット**と呼ばれる状態が許容される。ノードが兄弟ノードからのポインタによってすでに参照されているが、その親からは子ポインタによって参照されていない状態
- 検索キーがノードのハイキーを超えた場合、検索アルゴリズムは兄弟ノードへのリンクに従って検索を続行する
- 最善のパフォーマンスを保証するには、ポインタを親ノードに迅速に追加する必要があるが、検索プロセスを中断し再起動する必要はない（ツリー内の要素がすべてアクセス可能だから）
- スプリットは比較的まれな操作であり、Bツリーが縮小されることはあまりないので、このケースは例外的で、コストは取るに足らないもの
- 利点: 競合を減らし、スプリット時に親がロックを保持するのを防ぎ、ツリー構造の変更時に保持されるロックの数を一定の数まで削減する。構造的なツリーの変更と並行して読み取りを可能にすることが重要

---

## まとめ

| 概念 | 要点 |
|------|------|
| ACID | 原子性、一貫性、分離性、永続性の4特性 |
| バッファ管理 | ページキャッシュによるディスクI/O抽象化。FIFO/LRU/CLOCK/LFU等の置換戦略 |
| WAL | 追記型イミュータブルログ。LSNで順序管理。変更前にログ記録が必須 |
| ARIES | steal/no-forceポリシー。分析・redo・undoの3フェーズでリカバリ |
| 同時実行制御 | 楽観的（OCC）、悲観的（PCC）、マルチバージョン（MVCC）の3カテゴリ |
| 分離レベル | read uncommitted < read committed < repeatable read < serializability |
| MVCC | 複数バージョンを許容しタイムスタンプで管理。スナップショット分離の基盤 |
| ロック/ラッチ | ロックは論理的整合性（トランザクション単位）、ラッチは物理的整合性（ページ単位） |
| Blinkツリー | ハイキー + 兄弟リンクで並行性を向上。ハーフスプリットを許容 |
