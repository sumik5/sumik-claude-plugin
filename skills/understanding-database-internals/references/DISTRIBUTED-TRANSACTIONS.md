# 分散トランザクション

分散システムでの複数ノード間での一貫性のあるトランザクション実行を実現する手法。

## 概要

分散トランザクションでは、複数ノードに分散したデータに対してアトミック（全成功または全失敗）な操作を保証する必要がある。主なチャレンジは以下の通り：

- **ネットワーク分断への対応**: ノードが通信不能になる可能性
- **部分障害の処理**: 一部ノードが失敗した場合の全体ロールバック
- **パフォーマンスとスケーラビリティ**: 調整コストの最小化
- **一貫性と可用性のトレードオフ**: CAP定理の制約

---

## コアコンセプト

### アトミックに見せる操作

分散環境において、複数ノードでの操作をアトミックに見せるためには以下が必要：

- **All-or-Nothing保証**: すべての参加ノードで成功するか、すべて失敗するか
- **一貫性の維持**: 中間状態を外部に晒さない
- **分離性**: 他のトランザクションと干渉しない
- **永続性**: コミット後の変更は失われない

### トランザクションマネージャー

分散トランザクションを統括するコンポーネント：

- **コーディネーター**: トランザクション全体の調整を担当
- **コホート（参加者）**: 実際にデータを保持し操作を実行するノード
- **トランザクションログ**: 状態遷移と決定を永続化

---

## ツーフェーズコミット（2PC）

最も基本的な分散コミットプロトコル。

### プロトコルフロー

#### 準備フェーズ（Prepare Phase）

1. **コーディネーター**: すべてのコホートに準備メッセージを送信
2. **コホート**: トランザクションをコミット可能か判断
   - 可能な場合: 投票結果をコーディネーターに返信（準備完了状態に遷移）
   - 不可能な場合: 否定応答を返しトランザクション中断

#### コミット/中断フェーズ（Commit/Abort Phase）

3. **コーディネーター**: すべてのコホートが肯定応答した場合
   - **コミット**: すべてのコホートにコミットメッセージを送信
   - **中断**: 1つでも否定応答があれば、すべてのコホートに中断メッセージを送信

4. **コホート**: コミットまたは中断を実行し、完了を応答

### コホート障害シナリオ

| 障害発生タイミング | 影響 | 対処 |
|------------------|------|------|
| 準備前 | トランザクション未開始 | タイムアウト後にコーディネーターが中断 |
| 準備後、投票返信前 | コーディネーターは応答待ち | タイムアウト後に中断決定 |
| コミット/中断受信後 | 実行できず | コーディネーターが再送、最終的に手動介入 |

**特徴**:
- コホートの1つが利用不可でもコーディネーターは中断可能
- 準備完了状態のコホートは、コーディネーターの決定を待つ必要がある

### コーディネーター障害シナリオ

| 障害発生タイミング | 影響 | 対処 |
|------------------|------|------|
| 準備メッセージ送信前 | トランザクション未開始 | コホートはタイムアウトで中断 |
| 準備フェーズ中 | コホートは準備完了状態で待機 | **ブロッキング問題**: コホートは決定不可 |
| コミット/中断送信後 | 一部コホートが未実行の可能性 | バックアップコーディネーターが引き継ぎ、またはログから復旧 |

**ブロッキング問題**（2PCの主要な欠点）:
- コーディネーターがクラッシュした場合、準備完了状態のコホートは決定を知る術がない
- コホートはロックを保持し続け、他のトランザクションをブロック
- 可用性が大幅に低下

---

## スリーフェーズコミット（3PC）

2PCのブロッキング問題を解消するために準備フェーズを追加したプロトコル。

### プロトコルフロー

#### 提案フェーズ（Propose Phase）

1. コーディネーターが提案を送信し、投票を収集
2. すべてのコホートがコミット可能と応答した場合、準備フェーズへ

#### 準備フェーズ（Prepare Phase）

3. コーディネーターが投票結果についてコホートに通知
4. コホートは準備メッセージを受け取り、準備完了状態に遷移（またはタイムアウトで中断）

#### コミット/中断フェーズ（Commit/Abort Phase）

5. コーディネーターが準備フェーズの結果をすべての参加ノードに通知
6. それらのタイムアウトカウントをリセットして、実際にトランザクションを終了

### コーディネーター障害への対処

3PCでは、ネットワーク分断時に以下のルールでノンブロッキングを実現：

- **準備フェーズ前の障害**: コホートはタイムアウト後にコミット済みノードが存在しないことを確認し中断
- **準備フェーズ中の障害**: スプリットブレインを引き起こしノードの中にはコミット準備をするものもあり、すべてはプロトコルに従って動作する
- **現在の状態に基づく決定**: 準備済みの状態にあるノードがタイムアウト後にコミット継続

**3PCの理論的限界**:
- メッセージのオーバーヘッドが増加し、遅延に弱くなる
- ネットワーク分断が発生した場合、依然としてスプリットブレインのリスクあり
- 2PCのブロッキングに関する問題をある程度軽減するが、ネットワーク分断には脆弱

---

## Calvinによる分散トランザクション

決定論的なトランザクションの実行順序を事前に決めることで、調整コストを削減する方式。

### アーキテクチャ

```
パーティション → シーケンサ → スケジューラ → ワーカー → ストレージ
```

#### 主要コンポーネント

- **シーケンサ**: トランザクションを受信し、すべての参加ノードが合意したグローバルなシーケンス番号を割り当て
- **スケジューラ**: トランザクション実行順序を管理し、依存関係を解決
- **ワーカー**: 実際にトランザクションを実行、結果をローカルストレージに永続化

### 動作フロー

1. **読み取り/書き込みセットと書き込みセットを分析**: トランザクションが必要とするデータレコードを特定し、アクティブな参加ノード（書き込みセットの要素を保持している）のリストを作成
2. **ローカルデータを取集**: トランザクション実行のために必要なローカルデータを収集
3. **アクティブな参加ノードで実行**: ワーカースレッドがアクティブな参加ノードで実行される場合、他のノードから転送されたデータレコードを受け取る
4. **結果をローカルストレージに永続化**: 実行結果を他のノードに転送、結果をそれぞれローカルに永永続化

### 特徴

| 項目 | 説明 |
|------|------|
| **並行制御** | 決定論的なスケジューリング（事前に順序確定） |
| **複製処理** | Paxosコンセンサスアルゴリズム、または非同期レプリケーション |
| **トランザクション実行前の準備** | シーケンサでの合意によるエポック単位のバッチ処理 |
| **パフォーマンス** | 処理が複数エポック/パッチに入るかについて、シーケンサが確実に合意できるようにするために、Paxosの間では障害が発生したリーダーの状態をノードが再生成する必要がある |

**メリット**:
- 実行フェーズでの調整オーバーヘッドがなくなり、すべてのレプリカが同じ入力を受け取る
- 同等の出力を生成するようになり、同等の出力を生成するようになる

**デメリット**:
- 処理が発生するまでに遅延が生まれる（エポックの境界）
- トランザクションを順調に相似させる必要はあります

---

## Spannerによる分散トランザクション

Google Spannerが採用する、TrueTime APIを活用した外部一貫性を持つ分散トランザクション方式。

### TrueTimeとは

高精度のウォールクロック（実時間）APIで、不確実性の境界を明示的に扱える：

```
TT.now() = [earliest, latest]
```

- **TT.now()**: 現在時刻の不確実性区間を返す
- **不確実性**: GPSとアトミッククロックの組み合わせでマイクロ秒オーダーに抑制

### トランザクションタイプ

#### 読み取り書き込みトランザクション（Read-Write）

- ロック、2PCを使用し、クロステーブルの読み取り/書き込みトランザクション
- 最新のタイムスタンプでの読み取りにのみ、リーダーが必要

#### 読み取り専用トランザクション（Read-Only）

- とのレプリカでも実行でき、最新のタイムスタンプでの読み取り
- 特定のタイムスタンプでの読み取りであり、読み取り専用の場合の最大のタイムスタンプよりも古い場合、特定のタイムスタンプより古いタイムスタンプを持つ任意のレプリカで読み取りを実行できる

#### スナップショット読み取り（Snapshot Read）

- 特定のタイムスタンプや過去のタイムスタンプでの読み取り
- 各データレコードはタイムスタンプが割り当てられており、トランザクションのコミット時刻の値が保持されている

### 外部一貫性（External Consistency）の保証

Spannerの読み取り書き込みトランザクションは、外部一貫性（直列化可能性と同等のリアルタイムの特性を持つ）を保証する：

- トランザクションのタイムスタンプは、分散トランザクションの場合でも厳密化可能性と同等のリアルタイムの特性を持つ
- T1のタイムスタンプは、T2のタイムスタンプよりかさくなる
- これはすべての読み取りとすべての書き込みに適用される

### 2PCとTrueTimeの統合

Spannerは、一貫性のあるトランザクションログのレプリカを持つPaxosグループと、クロスシャード（複数シャード間の一貫性を保証するためのロックテーブルと、マルチシャードの分散トランザクションを管理するトランザクションマネージャーを使用して2PCを使用し、決定論的なトランザクションの順序付けにTrueTimeを使用：

1. **グループリーダーは一貫性を確保するために協調**: 2PCのロックテーブルへの問い合わせを行なってトランザクションの順序比とシャード内の一貫性を保証するのに十分なかを調べる
2. **2PCとTrueTimeの相互接続**: CalvinにおけるコストとデコストがあるのでPaxosグループの中でも2PCは操作を実行することを意味します
3. **パーティション化された分散データにおいてトランザクションの実行順序を可能にする**: そのアプローチはパーティション化された分散データにおいてトランザクションの実行順序を可能にするので、両方とも理解する必要があります

---

## データベースパーティショニング

データを複数ノードに分散して管理し、スケーラビリティを確保する手法。

### パーティショニング方式

| 方式 | 説明 | メリット | デメリット |
|------|------|---------|----------|
| **レンジベース** | データを複数の範囲に分割し、レプリケーションのみで管理 | 範囲クエリが効率的 | ホットスポットが発生しやすい |
| **ハッシュベース** | ハッシュ関数を使用してノードを決定 | 負荷分散が均等 | 範囲クエリが非効率 |
| **コンシステントハッシュ** | ノード追加/削除時のリバランス最小化 | 動的なスケーリングに適している | 実装が複雑 |

### コンシステントハッシュ法

Apache CassandraやRiakなどの一部のデータベースで使用される方式。

#### 基本原理

- **ハッシュリング**: ノードとデータをハッシュ化してリング上に配置
- **仮想ノード**: リングに各ノード（リソースに依存して）ごとに複数の仮想ノードの位置と自身の位置の間にある値の範囲を管理
- **リバランス**: ノードが追加されたり削除されたりした場合、hash(v) modulo Nから変えられる多くの値がもとの値と異なる点

**特徴**:
- クラスタのサイズを増やした分け（モジュロ、つまり余りを取る）をとります
- システム内にK個のノードがある場合、ターゲットとなるノードIDは、hash(v) modulo Nを計算して求める
- このアプローチの主な欠点は、ノードが追加されたり削除されたりした場合、クラスタサイズがNからN'に変更されるために、hash(v) modulo N'から返される多くの値がもとの値と異なる点

**コンシステント**という用語は、定義上、ハッシュテーブルのサイズが変更されるときに、K個の取り得るハッシュキーとN個のノードを持つシステムにおいて平均的にK/Nの範囲と直線上に配置して、最も自近いハッシュを持つ分値はごコンシステントハッシュ法既設の出力は、関税の範囲に変更がない、ということになります

---

## Percolatorによる分散トランザクション

分散データベースであるBigtableの上にトランザクションAPIを実装するライブラリ。

### スナップショット分離

Percolatorは、**スナップショット分離**（SI）レベルのトランザクションモデルを使用：

- トランザクションは読み取り専用のスナップショットとして扱われ、すべての読み取りがデータベースのスナップショットと一貫している
- **書き込みメタデータ**: トランザクションの開始タイムスタンプに前にコミットされたすべての値が含まれます
- **書き込みと書き込みの競合**: トランザクションが同じセルに対して書き込みを行おうとするケースが存在するときには、どちらか1つのみがコミットします（通常最初にコミット）
- **通常レベルにコミット**: スナップショット分離は、読み取り/スキューまたは書き込み/スキューのアノマリー（SI）と呼ばれるトランザクションモデルを使用

### 3ステップの実行フロー

#### a) 初期状態

TS1は、2つの口座の最新のタイムスタンプになっています。ロックはまだ取得されていません。

#### b) prewrite

prewriteと呼ばれる第1フェーズで、トランザクションは、このトランザクション中に書き込まれるすべてのセルのロック取得を試みます：

- ロックの1つはプライマリロックされ、残りがセカンダリロック
- **衝突の可能性**: 競合の可能性があるかどうかを確認し、他のトランザクションがより新しいタイムスタンプを持つデータをすでに書き込んだかどうか、あるいはタイムスタンプにかかわらず、未解放のロックがあるかどうかを確認

書き込みの場合、トランザクションは中断します。

#### c) commit

複数の可能性がなくなしし、競合の可能性がないと判断された場合、トランザクションは処理を続行します。第2フェーズの前に、プライマリロックもものみから始めて、クライアントはそのロックを解放しレコードに置き換えて書き込みメタデータを、最新のデータポイントのタイムスタンプで更新します。

### 特徴

| 項目 | 説明 |
|------|------|
| **並行制御** | スナップショット分離、楽観的並行制御 |
| **基盤** | Bigtableの上に構築されたライブラリ |
| **コミット済みメタデータ** | コミットされたデータポイントの規模（書き込みメタデータ）、異なる列のロックを格納します |
| **アノマリー** | 書き込みスキューは防げないため、ロックを獲得 |

---

## 調整の回避

分散トランザクションのパフォーマンスとスケーラビリティを向上させるために、調整（coordination avoidance）を試みる試みがあります：

### I-Confluence（不変合流性）

不変条件があるが、分散したつのデータベース状態にマージすることを保証する特性として、定義されています。この場合に不変値（Invariants）は、ACIDにおける一貫性（C）を伴います：

- **圧意の2つの有効な状態はマージして1つの有効な状態に変えられる**のでI-Confluentの操作は、逐次の調整処理なしで実行できます
- その結果、パフォーマンスの特性とスケーラビリティの向上につながります

### RAMP（Read Atomic Multi-Partition）トランザクション

マルチパーパーティションの同時実行制御と現在実行中の操作のメタデータを使用して、欠落している状態の更新を他のノードから取得し、読み取りと書き込みの操作を並行実行します：

- **Read Atomicの分離レベル**: トランザクションが、実行中未コミット、または中断されたトランザクションからの、処理中の状態変更を見ることができない
- **fractured read**: トランザクションには、他のトランザクションによって実行された書き込みのサブセットのみが見えます
- **分離レベル**: Read Atomicの分離レベルでは、fractured readもできません

---

## 分散トランザクション手法の比較

| 手法 | 一貫性 | 可用性 | ブロッキング | パフォーマンス | 適用シナリオ |
|------|--------|--------|-------------|--------------|-------------|
| **2PC** | 強い | 低い（ブロッキング） | あり | 中程度 | 高い一貫性要件、小規模クラスタ |
| **3PC** | 強い | 中程度（タイムアウト依存） | 理論上なし | 低い（メッセージ増） | ネットワーク分断が少ない環境 |
| **Calvin** | 強い（直列化可能） | 高い | なし | 高い（調整回避） | 決定論的実行が可能なワークロード |
| **Spanner** | 外部一貫性 | 高い | なし | 高い（TrueTime依存） | グローバル分散、強い一貫性要件 |
| **Percolator** | スナップショット分離 | 高い | なし | 中程度 | 大規模増分処理、書き込みスキュー許容 |

---

## 実装時の注意点

### 2PC/3PC実装

- **タイムアウト設定**: ネットワーク遅延とノード処理時間を考慮した適切な値を設定
- **ログの永続化**: コーディネーターとコホートの状態を確実に記録
- **リカバリ手順**: 障害発生時の手動介入手順を明確化
- **監視とアラート**: ブロッキング状態の検出と通知

### Calvin実装

- **シーケンサの冗長化**: Paxos/Raftで合意を取り高可用性を確保
- **バッチサイズの調整**: レイテンシとスループットのバランス
- **依存関係解析**: 正確な読み取り/書き込みセットの事前抽出

### Spanner実装

- **TrueTime代替**: GPS/原子時計がない環境ではNTPベースの実装を検討
- **クロック同期**: ntpdやchronyの設定を最適化
- **不確実性の測定**: 定期的なクロックドリフト監視

### Percolator実装

- **コンフリクト処理**: 楽観的並行制御の再試行ロジック
- **ガベージコレクション**: 古いバージョンのクリーンアップ
- **プライマリロック選択**: 衝突を最小化するヒューリスティック

---

## 代表的な実装例

| システム | 採用手法 | 特徴 |
|---------|---------|------|
| **MySQL（分散トランザクション）** | 2PC | XA準拠、レガシーシステムとの互換性 |
| **PostgreSQL（2PC via XA）** | 2PC | FDW（Foreign Data Wrapper）経由の分散トランザクション |
| **MongoDB** | 2PC（マルチドキュメント） | 4.0以降でACIDトランザクション対応 |
| **FaunaDB** | Calvin風 | 決定論的実行、グローバル分散 |
| **Google Spanner** | Spanner | TrueTime、外部一貫性 |
| **TiDB** | Percolator | Bigtable風のTiKVの上に実装 |
| **CockroachDB** | Hybrid（2PC + クロック同期） | Spanner風、HLCベース |

---

## まとめ

分散トランザクションは、一貫性、可用性、パフォーマンスのトレードオフを伴う複雑な問題である。システム要件に応じて適切な手法を選択することが重要：

- **強い一貫性が最優先**: 2PC/3PC（小規模）、Spanner（大規模グローバル）
- **高可用性とスケーラビリティ**: Calvin、Percolator
- **レガシー統合**: 2PC（XA準拠）
- **調整回避**: I-Confluence、RAMP

最新の分散データベースは、これらの手法を組み合わせて実装し、ワークロードに応じて最適なトレードオフを提供している。
