# Bツリーの実装

ディスク上でのBツリー実装に特有の概念をまとめる。ページヘッダの構成要素、ルートからリーフへの探索手法、ノードの分割・統合の伝播、データ圧縮、およびバキュームとメンテナンスについて扱う。

---

## 1. ページヘッダ

ページヘッダには、ナビゲーション、メンテナンス、最適化に必要なメタ情報が格納される。具体的には、ページの内容とレイアウトを記述したフラグ、ページ内のセル数、セルのオフセット、空き領域の範囲を示す下限/上限オフセットなどが含まれる。

### 1.1 マジックナンバー

ファイルまたはページヘッダに頻繁に保持される値で、複数バイトのブロックである。ブロックがページを表すことを知らせたり、種類の指定やバージョン識別に使用できる定数値。検証と正常性検査に用いられ、ランダムなオフセットにおけるバイトシーケンスがマジックナンバーと一致することはほとんどあり得ない。

書き込み時にマジックナンバー（例: `50 41 47 45` = "PAGE" の十六進表記）をヘッダに記入し、読み取り時にヘッダの先頭4バイトと比較することで、ページが正しく配置されたことを検証できる。

### 1.2 兄弟（Sibling）リンク

左右の兄弟ページ（同じレベルで隣り合うページ）へのポインタを格納する。親ノードをたどらなくても隣接ノードを探し出せるため、スプリットとマージの操作が複雑さを増す代わりに柔軟性が向上する。

兄弟ノードへのリンクを格納する短所の1つは、スプリット時とマージ時に兄弟ノードの更新が必要になる点で、追加でロックが必要になる可能性がある。Blinkツリーにおける並行性への応用については後述する。

### 1.3 右端のポインタ

Bツリーのセパレータキーは、ツリーをサブツリーに分割し、それらをたどるために使用される。子ページへのポインタ数はキーの数よりも常に1多くなる。各セパレータキーは1つの子ポインタを持つが、最後のポインタはいずれのキーともペアになっていないので、別に格納される。

右端の子ノードがスプリットされ、新しいセルが親に追加される場合には、右端の子ポインタを割り当て直す必要がある。スプリット後に親に追加されたセルには昇格されたキーが格納され、そのセルはスプリットされたノードをポイントし、新しいノードへのポインタは以前の右端のポインタの代わりに割り当てられる。

### 1.4 ノードハイキー（Node High Key）

右端のポインタをノードハイキーとともにセルに格納するアプローチ。ハイキーは現在のノードの下のサブツリー内で指定できる範囲内で、もっとも高いキーを表す。PostgreSQLで使用されるB^linkツリーと呼ばれるアプローチの基盤となる。

- ハイキーを持たないBツリー: N個のキー（K_i）とN+1個のポインタ（P_i）。K_0 = -無限大は暗黙的で、ノードには存在しない
- ハイキーを持つBツリー: K_{N+1}のキーを各ノードに追加。ポインタP_Nがポイントするサブツリーに格納できるキーの上限を指定

### 1.5 オーバーフローページ

ノードサイズとツリーのファンアウトの値は固定されており、動的に変化しない。可変長の値がツリー内に存在し、そのサイズが十分に大きい場合には、いくつかの値しかページに収まらない。

データを新しく連続した領域にコピーすることなく可変長のノードを実装するには、複数のリンクされたページからノードを構築する方法をとる。デフォルトのページサイズ（例: 4KB）を超えたデータは、4KBの拡張ページを割り当て、リンクされた拡張ページとして管理する。これを**オーバーフローページ**と呼ぶ。

- ペイロードの一定サイズ（`max_payload_size`）まではプライマリページに格納
- それを超えた残りはオーバーフローページに格納
- 最初のオーバーフローページのページIDがプライマリページのヘッダに格納される
- 複数のオーバーフローページは相互にリンクされる

キーは通常カーディナリティが高いので、キーの一部を格納することは理にかなっている。大半の比較はプライマリページ内の切り詰められたキーの部分で行える。すべてのデータレコードがサイズ超過を起こすような場合には、大きなデータの扱いに特化したBLOBストレージの導入を検討すべきである。

---

## 2. 二分探索

Bツリーのノード内で検索対象のキーを探索するには**二分探索**を使用する。ソートされたデータに対してのみ正常に機能するため、キーの順序を保ち、ソート済みであるという特徴を維持することが必要不可欠である。

二分探索アルゴリズムでは、ソートされた項目の配列と検索対象のキーを受け取る。

- 返された数値が正の場合: 検索対象のキーが検出されたことを示し、入力配列内での位置がその数値で指定される
- 返り値が負の場合: 入力配列内に存在しないことを示し、**挿入位置**がその数値で指定される

挿入位置は、指定されたキーよりも大きな要素のうち、最初（最小）の要素のインデックスとなる。

### 2.1 間接ポインタによる二分探索

Bツリーのページ内のセルは、挿入された順序で格納されており、セルのオフセットのみが論理的な順序を保持する。ページのセルを介して二分探索を実行するには、中央のセルのオフセットを選択し、そのポインタに従ってセルを検索する。このセルのキーを検索対象と比較して、左または右のどちらの検索を続行すべきかを決定する。

---

## 3. スプリットとマージの伝播

Bツリーのスプリットとマージは、さらに上位レベルに伝播する可能性がある。スプリットされたリーフ、またはマージされたリーフのペアからルートノードまでたどれるようにする必要がある。

- 下位レベルのページは上位レベルから参照されたときに常にページインされる（メモリに読み込まれる）ので、親ノードへのポインタ情報をディスク上に永続化する必要はない
- 親が変更されるたびに兄弟ノードへのポインタも更新が必要になる場合がある

### 3.1 パンくずリスト

親ノードのポインタを格納して管理する代わりに、ターゲットのリーフノードへの経路を追跡する方法。挿入時のスプリットまたは削除時のマージの際には、親ノードへのチェーンを逆順でたどることも可能。

**パンくずリスト**（ノードを通過した痕跡）はルートからたどったノードへの参照が含まれるスタック構造であり、スプリットまたはマージを伝播する際にこれを使用して逆向きにたどり直す。PostgreSQLではパンくずリストがスタックに格納され、BTStackとして内部的に参照される。

動作の流れ:
1. ルートからリーフまでツリーをたどり、パンくずリストを構築
2. リーフノードがスプリットされた場合、スタックの先頭にある項目がポップされ、直接の親ノードが突き止められる
3. 親ノードに十分な領域がある場合、新しいセルが親ノードに追加される
4. 親ノードにも領域がない場合、親ノードもスプリットされる
5. スタックが空になりルートに到達するか、そのレベルでスプリットが行われなくなるまで再帰的に継続

### 3.2 リバランシング

一部のBツリーの実装では、スプリットとマージの操作の延期が試みられ、その間にそのレベルの中で要素の**リバランシング**を行う。利用率の高いノードから空きの多いノードにできる限り要素を移動したりすることで、コストを償却しようとする。

- 利用率の向上により、ノードの占有率が改善され、ツリー内のレベル数を減らすことができる
- ただし、リバランシングのメンテナンスコストが高くなる可能性がある
- Bツリーは両側の兄弟ノードが一杯になるまで、隣接するノードの間でデータを分散し続ける。両側が一杯になると、1つのノードを2つではなく3つのノードにスプリットし、それぞれが3分の2ずつ満たされる

---

## 4. 右側限定の追加

多くのデータベースシステムでは、プライマリインデックスキーとしてオートインクリメントで単調増加する値を使用する。この場合、すべての挿入がインデックスの末尾に向かって右端のリーフで行われるため、最適化が可能。

- キーは単調に増加するので、更新および削除に対する追加の比率が低い
- リーフ以外のページが断片化されることも、ランダムに並べられたキーの場合より頻度が低くなる

PostgreSQLではこのケースを**ファストパス**と呼ぶ。挿入されるキーが右端のページ内の最初のキーより確実に大きく、新しく挿入されるエントリを保持できる十分な領域があるときには、キャッシュされた右端のリーフの適切な場所に挿入され、読み取りパス全体をスキップできる。

SQLiteでは同様の概念を**クイックバランス**と呼ぶ。

### 4.1 バルクロード

ソート済みのデータをバルクロードする場合には、右側限定の追加の考え方をさらに活用できる。ツリーの作成に必要なデータはすでにソートしてあるので、バルクロード中に行う必要があるのは、ツリーの右端の位置にアイテムを追加することだけ。

- スプリットとマージを完全に避けて、ツリーをボトムアップ方式で構築できる
- リーフレベルごとに書き込み、すでに書き込み済みの下位レベルのノードへのポインタを十分に確保できたら、すぐに上位レベルのノードを書き出すことができる
- ディスク上でスプリットもマージも実行する必要がない
- 同時に、ツリーの最小部分のみを扱い、現在書き込まれているリーフノードのすべての親を構築時に備えてメモリに保管しておく必要がある

イミュータブルなBツリーも同じ方法で作成できる。ミュータブルなBツリーとは違って、その後の変更のために領域のオーバーヘッドを確保しておく必要はない。すべてのページは完全に埋められるので利用率が向上し、より良いパフォーマンスにつながる。

---

## 5. 圧縮

データを圧縮せずにそのままの状態で格納することは、かなりのオーバーヘッドが発生する可能性がある。多くのデータベースではデータを圧縮して領域を節約する方法が提供されている。

### トレードオフ

- アクセス速度と圧縮率の間に明らかなトレードオフが発生する
- 圧縮率を大きくするとデータサイズが改善され、1回のアクセスで多くのデータを取り出せるようになるが、それだけ多くのRAMとCPUサイクルが圧縮と展開に必要になる

### 圧縮の粒度

- **ファイル全体の圧縮**: 圧縮率は向上するが、更新時にファイル全体を再度圧縮する必要があるので用途は限られる
- **ページごとの圧縮**: ページは相互に独立して圧縮および展開することができ、フラッシュと関連付けることも可能。固定サイズのページを使用するアルゴリズムに適合する

圧縮されたページはディスクブロックの一部しか占めていない場合がある。データのやり取りは通常ディスクブロック単位で行われるので、余分なバイトをページングする必要がある。

### 行指向と列指向

データレコード全体を圧縮する行指向と、列ごとに分けて圧縮する列指向がある。列指向の場合、ページ管理と圧縮は分離される。

### 圧縮ライブラリ

多くのオープンソースデータベースでは、プラグイン可能な圧縮手段が含まれている。Snappy、zLib、lz4やその他多くの利用可能なライブラリを使用する。圧縮アルゴリズムの評価指標としては、メモリオーバーヘッド、圧縮の性能、展開の性能、および圧縮率の4つが重要。

---

## 6. バキュームとメンテナンス

ストレージの整合性を維持し、領域を確保し、オーバーヘッドを削減し、ページの順序の維持を行うために、クエリと並行してバックグラウンドで実行する処理が必要。

### 6.1 更新と削除による断片化

スロット化ページの設計では、内部ノードの後続のスプリットおよびマージ、またはリーフレベルでの挿入、更新、および削除によって、ページに**論理的には**領域が十分にあるが**連続する領域**が十分にない断片化状態が発生する可能性がある。

- **有効なデータレコード**: ルートノードからポインタを下方にたどって到達できるもの（アドレス可能）
- **ガベージ**: アドレス不可能なデータレコード。いずれにおいても参照されず、読み取ることも解釈することもできない

**リーフレベルでの削除**: ヘッダからセルのオフセットを消去するだけで、セル自体は破損することなく残す。この処理の後はセルはアドレス可能ではなくなり、クエリ結果にその内容が表示されなくなる。セルの無効化や隣接するセルの移動は不要。

ページがスプリットされると、オフセットのみが切り詰められ、ページの残りの部分はアドレス可能でなくなるので、新しいデータが来るまで上書きされるか、バキュームプロセスが開始されるとガベージコレクションの対象になる。

一部のデータベースはガベージコレクションに依存し、削除および更新されたセルをマルチバージョン同時実行制御のためにそのまま残す。セルは更新が完了するまで並行して実行されるトランザクションからアクセス可能な状態のまま残され、他のスレッドがアクセスしなくなるとすぐに回収できる。

### 6.2 ページのデフラグ

未使用の領域の回収要求およびページの再書き込みに応じるプロセスは、**コンパクション**、**バキューム**、あるいは単に**メンテナンス**と呼ばれる。

- コンパクションはページをスキャンし、ガベージコレクションを実行し、内容を書き換えるという、明確に区別された非同期プロセス
- 無効なセルに占められた領域を回収し、セルを論理的な順序に従って再書き込みする
- ページが再書き込みされるときには、ファイル内の新しい位置に再配置されることもある
- 未使用のメモリ内ページが使用可能になり、ページキャッシュに返される
- 新しく使用可能になったディスク上のページのIDが**フリーページリスト**（フリーリスト）に追加される
- この情報は、ノードのクラッシュや再起動の後にも耐えられるように、また空き領域が失われたり抜けたりすることのないように、保持される必要がある

---

## まとめ

| 概念 | 要点 |
|------|------|
| ページヘッダ | マジックナンバー、兄弟リンク、右端ポインタ、ハイキー、オーバーフローページ |
| 二分探索 | 間接ポインタ経由でセルオフセットの論理的順序を利用 |
| スプリット/マージ | パンくずリストで経路を追跡し、上位レベルへ伝播 |
| リバランシング | 隣接ノード間で要素を再分配し、スプリットを延期 |
| 右側限定追加 | 単調増加キーの最適化（ファストパス/クイックバランス） |
| バルクロード | ボトムアップ構築でスプリット/マージを回避 |
| 圧縮 | ページ単位の圧縮が実用的。速度と圧縮率のトレードオフ |
| バキューム | ガベージコレクション + デフラグ + フリーページリスト管理 |
