# ログ構造化ストレージ

イミュータブルなストレージ構造では、既存のファイルに変更を加えることはできない。一度書き込まれたら、二度と書き換えられない。新しいレコードが新しいファイルに追加される。最終的な値を見つけ出すには、複数のファイルからレコードを再構築する必要がある。

ミュータブルな構造（Bツリー）ではディスク上のレコードをその場で上書きするのに対し、イミュータブルなLSMツリーでは追記型のストレージとマージによる調停を使用する。

---

## LSMツリー

### 基本原理

**上書き型と追記型の比較:**

| 特性 | 上書き型（Bツリー） | 追記型（LSMツリー） |
|------|---------------|---------------|
| 読み取り性能 | 最適化 | 読み取りの増幅あり |
| 書き込み性能 | ランダムI/O | シーケンシャルI/O |
| 領域効率 | 予備領域が必要 | イミュータブルで密度が高い |
| 並行アクセス | ロックとラッチ | セグメント単位で単純化 |

LSMツリーはバッファリングと追記型のストレージを使用してシーケンシャルな書き込みを実現する。ノードは完全に一杯になっており、シーケンシャルなディスクアクセスに最適化されている。

### LSMツリー構造

LSMツリーは小さなメモリ上のコンポーネントと大きなディスク上のコンポーネントで構成される。

#### 2コンポーネントLSMツリー

- ディスクコンポーネントが1つしかなく、イミュータブルなセグメントで構成される
- ディスクコンポーネントはBツリーとして構成され、ノードの使用率が100%で読み取り専用のページを持つ
- メモリ上のツリーの内容は部分的にディスクにフラッシュされる
- フラッシュ時にはメモリ上のセグメントとディスク上のセグメントがマージされた内容が新しいセグメントとして書き出される

**フラッシュの3つの要件:**

1. フラッシュプロセスが開始されたら即座に、すべての新規書き込みが新規のmemtableに向かうようにしなければならない
2. サブツリーのフラッシュ中は、ディスク上のサブツリーとフラッシュ中のメモリ上のサブツリーの両方の読み取りアクセスが可能になっていなければならない
3. フラッシュの後は、マージされた内容の公開とマージされなかったディスク上とメモリ上の内容の破棄がアトミックに実行されなければならない

#### マルチコンポーネントLSMツリー

- ディスク上のテーブルを1つだけではなく複数使用する
- memtable全体の内容が1度にフラッシュされる
- **コンパクション**と呼ばれる定期的なマージプロセスが起動される

**データのライフサイクル:**

1. データは最初、メモリ上のコンポーネントにバッファリングされる
2. それが大きくなりすぎると、内容はフラッシュされてディスク上にテーブルが作成される
3. その後、複数のテーブルがマージされて、より大きなテーブルが作成される

### memtableとインメモリテーブル

**memtable:**

- ミュータブルなテーブルで、データレコードをバッファリングし、読み取りと書き込みの操作対象となる
- 内容が設定可能な閾値まで増大したときにディスクに永続化される
- memtableを更新してもディスクアクセスは発生しない

**フラッシュの仕組み:**

- 定期的に起動するか、サイズの閾値をもとに起動する
- 事前にmemtableの**切り替え**が必要（新しいmemtableが割り当てられ、それがすべての新規書き込み先となる）
- 古いmemtableはフラッシュ中の状態に変わる
- フラッシュ中のmemtableは完全にフラッシュされるまで引き続き読み取り可能
- フラッシュの後、古いmemtableは破棄され、新しく書き込まれたディスク上のテーブルが読み取り可能となる

**永続性の保証:**

- memtableが完全にフラッシュされるまで、その内容の唯一のディスク上のバージョンは先行書き込みログに格納される
- memtableの内容がディスクに完全にフラッシュされると、ログは削除可能となる

### 更新と削除

LSMツリーでは挿入、更新、削除の操作の際にディスク上のデータレコードの検索は不要。代わりに読み取り時に冗長なレコードが調停される。

**削除の仕組み:**

- データレコードをmemtableから取り除くだけでは不十分（同じキーのデータレコードがディスク上の他のテーブルに保持されている可能性がある）
- 削除は明示的に記録する必要があり、特別な削除エントリ（**墓石**, tombstone）を挿入する
- 調停プロセスで墓石が選択され、無効化された値がフィルタ処理によって除外される

**範囲削除:**

- 述語削除（predicate deletes）を使用する
- 標準的なレコード並べ替えルールに従って、ソートする述語を持つ削除エントリを追加する
- 調停時に述語と一致するデータレコードがスキップされる
- Apache Cassandraでは**範囲墓石**と呼んでいる

### LSMツリーの検索

LSMツリーは複数のコンポーネントで構成されるため、検索時には通常2つ以上のコンポーネントがアクセスされる。それらの内容をクライアントに返す前にマージして調停する必要がある。

### マージイテレーション

ディスク上のテーブルの内容はソートされているので、多次元のマージソートアルゴリズムを使用できる。

**アルゴリズム:**

1. 各イテレータからの最初のアイテムをキューに入力する
2. キューからもっとも小さい要素（先頭）を取り出す
3. 対応するイテレータが枯渇していない場合には、そのイテレータからの要素をキューに再度入力する
4. 問い合わせの条件が満たされるか、またはすべてのイテレータが枯渇するまで処理を続行する

- **優先度付きキュー**（最小ヒープなど）を使用し、N個までの要素（Nはイテレータの数）を保持する
- 複雑さの観点からは、イテレータのマージはソート済みコレクションのマージと同じで O(N) のメモリオーバーヘッド
- イテレータの先頭のソート済みコレクションは O(log N)（平均的な場合）で維持される

### 調停

マージイテレーションは複数のソースからのデータをマージする際に必要な操作の1つの側面にすぎない。もう1つの重要な側面は、同じキーと関連付けられたデータレコードの**調停**および競合の解決。

**タイムスタンプによる優先順位:**

- データレコードを調停する場合にはどちらが優先されるかを理解する必要がある
- データレコードにはタイムスタンプなどのメタデータが保持されている
- 最新のタイムスタンプを持つレコードが優先される
- 最新のタイムスタンプを持つことによって無効化されたレコードはクライアントに返されず、コンパクションの際に書き込まれることもない

---

## LSMツリーにおけるメンテナンス

### コンパクション

ディスク上のテーブルの数が絶えず増加し続けるのを、定期的に行われるコンパクションによって削減する。

**コンパクションの処理:**

- 複数のディスク上のテーブルを選択し、前述のマージおよび調停のアルゴリズムを使用してそれらの内容を反復処理する
- その結果を新しく作成したテーブルに書き出す
- 対象テーブルはコンパクションが終了するまで読み取り可能のままとする
- コンパクション後のテーブルを書き込めるだけの十分な空き領域がディスク上で必要とされる

**墓石とコンパクション:**

- 墓石は調停を正しく行うために必要な重要情報
- 墓石は即座に排除されるわけではない。古いタイムスタンプを持つ同じキーのデータレコードがいずれのテーブルにも存在しないという確証がストレージエンジンで得られるまで墓石は保持される
- コンパクション時に墓石を保持することはデータの復活を避けるために重要

### 平準化コンパクション（Leveled Compaction）

ディスク上のテーブルをいくつかの**レベル**に区分する方式。RocksDBなどで使用されている。

**仕組み:**

- 各レベルのテーブルには目標サイズがあり、各レベルにはインデックス番号（ID）がある
- レベル0のテーブルはmemtableの内容をフラッシュすることで作成される（レベル0には重複するキー範囲が含まれることがある）
- レベル1とそれより大きいインデックスを持つすべてのレベルでは、テーブルのキー範囲は重複しない
- レベル0のテーブルの数が閾値に達すると、レベル1の新しいテーブルにマージされる

**レベル間の関係:**

- レベル間でサイズは指数関数的に増大する
- 最新のデータはもっとも小さいインデックスを持つレベルに常に含まれる
- 古いデータはより大きいレベルに徐々に移動させられる
- 各レベルのテーブルが個々で異なるキー範囲を維持するので、読み取り時にアクセスされるテーブルの数が削減される

### サイズ階層化コンパクション（Size-Tiered Compaction）

テーブルをレベルに基づいてグループ化するのではなく、**サイズに従ってグループ化**する方式。

**仕組み:**

- 小さなテーブルを同様に小さなテーブルとグループ化し、大きなテーブルは大きなテーブルとグループ化する
- レベル0にはmemtableからフラッシュされたか、コンパクションで作成された最小のテーブルが保持される
- テーブルがコンパクションされる際に、その結果としてマージされたテーブルは対応するサイズのテーブルを保持しているレベルに書き込まれる
- 大きいほうのテーブルをコンパクションして上位レベルに昇格し、小さいほうのテーブルを下位レベルに降格する

**テーブル枯渇の問題:**

- コンパクションされたテーブルが処理後も十分に小さいままである場合がある（例: レコードが墓石によって無効化されていて、マージ済みのテーブルに追加されない場合）
- 上位レベルではコンパクションが行われなくなって読み取りのコストが上がることがある

### 時間枠コンパクション（Time Window Compaction）

- 書き込みのタイムスタンプを考慮して、すでに有効期限が過ぎている範囲のデータを保持しているファイル全体を破棄することを可能にする
- 有効期限が設定される、つまり一定の期間が経過すると無効になるレコードを持つ時系列のワークロードに対して特に有用
- Apache Cassandraで実装されている

---

## 読み取りと書き込みおよび領域の増幅

イミュータブルな方法でデータをディスクに格納するときには以下3つの問題が発生する。

### RUM予想

ストレージ構造でよく使用されているコストモデルとして、読み取り（Read）、更新（Update）、メモリ（Memory）の各オーバーヘッドを考慮するRUM予想がある。

**基本法則:**

- これらのオーバーヘッドのうち2つを削減すると、必然的に3つ目のオーバーヘッドが悪化する
- 最適化は3つのパラメータのうち1つを犠牲にした場合にのみ可能

**各ストレージエンジンの最適化:**

| ストレージ | 最適化対象 | 犠牲 |
|----------|----------|------|
| Bツリー | 読み取り | 書き込みの増幅、利用領域の増幅 |
| LSMツリー | 書き込み | 読み取りの増幅 |

**3種類の増幅:**

- **読み取りの増幅**（read amplification）: データを取り出すために複数のテーブルを調べる必要性に起因する
- **書き込みの増幅**（write amplification）: コンパクションによる絶え間ない書き直しによって引き起こされる
- **利用領域の増幅**（space amplification）: 同じキーに関連付けられた複数のレコードを格納することから発生する

---

## 実装の詳細

### SSTable（Sorted String Table）

ディスク上のテーブルはSSTable（Sorted String Table）を使用して実装される。

**構造:**

- SSTable内のデータレコードはソートされており、キー順にレイアウトされている
- **インデックスファイル**と**データファイル**という2つのコンポーネントで構成される
- インデックスファイルにはBツリーのような対数オーダーの検索、またはハッシュテーブルのような一定時間での検索を可能にする構造が使用される

**インデックスコンポーネント:**

- キーとデータのエントリ（実際のデータレコードが格納されているデータファイルのオフセット）が保持される
- 連結されたキーと値のペアで構成される

**データコンポーネント:**

- セルがシーケンシャルに書き込まれており、SSTableのライフサイクルの間は変更されない
- インデックスファイルにはデータファイルに格納されているデータレコードへのポインタが保持される

**コンパクション時の特性:**

- データファイルをシーケンシャルに読み取ることができる
- データファイルに含まれるデータレコードはすでに順序付けされているので、インデックスコンポーネントを扱う必要がない
- 1回の実行で、データレコードをシーケンシャルに書き込むことによって作成される
- ファイルが完全に書き込まれると、すぐにそのファイルはイミュータブルであるとみなされるので、ディスク上の内容は変更されない

### SSTable-Attached Secondary Indexes（SASI）

- Apache Cassandraに実装されたSASI
- テーブルに対するインデックス作成をプライマリキーだけでなく他のフィールドを使用してもできるようにする
- インデックス構造とそれらのライフサイクルがSSTableのライフサイクルと結び付けられ、インデックスがSSTableごとに作成される
- memtableの内容にもインデックスを作成する

### ブルームフィルタ

LSMツリーにおいて読み取りの増幅が発生するのは、読み取り操作を実行する過程で複数のディスク上のテーブルを調べる必要があるから。

**基本概念:**

- 確率論的なデータ構造であり、要素が集合のメンバーであるかどうかを調べるために使用できる
- **偽陽性の一致**を返す可能性があるが、**偽陰性の一致**を返す可能性はない
- 否定的一致を返した場合には、要素が集合のメンバーではないことが保証される

**LSMツリーでの活用:**

- キーがテーブルに含まれている**可能性がある**か、あるいはテーブルに含まれていないことが**確実**であるかを判断できる
- 否定的一致を返したファイルはクエリの実行時にスキップされる
- 読み取り時にアクセスされるテーブルの数を大幅に削減する

**仕組み:**

- 大きなビット配列と複数のハッシュ関数が使用される
- ハッシュ関数はテーブル内のレコードのキーに適用され、ビットが1に設定されているビット配列内のインデックスを検索する
- 検索時にすべてのハッシュ関数で決定されたビットが1である場合にはメンバーである確率が返される
- ビットのうちの少なくとも1つが0であれば、要素がその集合内に存在しないということ

**トレードオフ:**

- ビット集合のサイズとハッシュ関数の数を設定することで誤検出の確率をコントロールする
- ビット集合が大きければ衝突の可能性はそれだけ小さくなる
- ハッシュ関数の数が増えれば確認できるビットが増え、結果はそれだけ正確になる
- ビット集合が大きくなれば使用されるメモリが増え、多くのハッシュ関数の計算処理パフォーマンスに悪影響を与えかねない

### スキップリスト

ソート済みのデータをメモリ内に保持する手段として人気のあるデータ構造。

**特徴:**

- 片方向リストよりはるかに単純であり、確率論的な複雑性の保証は検索ツリーに近い
- 挿入および更新のためのローテーションや再配置を必要としない
- 確率論的なバランシングを使用する
- 一般的にイミュータブルなBツリーほどキャッシュとの親和性が高くない（ノードが小さく、メモリ内にランダムに割り当てられる）

**構造:**

- 高さの異なる一連のノードで構成され、項目の範囲をスキップすることが可能な連結された階層を構築する
- 各ノードにはキーが保持され、いくつかのノードは複数の後続ノードを持つことがある
- ノードの高さはランダム関数によって決定され、挿入時に計算される
- 高さが同じノードは**レベル**を形成する

**検索アルゴリズム:**

1. 最上位レベルのノードポインタをたどる
2. 検索対象のキーより大きなキーを保持するノードに行き当たると、その前のノードが次のレベルのノードへのリンクをたどる
3. 検索対象のキーか、または検索対象のキーより小さいキーを持つ前ノードが見つかるまで再帰的に繰り返される

**並行性:**

- `fully_linked`という追加フラグを使用する線形化可能性を持つスキームを実装することで作成できる
- コンペアアンドスワップを使用して設定できる
- Apache CassandraやWiredTigerで使用されている

### ディスクアクセス

- テーブルの内容の大半はディスク上に存在しており、ストレージデバイスは一般的にデータブロック単位でアクセスされる
- LSMツリーの実装の多くはページキャッシュに依存してディスクアクセスと中間キャッシングを行う
- メモリ内の内容がイミュータブルであり、並行アクセスのための追加ロックも追加ラッチも必要がない
- LSMツリーにおけるデータレコードは必ずしもページに合わせて配置されていない（ポインタはアドレス指定のためにページIDではなく絶対的なオフセットを使用して実装される）

### 圧縮

- LSMツリーにも適用できるが、LSMツリーのテーブルはイミュータブルであり一般的に一度のパスで書き込まれることが主要な違い
- データをページ単位で圧縮すると、圧縮後のページのサイズは未圧縮ページのサイズより小さくなるので、ページに合わせた配置がされない
- 圧縮後のページをアドレス可能にするには、圧縮後のページのオフセットとサイズを格納する間接的なレイヤが必要

---

## 順序付けされないLSMストレージ

### Bitcask

Bitcaskは順序付けされていないログ構造化ストレージエンジンの1つ。バッファリングにmemtableを使用せず、データレコードを直接ログファイルに格納する。

**keydir:**

- 対応するキーの最新のデータレコードへの参照を保持するデータ構造
- 古いデータレコードがディスク上に残っている場合があるが、それらはkeydirから参照されない
- コンパクション時にガベージコレクションによって処理される
- インメモリのHashMapとして実装され、起動時にログファイルから再構築する必要がある

**書き込み:**

- キーとデータレコードがシーケンシャルにログファイルに追加される
- 新しく書き込まれたデータレコードの場所へのポインタがkeydirに配置される

**読み取り:**

- keydirが調べられて検索対象のキーの場所が特定される
- ログファイルへの関連付けられたポインタをたどることでデータレコードを探す
- keydir内のキーと関連付けられる値は常に1つしか存在できないので、ポイントクエリは複数のソースからデータをマージする必要がない

**コンパクション:**

- すべてのログファイルの内容がシーケンシャルに読み取られ、マージされてから新しい場所に書き込まれる
- 有効なデータレコードのみを保持し、無効化されたものは破棄される
- keydirは再配置されたデータレコードへの新しいポインタで更新される

**制約:**

- データレコードは直接ログファイルに格納されるので、別の先行書き込みログを管理する必要がなく、利用領域のオーバーヘッドと書き込みの増幅を削減する
- ポイントクエリのみがサポートされ、**範囲スキャンができない**（keydirとデータファイルのどちらにおいても項目が順序付けされていない）
- すべてのキーをメモリ内に保持しなければならず、起動時にkeydirを再構築することはユースケースによっては使用に耐えないほどの制約になる

### WiscKey

LSMツリーによってキーがソートされた状態に保つことで、ガベージコレクションからソート処理を切り離す方式。

**vLog（値ログ）:**

- 順序付けされていない追記型のファイルでデータレコードを保持する
- キーはソートされたLSMツリーに格納され、ログファイル内の最新のデータレコードをポイントする
- キーはそれらに関連付けられたデータレコードと比べて一般的にはるかに小さいので、圧縮するほうが効率的

**Bitcaskとの違い:**

- Bitcaskの2つの問題（すべてのキーをメモリ内に保持しなければならないこと、起動時にハッシュテーブルを再構築しなければならないこと）を解決
- キーをソートされたLSMツリーで管理するため、範囲スキャンも可能

**範囲スキャンの課題:**

- vLogのデータがソートされていないので、範囲スキャンにおいてランダムなI/Oが必要になる
- WiscKeyでは範囲スキャン時にブロックをパラレルにプリフェッチし、ランダムなI/Oのコストを削減するために内部的なSSDのパラレル処理が使用される
- それでもブロック転送の観点からコストは高いまま

**ガベージコレクション:**

- コンパクション時にvLogファイルの内容はシーケンシャルに読み取られ、マージされ、新しい場所に書き込まれる
- ポインタ（キーLSMツリー内の値）はこれらの新しい場所をポイントするように更新される
- vLogの内容全体をスキャンしなくても済むように、headポインタとtailポインタが使用される（有効なキーを保持しているvLogセグメントに関する情報が含まれている）

---

## LSMツリーにおける並行性

### テーブルビュー

主要な並行性の課題は**テーブルビュー**（フラッシュ時とコンパクション時に変更されるメモリ上とディスク上のテーブルのコレクション）の切り替えとログの同期に関連している。

**フラッシュ時のルール:**

- 新規のmemtableに、読み取りおよび書き込みが可能にならなければならない
- 古い、フラッシュ中のmemtableは読み取りから見える状態のままでなければならない
- フラッシュ中のmemtableはディスクに書き込まれなければならない
- フラッシュ済みのmemtableの破棄とフラッシュ済みのディスク上テーブルの作成はアトミックとして実行されなければならない
- フラッシュ済みのmemtableに適用された操作のログエントリを保持している先行書き込みログのセグメントは破棄されなければならない

**同期ポイント:**

| 同期ポイント | 説明 |
|------------|------|
| memtableの切り替え | すべての書き込みが新しいmemtableにのみ送られるようにする |
| フラッシュの確定 | テーブルビューにおいて古いmemtableをフラッシュされたディスク上のテーブルに置き換える |
| 先行書き込みログの切り捨て | フラッシュされたmemtableと関連付けられているレコードを保持するログセグメントを破棄する |

---

## ログスタック

### ログ構造化ストレージ（LSS）

SSDでもログ構造化ストレージを使用して、ランダムな小さい書き込みを処理し、書き込みのオーバーヘッドを最小化し、ウェアレベリングを改善し、デバイスの寿命を延ばす。

LSMツリーとSSDは相性のよい組み合わせ。シーケンシャルなワークロードと追記型の書き込みが、同じ場所を上書きすることで発生する書き込み増幅を削減するのに有効だからである。

### フラッシュトランスレーションレイヤ（FTL）

**SSDの特性:**

- ランダムな小さい書き込みを物理的な1ページにまとめて一括処理する必要がある
- SSDがプログラム/消去（P/E）サイクルを使用して動作するという事実（書き込みは前もってデータが消去されているページに対してのみ行える）
- ページを単独で消去することはできない。**ブロック**（通常は64個から512個のページが保持される）内のページをまとめて消去する

**FTLの役割:**

- 論理ページアドレスを物理的な位置に変換する
- ページの状態（有効、破棄済み、空白）を記録する
- ガベージコレクションを実行し、破棄されたページを消去する
- SSDの**ウェアレベリング**を調整する役割も担う

**ガベージコレクション:**

- データが消去される予定のブロックに含まれるすべてのページが破棄の対象とは限らない
- 有効なページを空白ページが含まれるブロックの1つに再配置する必要がある
- 有効なページをすべて再配置すればブロックのデータを安全に消去でき、空のページを書き込みに使用できる

### ファイルシステムログ

- 多くのファイルシステムでは書き込みバッファリングにログが使われている
- 書き込みの増幅を削減し、背後にあるハードウェアを最適に使用することができる

**ログスタックの問題:**

- 複数のログ構造化システムを積み重ねていくと、書き込みの増幅、断片化、パフォーマンスの劣化などの問題に突き当たる
- 上位レベルのログセグメントの書き込みと廃棄が、下位レベルの異なるログおよび異なるガベージコレクションのパターンの発生につながる
- 隣接するセグメントの一部が断片化したり再配置される可能性がある

### LLAMAと注意深いスタック

Bwツリーのイミュータブルなバージョンについて、ラッチフリーで、ログ構造化されていてアクセスメソッドを意識する（LLAMA）ストレージサブシステムの上のレイヤとして置かれる。

**Bwツリーとの連携:**

- 論理的なBwツリーのノードは物理的なデルタノードの連結リストで構成される
- 論理的なノードはメモリ内のマッピングテーブルを使用してリンクされ、ディスク上の最新の更新の場所をポイントする
- ログ構造化ストレージは4MBのフラッシュバッファでノードの更新（デルタノード）をまとめてバッファリングし、ページが一杯になるとすぐにディスクにフラッシュされる

**LSSのガベージコレクションとの連携:**

- LLAMAにおけるBwツリーへの意識によって、複数のデルタノードを単一の連続した物理的な場所に統合することが可能になる
- LSSのガベージコレクションは論理的なBwツリーのノードの内容の統合にも対応できる
- ガベージコレクションが複数のデルタノードを連結して書き換えることで、Bwツリーのノードに使用される領域の合計が減少し、読み取るために必要なレイテンシが削減される

### Open-Channel SSD

ソフトウェアレイヤのスタックに代わる方法として、すべての間接レイヤをスキップしてハードウェアを直接使用することもできる。

- ファイルシステムとフラッシュトランスレーションレイヤを使用しないようにすることが可能
- 少なくとも2つのレイヤのログを避けられ、ウェアレベリング、ガベージコレクション、データの配置、スケジュール管理に対する制御を強化できる
- FTLは経由されない（開発者の観点からは確かに細部に渡って注意を払う必要がある）

---

## まとめ

ログ構造化ストレージは、フラッシュトランスレーションレイヤからファイルシステムとデータベースシステムまで、あらゆる場所で使用されている。メモリ内でランダムな小さい書き込みをまとめて一括処理することで、書き込みの増幅を削減するために役立つ。削除されたセグメントが使用していた領域を回収するためにLSSは定期的にガベージコレクションを起動する。

LSMツリーはLSSからいくつかのアイデアを取り入れて、ログ構造化の手法で管理されるイミュータブルなインデックス構造を構築するために役立つ。書き込みはメモリ内で一括処理され、ディスクにフラッシュされる。無効化されたデータレコードはコンパクション時にクリーンアップされる。

重要なのは、多くのソフトウェアレイヤでLSSを使用していることを忘れず、レイヤが最適にスタックされるようにすること。あるいはファイルシステムのレベルを完全にスキップしてハードウェアに直接アクセスすることも可能である。
