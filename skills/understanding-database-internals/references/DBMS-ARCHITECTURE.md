# DBMSアーキテクチャ

## 概要

このファイルでは、データベース管理システム（DBMS）の全体的なアーキテクチャと、設計上の主要な選択肢について解説します。DBMSは単なるデータの保管場所ではなく、クエリ処理、最適化、同時実行制御、トランザクション管理など、複雑な機能を提供する統合システムです。

---

## DBMSの主要コンポーネント

データベース管理システムは、以下の3つの主要レイヤーで構成されます：

### 1. トランスポート層

クライアントからのリクエストを受信し、データベースクラスタ内のノードと通信する役割を担います。

- **機能**: 転送サブシステム
- **責務**: クエリの受信、通信プロトコルの処理、ノード間通信

### 2. クエリプロセッサ

受け取ったクエリを解析し、最適化して実行計画を生成します。

#### サブコンポーネント

| コンポーネント | 役割 |
|------------|------|
| **クエリパーサ** | SQL文を解析し、構文木を生成 |
| **クエリオプティマイザ** | 複数の実行プランを評価し、最適なプランを選択 |

**クエリオプティマイザの重要性**: 同じクエリでも実行プランによって性能が桁違いに変わることがあります。オプティマイザは、インデックスの利用、結合順序、アクセスパターンなどを考慮して、コストモデルに基づいた最適化を行います。

### 3. 実行エンジン

クエリプロセッサが生成した実行計画を実際に実行します。

#### 実行方式

- **ローカル実行**: 単一ノードでの実行
- **リモート実行**: 他ノードへのクエリ転送（分散データベース）

### 4. ストレージエンジン

ディスク上のデータへのアクセスと、それらの構造を管理します。以下のように複数のコンポーネントで構成されます：

#### 主要コンポーネント

| コンポーネント | 役割 |
|------------|------|
| **トランザクションマネージャ** | トランザクションのスケジュール管理、論理的一貫性の保証 |
| **ロックマネージャ** | データオブジェクトのロック管理、並行性制御 |
| **アクセスメソッド** | ヒープファイル、Bツリー、LSMツリー等のストレージ構造 |
| **バッファマネージャ** | データページのメモリキャッシュ管理 |
| **リカバリマネージャ** | 操作ログの管理、障害時のシステム状態復旧 |

---

## メモリベースDBMS vs ディスクベースDBMS

DBMSは、データを主にメモリとディスクのどちらに格納するかによって2つのタイプに分けられます。

### 比較表

| 特性 | インメモリDBMS | ディスクベースDBMS |
|------|-------------|----------------|
| **主な格納場所** | RAM | HDD/SSD |
| **アクセス速度** | ✅ 極めて高速（ナノ秒〜マイクロ秒） | ⚠️ 低速（ミリ秒） |
| **データ容量** | 🔴 制限あり（RAMサイズ） | ✅ 大容量（テラバイト〜ペタバイト） |
| **コスト** | 🔴 高い（RAMは高価） | ✅ 低い（ディスクは安価） |
| **永続性** | ⚠️ 別途ディスクバックアップが必要 | ✅ 標準で永続化 |
| **データ構造** | ポインタベース、簡素化された構造 | ページベース、シリアライズが必要 |
| **代表例** | Redis, Memcached, SAP HANA, VoltDB | PostgreSQL, MySQL, Oracle, MongoDB |

### インメモリDBMSの特徴

#### 利点

- **圧倒的な速度**: ディスクI/Oのボトルネックがないため、クエリ応答が桁違いに高速
- **シンプルなデータ構造**: ページ管理やバッファリングが不要
- **低レイテンシ**: リアルタイム処理、ハイフリークエンシートレーディングに最適

#### 制約

- **容量の限界**: RAMのコストと物理的制約により、大規模データには不向き
- **永続性のコスト**: スナップショットやログをディスクに書き込む必要がある
- **障害時のリスク**: 電源断でデータ損失の可能性（UPS、バッテリバックアップRAMで緩和可能）

### ディスクベースDBMSの特徴

#### 利点

- **大容量**: テラバイト〜ペタバイト級のデータを扱える
- **永続性**: ディスクへの書き込みでデータが永続化
- **コスト効率**: GB単位のコストがRAMより大幅に低い

#### 制約

- **I/Oボトルネック**: ディスクアクセスがミリ秒単位で遅延を生む
- **複雑なバッファ管理**: ページキャッシュ、置換アルゴリズム、同期処理が必要
- **ディスクの物理特性**: HDDではシーク時間、SSDでも書き込み増幅の問題

### ディスクベースDBMSのストレージ永続性

ディスクベースDBMSでは、揮発性データの耐久性を保証するために、以下の技術が使われます：

#### Write-Ahead Logging (WAL)

- データ本体の更新前に、変更内容をログファイルに記録
- ログ先行書き込みにより、クラッシュ後もログから状態を復元可能

#### バックアップとコピー

- 特定時点のスナップショットや完全バックアップをディスクに保存
- リカバリ時は、バックアップ + ログの再生で状態復旧

#### ログレコードの処理

- ログレコードは通常、バッチ処理でバックアップコピーに取り込まれる
- スナップショット時は、データベーススナップショット + 後続ログで完全な状態を再構築

---

## 行指向 vs 列指向データベース

データベースは、データレコードをどのように格納するかによって**行指向（Row-Oriented）**と**列指向（Column-Oriented）**の2つに分類されます。

### データレイアウトの違い

#### 行指向（Row Store）

データを**行（レコード）単位**で格納します。

```
| 識別子 | 日付       | 価格 |
|--------|-----------|------|
| John   | 01 Aug 81 | +1 111 222 333 |
| Sam    | 14 Sep 88 | +1 555 888 999 |
| Keith  | 07 Jan 84 | +1 333 444 555 |
```

**ディスク上のレイアウト（行指向）**:
```
[John, 01 Aug 81, +1 111 222 333]
[Sam, 14 Sep 88, +1 555 888 999]
[Keith, 07 Jan 84, +1 333 444 555]
```

#### 列指向（Column Store）

データを**列（フィールド）単位**で格納します。

**ディスク上のレイアウト（列指向）**:
```
識別子: [John, Sam, Keith]
日付: [01 Aug 81, 14 Sep 88, 07 Jan 84]
価格: [+1 111 222 333, +1 555 888 999, +1 333 444 555]
```

### 行指向データベースの特徴

#### 利点

- ✅ **行全体のアクセスが高速**: 1回のディスクシークでレコード全体を取得
- ✅ **OLTP（オンライントランザクション処理）に最適**: ユーザーごとの挿入・更新・削除が効率的
- ✅ **トランザクション処理が容易**: 行ロックが自然に実装できる

#### 制約

- 🔴 **列の一部だけが必要な場合は非効率**: 不要なフィールドも読み込む
- 🔴 **集計クエリが遅い**: 全行をスキャンして特定列を抽出

#### 代表的な実装

- MySQL、PostgreSQL、Oracle、MongoDB、CStore

### 列指向データベースの特徴

#### 利点

- ✅ **OLAP（オンライン分析処理）に最適**: 集計・フィルタリング・分析クエリが高速
- ✅ **圧縮率が高い**: 同じ型のデータが連続するため圧縮効率が良い
- ✅ **列単位のアクセスが高速**: 必要な列だけを読み込む

#### 制約

- 🔴 **行全体の再構築が遅い**: 複数の列ファイルから行を再構成するコストが高い
- 🔴 **個別レコードの更新が非効率**: 複数の列ファイルを更新する必要がある

#### 代表的な実装

- Apache Parquet、Apache ORC、RCFile、Vertica、ClickHouse

### ワークロード別の推奨

| ワークロード | 推奨 | 理由 |
|------------|------|------|
| **OLTP（トランザクション処理）** | 行指向 | 個別レコードの挿入・更新・削除が頻繁 |
| **OLAP（分析処理）** | 列指向 | 集計・グループ化・フィルタリングが主体 |
| **ハイブリッド (HTAP)** | 行指向 + 列指向の併用 | OLTPとOLAPを同時に処理 |

### 相違点と最適化

列指向と行指向の違いは単なるデータレイアウトだけでなく、アクセスパターンを理解することが重要です。

#### 行指向ストアの最適化

- **行格納の効率化**: 行ごとにまとめて格納することで、ユーザーレコード全体を1回のディスクシークで取得可能
- **空間局所性の利用**: OSのページキャッシュ、CPUのベクトル化命令を活用

#### 列指向ストアの最適化

- **圧縮の活用**: 同じ型のデータが連続するため、辞書エンコーディングやRLE（Run-Length Encoding）が効果的
- **ベクトル化処理**: SIMD（Single Instruction Multiple Data）により、列単位で同じ演算を高速処理
- **遅延マテリアライゼーション**: 必要な列だけを読み込み、最後に行を再構築

---

## ワイドカラムストア

ワイドカラムストア（Wide Column Store）は、列指向ストアとは異なる概念であり、**列ファミリー**と呼ばれる単位でデータをグループ化します。

### 特徴

- **列ファミリー単位のグループ化**: 関連する列をまとめて格納
- **スキーマレス**: 各行が異なる列を持つことが可能
- **スパースデータの効率的格納**: NULL値を格納しない

### データモデル例（Webテーブル）

```
行キー: com.cnn.www

列ファミリー: contents
  | タイムスタンプ | 修飾子 | 値 |
  |--------------|-------|-----|
  | t3 | html | "<html>..." |
  | t5 | html | "<html>..." |
  | t6 | html | "<html>..." |

列ファミリー: anchor
  | タイムスタンプ | 修飾子 | 値 |
  |--------------|-------|-----|
  | t8 | cnnsi.com | "CNN" |
  | t5 | my.look.ca | "CNN.com" |
```

### 代表的な実装

- **Bigtable**: Googleの分散ストレージシステム
- **HBase**: Hadoop上のBigtable実装
- **Cassandra**: 高可用性・スケーラビリティを重視した分散DB

### ワイドカラムストアの利点

- ✅ **スパースデータに最適**: 異なるスキーマを持つ行が共存可能
- ✅ **水平スケーラビリティ**: 行キーによるシャーディングが容易
- ✅ **タイムスタンプベースのバージョン管理**: データ履歴の管理が組み込まれている

---

## データファイルとインデックスファイル

データベースシステムの主要な目的の一つは、データを格納し、そのデータへの迅速なアクセスを可能にすることです。

### データファイルの種類

データファイルには、データレコードを格納するさまざまな方法があります：

#### 1. ヒープファイル（Heap File）/ 無秩序ファイル

- **特徴**: レコードを追記順に格納（順序なし）
- **利点**: 挿入が高速
- **欠点**: 検索は線形スキャンが必要（O(N)）
- **用途**: ログ、一時テーブル

#### 2. ソート済みファイル（Hash-Organized File）

- **特徴**: レコードをハッシュ値に基づいて格納
- **利点**: ポイントクエリが高速（O(1)）
- **欠点**: 範囲クエリは非効率
- **用途**: キャッシュ、インメモリインデックス

#### 3. ハッシュ構造ファイル（Sorted File）

- **特徴**: レコードをキー順に格納
- **利点**: 範囲クエリが効率的、二分探索が可能（O(log N)）
- **欠点**: 挿入・削除時の再配置コストが高い
- **用途**: インデックス、主キー順のテーブル

### インデックスファイル

インデックスは、効率的にデータレコードを検索できるようにディスク上のデータレコードをまとめたものです。

#### インデックスの種類

| インデックスタイプ | 説明 | 構造 |
|----------------|------|------|
| **プライマリインデックス** | データレコード自体がインデックスに格納される | クラスタ化インデックス（Clustered Index） |
| **セカンダリインデックス** | インデックスがデータレコードへのポインタを保持 | 非クラスタ化インデックス（Non-Clustered Index） |

#### プライマリインデックス（Clustered Index）

- **定義**: データテーブル自体がインデックスの葉として構成される
- **利点**:
  - インデックス検索後、追加のディスクアクセス不要
  - 範囲クエリが高速（キー順に並んでいる）
- **欠点**:
  - テーブルごとに1つしか存在できない
  - 挿入・削除時にデータ全体を再配置する可能性
- **代表例**: MySQL InnoDBの主キー

#### セカンダリインデックス（Non-Clustered Index）

- **定義**: データエントリがレコードを直接識別し、そのファイル内からそれらのレコードを検索する情報を含む
- **利点**:
  - 複数のセカンダリインデックスを作成可能
  - データ本体とは独立して管理できる
- **欠点**:
  - インデックス検索後、データレコードへのポインタを辿る追加I/Oが必要
  - インデックスサイズがデータ本体より小さいが、別ファイルとして管理
- **代表例**: PostgreSQLの通常のインデックス

### インデックス構造の選択

| インデックス構造 | プライマリインデックス | セカンダリインデックス |
|---------------|------------------|------------------|
| **Bツリー** | ✅ 主流（InnoDBなど） | ✅ 主流（PostgreSQLなど） |
| **ハッシュインデックス** | ⚠️ まれ | ✅ 頻繁に使用 |
| **LSMツリー** | ✅ RocksDB、LevelDB | ✅ 複数レベルのSSTable |
| **フルテキストインデックス** | ❌ 不可 | ✅ 転置インデックス |

---

## バッファリング、イミュータビリティ、オーダリング

ストレージエンジンの設計において、以下の3つの変数が重要な役割を果たします：

### 1. バッファリング（Buffering）

- **定義**: ストレージ構造が、データをディスクに書き込む前にメモリに一定期間保持するかどうか
- **バッファありの利点**: 書き込み回数を削減し、シーケンシャルI/Oを実現
- **バッファなしの利点**: データの永続性が即座に保証される

#### 実装例

| 特性 | Bツリー | LSMツリー |
|------|--------|----------|
| **バッファリング** | ⚠️ 中程度（ページキャッシュ） | ✅ 積極的（Memtable） |
| **書き込み増幅** | 🔴 高 | 🟢 低 |

### 2. イミュータビリティ（Immutability）

- **定義**: ファイルが一度書き込まれた後、更新されず不変であるかどうか
- **イミュータブルの利点**:
  - コピーオンライト（Copy-On-Write）により、バージョン管理が容易
  - 並行読み取りが安全（ロック不要）
- **ミュータブルの利点**:
  - インプレース更新が可能で、古いデータの削除が不要

#### 実装例

| 特性 | Bツリー | LSMツリー |
|------|--------|----------|
| **イミュータビリティ** | ❌ インプレース更新 | ✅ SSTableは不変 |
| **ガベージコレクション** | 🟢 不要 | ⚠️ Compactionが必要 |

### 3. オーダリング（Ordering）

- **定義**: データレコードをディスク上でキーの順序で格納するかどうか
- **順序ありの利点**:
  - 範囲クエリが高速（連続読み取り）
  - 二分探索が可能
- **順序なしの利点**:
  - 挿入が高速（追記のみ）

#### 実装例

| 特性 | Bツリー | LSMツリー |
|------|--------|----------|
| **オーダリング** | ✅ ソート済み | ✅ ソート済み（SSTable） |
| **範囲クエリ** | ✅ 高速 | ⚠️ 中程度（マージスキャン） |

---

## TPC-Cベンチマークとストレステスト

データベースシステムの性能を評価する際、標準化されたベンチマークが広く使用されます。

### TPC-C（Transaction Processing Performance Council）

- **目的**: データベースベンチマークが日社の製品のパフォーマンスを比較して評伝料とするために使用される一連のベンチマークを策定
- **ワークロード**: 一般的なアプリケーションワークロードをシミュレートする混合トランザクション
- **評価指標**:
  - **スループット**: トランザクション数/秒
  - **レイテンシ**: トランザクション応答時間
  - **ACID特性**: トランザクションの正確性

### ストレステスト

- **目的**: 特定のユースケースに特化した負荷テスト
- **方法**:
  - 最大同時接続数の負荷をかける
  - 実世界のワークロードを再現
- **評価ポイント**:
  - システムがどの程度までスケールするか
  - 障害時の挙動
  - リカバリ時間

---

## まとめ

DBMSアーキテクチャの理解は、データベース選定と最適化の基盤です：

### キーポイント

1. **コンポーネント理解**: トランスポート、クエリプロセッサ、実行エンジン、ストレージエンジンの役割
2. **メモリ vs ディスク**: ワークロードに応じた選択（速度 vs 容量 vs コスト）
3. **行指向 vs 列指向**: OLTP vs OLAPの最適化
4. **データファイルとインデックス**: ヒープ、ソート済み、ハッシュ構造の使い分け
5. **設計変数**: バッファリング、イミュータビリティ、オーダリングのトレードオフ

次章以降では、これらのコンポーネントの具体的な実装（特にBツリーとLSMツリー）について深掘りします。
