# 障害検出とリーダー選出

第9章「障害検出」と第10章「リーダー選出」のリファレンス

## 障害検出

システムにおいて障害に適切に対処するには、タイムリーに障害を検出する必要があります。障害が発生したプロセスにアクセスすると、たとえそれが応答できないとしても、レイテンシを増大させ、システム全体の可用性を低下させる可能性があります。

非同期の障害システムで、タイミングの前提がまったくないシステムで障害を検出するのは、極めて困難です。それは、プロセスがクラッシュしたのか、それとも実行速度が遅くで応答に限らないほど良い問題がかかっているのかを区別できないからです。この点に関する問題については、p.195「8.5 FLPの不可能性」で議論しました。

ステップを実行を安全に受けられていないこと応答するからには、通常、「動作停止」「障害が発生した」「クラッシュした」などの用語が使用されます。また、実行状態が疑わしいプロセスの説明には、「応答なし」「故障」、「動作が遅い」などの用語が使用されます。ただし、これらのプロセスは、実際には**動作停止**（dead）になっていることもあります。

障害は、それが**ノードレベル**（プロセスがクラッシュしたり、その配信が落ちたり）、その配信が起こったり）する場合）、または**プロセスレベル**（プロセスがクラッシュしたり、その実行が遅かったりする場合）で発生し、遅れと障害は、いつでも区別できるというわけではありません。このことは、正常に動作しているが応答が遅いプロセスを誤って除外（**陽性**、false-positive）をを生じさせること、応答がないプロセスに、動作を停止しているというマークを付けるのが遅れて、誤れなき陽性で形式で参え、最終的には応答するであろうと期待する（**陰性**、false-negative）をも生むことの間に、常にトレードオフが存在することを意味します。

障害検出機構は、障害が発生したプロセスやプロセスできないプロセスを識別して、それらをアルゴリズムから除外し、活性を保証すると同時に安全性を維持する機能を果たす、ローカルサブシステムです。

活性と安全性は、特定の問題を解決するためのアルゴリズムの能力と、その出力の正しさを記述する特性です。さらに形式的な言い方をすれば、活性は、特定の望国されたイベントが**必ず**発生することを保証するための特性です。たとえば、いずれかのプロセスが障害を発生した場合、障害検出機構があるプロセスにdeadのマークを付けた場合、このプロセスは実際に停止していなければなりません [LAMPORT77] [RAYNAL99] [FREILING11]。

障害的な結果から見ると、障害の発生したプロセスを除外することと、不要な作业を行なくてすむことと、エラーの伝播をカスケード障害を防止できます。その一方で、動作していない疑いのあるプロセスを除外すると、可用性を低下させることになります。

障害検出アルゴリズムは、いくつかの必要不可欠な特性を明示しなければなりません。まず第一に、すべてでの障害のないメンバーは、最終的にプロセスの障害を認識しなければならず、アルゴリズムは、実行を続けてその最終的な結果に到達できなければなりません。この特性は、**完全性**と呼ばれます。

アルゴリズムの品質は、その**効率性**で判断できます。それは、障害検出機構がプロセスの障害を迅速に検知し、それを詳細することもう1つの方法は、アルゴリズムの**精度**を見ることです。それは、プロセスの障害が正確に検出されたかどうかです。別の言い方をすれば、アルゴリズムが正確ではないのは、正常なプロセスに障害が発生していると、アルゴリズムが誤って判断した場合や、故障の障害を検出できない場合です。

効率性と精度の間には、トレードオフがあります。障害の兆候として、早く対応する必要であると考えられます。アルゴリズムの効率性が高くなれば、精度性は低くなる可能性があり、アルゴリズムの精度が高くなれば、通常、効率性は低くなります。精度と効率性を兼ね備えた障害検出機能を構築することは、おそらく不可能でしょう。同様に、障害検出機構は、陽性性を生成する、つまり誤って正常なプロセスに障害があると誤認してしまうかもしれません [CHANDRA96]。

障害検出機構は必须条件であり、多くの合意アルゴリズムおよびアトミックブロードキャストアルゴリズムにとって、必要不可欠な要素です。これについては、本書の後半で検討する予定です。

多くの分散システムでは、ハートビートを使用して障害検出機構を実装しています。このアプローチは、その単純さと強い完全性のため、非常に人気があります。以下で検討するアルゴリズムでは、ビザンチン障害は存在しないことを前提にします。つまり、プロセスが自身の状態、またはその近くのプロセスの状態について、意図的に誤ったメッセージを送信することはないと仮定します。

## ハートビートとping

リモートプロセスの状態は、以下2つの定期的なプロセスのいずれかを起動することで、問い合わせることができます。

- **pingを起動します**: このコマンドは、リモートプロセスにメッセージを送信し、指定された時間内に予期した応答があるかどうかを、それらが正常に動作しているかを確認します
- **ハートビートを起動します**: これは、プロセスがそのピアにメッセージを送信して、自身がまだ稼働中であることを積極的に通知するときに使用します

ここでは例として pingを使用しますが、ハートビートを用いて同じ問題を解決し、同じ結果を得ることもできます。

各プロセスは、他のプロセスのリスト（正常に動作、動作を停止、疑わしいものなど）を維持し、その状態が疑問視された場合に、そのリストを更新します。プロセスが長時間に渡って応答しない場合や、メッセージへの応答に失敗する場合、そのプロセスには疑わしいというマークが付けられます。

図9-1は、システムが正常に機能している状態を示しています。プロセスP₁が、近くのノードP₂の状態を問い合わせており、ノードP₂は、確認応答を返しています。

これと反対に図9-2は、確認応答メッセージが直理していない様子を示しています。この場合には、生存しているプロセスに、ダウンしているという �マークが付けられる可能性があります。

多くの障害検出アルゴリズムは、ハートビートとタイムアウトに基づいています。たとえば、分散システムの構築によく使用されるプロトコルであるAkkaには、デッドライン障害検出機構（https://databass.dev/links/41）が実装があり、今どこでハートビートが使用され、プロセスが固定の時間内で登録に失敗すると、プロセスの障害がレポートされます。

このアプローチには複帰的な欠点がいくつかあります。たとえば、その精度はpingの頻度およびタイムアウトの値重方法法に依存します。さらに、「他のプロセスから見た別のプロセスの前提状を補選することが期待できません（p.204「9.1.2 ハートビートのアウトソーシング」）。

### タイムアウトフリーな障害検出機能

アルゴリズムの中には、障害検出の際に、タイムアウトへの依存を避けているものもあります。たとえば、Heartbeatという名のアウトソースフリーの障害検出機構 [AGUILERA97] は、ハートビートのみでカウントし、アプリケーションが、ハートビートのカウンタベクトル内のデータに基づいてプロセスの障害を検出することを可能にします。このアルゴリズムはタイムアウトフリーなので、非同期システムの構築ももとも動作します。

非同期な環境でいくつかのプロセスが、すべて相互にフェアパス（fair path）で接続されていることを前提とします。フェアパスとはフェアリンク（つまり、メッセージがこのリンクを介して断続なく同様も送信される場合には、順路に順延なく何度でも受信される手）のみが含まれます。ここに、各プロセスがネットワーク内の他のすべてのプロセスの存在を認識していることを前提とします。

各プロセスは、近くのプロセスのリスト、およびそれらに関連付けられたカウンタを管理します。プロセスは、はじめにハートビートのメッセージを近くのプロセスに送信します。各メッセージには、ハートビートの送信元であるプロセスのIDが含まれます。最初のメッセージには、パス内の最初の送信元とー意のIDが含まれます。このIDは、同じメッセージを複数回ブロードキャストするのを防止するために使用できます。

プロセスが新しいハートビートメッセージを受信すると、パスに含まれるすべての参加プロセスのカウンタを増加し、自身をパスに追加して、パスに含まれていない参加プロセスにこのハートビートを送信します。プロセスは、認識されているすべてのプロセスが、すでにこのメッセージを受信したことを言い換えると、プロセスIDがパスに表れることを確認すると、即座にメッセージの伝播を停止します。

メッセージは多様な広方でを経由し、ハートビートのパスには、近くのプロセスから受信して集められた情報が含まれているので、2つのプロセス間を直接つなぐリンクに障害が発生しているときでも、アクセス可能きないプロセスに、正常に動作していると、正しくマークすることができます。

ハートビートのカウンタは、システム全体の正規化されたビューを表します。このビューには、ハートビートが相互に関連しながらどのように伝播されているかが捉えられており、プロセスの状欠を可能にします。ただし、このアプローチの短所の1つは、ハートビートカウンタの増加が、かなり手の込んだ作柄になるということです。たとえば、信頼できる結果を生成できる閾値を選べるよう、それがどこ機能するのか適用するこちが若干難しいようです。それがてき なければ、アルゴリズムは、有効なプロセスに疑わしいというマークを誤って付けることがかわれません。

### ハートビートのアウトソーシング

上記に代わるアプローチとして、SWIM（scalable weakly consistent infection-style process group membership protocol）[GUPTA01]で使用されているのは、ハートビートのアウトソーシングを使用して信頼性を向上させる方法です。これには、近くのプロセスから見た当該プロセスの存在性に関する情報が使用可能になります。そのため、プロセスがネットワーク内の他のすべてのプロセスを認識する必要がなく、認識する必要があるのは、接続されたピアのサブセットのみです。

図9-3に示すように、プロセスP₁がプロセスP₂にpingメッセージを送信します。P₂はこのメッセージに応答しました。しかがって、P₁は次の段階に進んで、複数のランダムなメンバーP₃とP₄を選択します。これらのランダムなメンバーは、P₂へハートビートメッセージの送信を試み、応答があった場合には、確認応答を転送して、P₁に戻します。

このアプローチでは、直接的にアクセスできるかと、間接的にアクセスできるかを、両方とも確認できます。たとえば、P₁、P₂、およびP₃というプロセスがある場合に、P₃の状態をP₁とP₂の双方の観点から確認できます。

ハートビートのアウトソーシングを使用すると、判断の責任をメンバーのグループ全体に教すことによって、信頼性の高い障害検出機が可能になります。このアプローチでは、広範なノードのみがブロードキャストする必要があります。ハートビートのアウトソーシングの要求は平行で起動できるので、このアプローチによって、疑わしいプロセスに関してより多くの情報を速やかく取集でき、より的確な決定を行うことが可能になります。

## Phi-Accural Failure Detector

ノードの故障を、ご段択の期間として提供する際には、プロセスの状態は、動作しているか動作していないかの2通りしかありません。その代わりに、Phi-Accural（φ-accural）Failure Detector [HAYASHIBARA04] には連続としたノ段衣があり、監視対象のプロセスのクラッシュを確率論的に検討します。これは、スライディングウインドウを構築し、プロセスのビアからの、最新のハートビートの到着時刻の統計を収集することで実現されます。この情報は、次のハートビートのおよびその到着時刻を近似し、この値倍を実際の到着時刻と比較し、**疑わしいのレベルであるφ**を計算するために使用されます。このレベルは、現在のネットワークの条件を考慮に入れて、Phi-Accuralが Failure Detectorの異常を動的に調整できるようにします。

このアルゴリズムは、著信時刻を取集してサンプリングし、ノードの値を調べ について石舎できる判断を行うために使用できるピューを作成します。これらのサンプルは、φの値を計算するために使用されます。この統計的関数に関連するど、ノードにはダウンしているというマークを付けたらいけません。この障害検出機構は、ノードに疑わしいという保定を付ける民度を調整することで、ネットワークの状態の変化に動的に適応します。

アーキテクチャの観点からは、Phi-Accural Failure Detectorは、以下3つのサブシステムが結合されたものとして見ることができます。

### モニタリング（Monitoring）
ping、ハートビート、または要求と応答のサンプリングを介して活性情報を収集します。

### 解釈（Interpretation）
プロセスに疑わしいとマークすべきか否かを決定します。

### アクション（Action）
プロセスが疑わしいとマークされたときに必ず実行されるコールバックです。

モニタリングプロセスは、データサンプル（正規分布に従っていると仮定される）を収集し、ハートビートの到着時間の到来のタイムウインドウに保存します。新たな受信があった場合にこの情報が統合されます。

分布のパラメータは、サンプルの平均と分散を確定することで、サンプリングウインドウから抽出されます。この情報を多過に入れてφを計算します。この値は、プロセスの活性度を同じに決定するのに使用されます。この値が、言い換えれば、規定の決定サイクルを組み込みかどうかの程度をあらを表します。言い換えれば、決定サイクルに障害を認識させるハートビートを受け取るか決定に反するハートビートを設定して、詳算せ求めた値に反して、すべてのピアに確認するプロセスに正常に動作しているとらせる、最短を認定します。

このアプローチは、北陸先端科学技術大学院大学（Japan Advanced Institute of Science and Technology）の研究者たちによって開発され、現在では多くの分散システムで使用されています。たとえば、Cassandra（https://databass.dev/links/42）でも使用され、Akka（https://databass.dev/links/43）では、前述のデッドライン障害検出機構と併用されています。

## ゴシップと障害検出

決定を行う際に、単一ノードのビューに依存するのを避けるためのもう1つのアプローチは、ゴシップ方式の障害検出サービスです [VANRENESSE98]。このサービスでは、ゴシップ（p.258「12.6 ゴシップの散布」）を使用して、他のプロセスの状態を効しておよび配信します。

各ノードは、ハートビートカウンタ、およびタイムスタンプのリストを管理します。このタイムスタンプには、ハートビートカウンタが最終的に増分された時刻が記されています。各メンバーは、定期的にそのハートビートカウンタに加算し、ランダムに選択した近く近くのノードに、そのメッセージを受け取りと更新します。近くのノードは、そのメッセージを受け取ると、そのリスト中のハートビートカウンタを更新します。

また、ノードは、状態とハートビートカウンタのリストのチェックも定期的に行われます。いずれかのノードが長時間に渡ってそのカウンタを更新していなかった場合には、そのノードは障害が疑られます。このタイムアウトの長さは、陽性の確率を最小にするように、故意に伝播された最大での帯域幅に時間する可能性があります。

図9-4は、3つのプロセスがそれぞれのハートビートカウンタを共有しながら通信する様子を示しています。

- a) 3つともすべて通信でき、タイムスタンプを更新できます
- b) P₃ はP₁ とP₂ と通信できませんが、そのタイムスタンプもはP₂ の近くを介して引き続き伝播できます
- c) P₃がクラッシュします。それ以上更新を送信しなくなるので、他のプロセスによって故障が発生したと検出されます

このようにして、クラッシュしたノードを検出でき、併せて他のクラスタメンバーがアクセスできないノードも検知できます。クラスタのビューは複数のノードからもたらものなので、この決定は信頼性が高くなります。2つのホスト間にリンクの障害があったとしても、ハートビートは他のプロセスを介して伝播できます。システムの状態を伝播するためにゴシップを使用すると、システム内でのメッセージの数が増加します。情報の拡散の信頼性を高められます。

## リーダー選出

同期には、かなりのコストがかかる可能性があります。アルゴリズムの各ステップで参加ノード間の通信が必要な場合には、通信オーバーヘッドが大幅に増大することがあります。このことは、単一のノードもしくは長生存したノーケワークでは、特に顕著になります。同期のオーバーヘッドを減らし、決定を達成するために必要なメッセージのラウンドトリップを削減するため、に使用できます。リーダーは、グローバルな状態を収集して保持し、メッセージを受け取り、それらをプロセス間に配布します。また、障害の後や、初期化の間、あるいは重要な状態の変更が行われたときに、システムの再編成を調整するために提出することもできます。

すべての場合ですべてのメッセージの全順序を決定するために、リーダーの使用が必要になります。あるいは、前のリーダーがクラッシュしたり、通信に失敗したときにも、選出は起動されます。選出は、決定論的（deterministic）なものでなければなりません。厳密に1つのリーダーが、そのプロセスから選出しなければなりません。この決定は、すべての参加ノードに有効である必要があります。

リーダーの選出と分散ロック、つまり共有リソースの排他的な所有権は、理論的な観点からは同等しています。1つのプロセスが一重なセクションを実行できるのと同じ限りは、つまり、ロックを保持しているのは実際のロックを行うプロセスだけであり、そのプロセスがクラッシュするまでのほかのすべてのプロセスはそれを受信できるようになるという限りは、実際にどのプロセスが現在ロックを保持しているかを知ることは、他のプロセスにとって重要ではありません。それとは対照的に、選出されたプロセスは、いくつかの特別な機能を持ちます。他のすべての参加ノードにも知られはなりません。したがって、リーダーが新しく選出されたときには、その役割について、他のノードに通信する必要があります。

分散ロックのアルゴリズムに、一部のプロセスやプロセスグループを優先する部面がある場合、優先するプロセスかの序列の妥協を持ちます。それぞれの経路に対して優れはなければなりません。したがって、リーダーの選出の文脈では、長期間存在するロードが必要です。関数、正常なプロセスのサブセットからのリーダーが選出されるということであり、リーダーを選出された場合を除いて、他のノードとのループを保持しているかを知ることは、他のプロセスにとって重要ではありません。それとは対照的に、選出されたプロセスは、いくつかの特別な機能を持ちす。他のすべての参加ノードに知られはければなりません。

分散ロックのアルゴリズムに、ー蔀のプロセスやプロセスグループを優先する部間がある場合、優先するプロセスかの序列の妥協を持ちます。それぞれの指針に対して優れはなければなりません。したがって、システムにおいて、ー部のプロセスを他のプロセスより先に優先的に検討しなければなりません。

システム内に安定したリーダーが存在することで、リモートの参加ノードで欠談を及和くことを不要となります。メッセージ交換の回数を減らすことが可能になり、決定を達成するための代わりに、単一プロセスからの実行を推進するために有用です。リーダーシップの概念を持つシステムの問題の1つは、リーダーがボトルネックになる可能性があるとことです。この問題を克服するための多くのシステムでは、重複ない個い出しとレプリカセットにデータを分割します（p.281「13.6 データベースパーティショニング」）。各レプリカセットには独自のリーダーを選出します。このアプローチを使用しているシステムの1つがSpanner です（p.279「13.5 Spannerによる分散トランザクション」）。

すべてのリーダープロセスはいずれ状態を発信するものの、障害を検出し、候補し、対処するすべての手順を経なければなりません。システムでは、障害を発生したリーダーに代わる別のリーダーを選出するための複数のラウンドのメッセージ数のラウンドが増加するため、一部のリーダー選出のアルゴリズムが、このルールに適従していまず。

リーダー選出に先って、メッセージの全順序を決定するためにメッセージに使用できます。リーダーは、グローバルな状態を収集して保持し、メッセージを受け取り、それらをプロセス間に散布します。また、障害の後や、初期化の間、あるいは重要な状態の変更が行われたときに、システムの再編成を調整するために提出することもできます。

選出アルゴリズムの活性によって、ほとんど途切れることなくリーダーが存在し、選出が最終的には完了するすることが保証されます。つまり、システムは遷却状態を解消しなければなりません。既往とします、**安全性**も重要にし、同時に存在できるリーダーは**多くても1つ**あることを保証します。死蔵としては、どのような目的のために機能するリーダーが2つの選出されたが、相互の存在を認知していない状況）となる可能性を、完全に排除することは望ましですれは、それは複数のプロセスが同じメッセージを処理し、その結果について、他のノードに通信する必要があります。

ZAB（p.295「14.2.2 Zookeeper Atomic Broadcast（ZAB）」）、Multi-Paxos（p.303「14.3.4 Multi-Paxos」）、またはRaft（p.314「14.4 Raft」）のどら一部のアルゴリズムでは、参加ノード間に射意を達成する際に必要なメッセージの数を削減するために、一時的なリーダーを使用します。しかし、これらのアルゴリズムでは、それぞれのアルゴリズム固有の手段を使用して、リーダーの選出、障害の検出、および競合するリーダープロセス間の衝突の解決を行っています。

## フリーアルゴリズム

リーダー選出のアルゴリズムの1つで、フリーアルゴリズム（bully algorithm）と呼ばれているものでは、プロセスのランクを使用して新しいリーダーを識別します。各プロセスには一意のランクが割り当てられます。その全うえで、選出の際にもっとも高いランクを割り当てられたプロセスがリーダーになります [MOLINAR82]。

このアルゴリズムは、その単純さで知られています。このアルゴリズムがフリーと名付けられているのは、ランクがもっとも高いノードがいしめるノード（bully）ことで、他のノードにそれぞれを受け入れさせるからです。また、**君主制のリーダー選出**と呼ばれることもあります。前の君主が存在しなくなった場合で、ランクがもっとも高い兄弟ノードが君主になるからです。

初期化されていないにシステム内にリーダーが存在しないことを、いずれかのプロセスが検知した場合、または前のリーダーが要求来の応答を停止した場合、選出が開始され、以下3段階のステップで進められます（1.1）。

1. プロセスは、より高いIDを割り当てられたプロセスに選出メッセージを送信します
2. プロセスは、ランクがより高いプロセスからの応答を待機します。ランクがより高いプロセスからの応答が受信された場合は、ステップ3に進みます。そうし以外の場合には、プロセスは、応答を受け取れた中でランクがもっとも高いプロセスに通知し、そのプロセスがステップ3に進むことを許容します
3. プロセスは、ランクがより高く有効なプロセスが存在しないことを前提に、ランクが低いすべてのプロセスに、新しいリーダーについて通知します

図10-1は、以下に示すようなリーダー選出のフリーアルゴリズムを示したものです。

- a) プロセス3は、前のリーダー6がクラッシュしたことを検知し、より高いIDを割り当てられたプロセスにElection（選出）のメッセージを送信して、選出を新しく開始します
- b) 4と5は、3よりランクが高いので、Alive（動作中）であるという応答を返します
- c) 3は、この選出ラウンドで応答してきた中でランクがもっとも高いプロセス5に通知します
- d) 5が新しいリーダーとして選出されます。新しいリーダーはElected（選出済み）のメッセージをブロードキャストして、ランクの低いプロセスに選出結果を通知します

このアルゴリズムの枠内の明白な問題の1つは、ネットワーク分断が存在する場合に、安全性の保証されていです。最も高いランクのノードがある1つ以上のサブセットでリーダーが選ばれることに運続するとです。ノードが独立していかに判断を下さすニとすることになるとです。この状況は、**スプリットプレイン**（split brain）と呼ばれます。

不安定でランクが高いノードは、それらのノードが不安定で、前選出が極と上行われれる状態になかわれない場合です。不安定でランクが高いノードは、それ自体をリーダーとして提案しますが、その後すぐに故障を発生し、再選出を開始させることになります。この問題は、スケジュールのの周辺状態を配慮し、選出時にそれらを考慮に入れることで解決できます。

## 次候補へのフェイルオーバー

フリーアルゴリズムには、そのままきまな貨幣を改善した多くのバージョンが存在します。たとえば、次に候補となる（next-in-line）複数の代替プロセスをフェイルオーバー先にすることで、再選出を短縮できます [GHOLIPOUR09]。

それぞれの選出されたリーダーは、フェイルオーバー先のノードリストを維持します。いずれかのリーダーが障害を発生したり、次の候補が現したり新しい選出ラウンドを開始するために、障害を発生したリーダーによって提供されたリスト内でランクがもっとも高い**代替プロセス**にメッセージを送信します。指定された代替プロセスのいずれが動作中であれば、それが新しいリーダーになります。この場合には、完全な新的選出ラウンドを経る必要がありません。

リーダーの障害を検出したプロセスが自体が障害である場合には、即座に新しいリーダーについて、他のプロセスに通信できます。

図10-2は、この拡張化が効果を発揮している選出のプロセスを示しています。

- a) 代替プロセスとして、{5,4}が指定されているリーダー6がクラッシュします。3がこの障害を検知し、リスト内でランクがもっとも高い代替プロセスである5に通知します
- b) 5は、正常に動作中であることに応答して、代替プロセスのリストに含まれる他のノードと通信することを防止します
- c) 5は、自分が新しいリーダーになったことを他のノードに通知します

次に候補となるプロセスが正常に動作中である限には、結末的に選出時間が減設されます。

## 候補者/一般人の最適化

もう1つのアルゴリズムでは、必要なメッセージの数を削減するために、ノードを**候補者**（candidate）と**一般人**（ordinary）という2つのサブセットに分割します。これらの中から候補者ノード1つのみが最終的にリーダーになります [MURSHED12]。

一般人プロセスは、候補者ノードにコンタクトすることで選出を開始し、候補者ノードからの応答を収集して、ランクがもっとも高い動作中の候補者を新しいリーダーとして選出します。次に、一般人プロセスは、障害を検知している候補者たちに通知します。

同時に複数の選出が行われるという問題を解決するために、このアルゴリズムでは、タイブレーカー変数8の使用を提案しています。これはプロセス固有の延楼を表し、ノード間で大幅に異なるような値である必要があります。タイブレーカー変数8が大きいほど、一般的にメッセージのラウンドトリップの時間よりは長くなります。優先度が高いノードはどの遅延も発生せず、優先度が低いノードほどの遅延ます。

図10-3は、選出プロセスの手順を示しています。

- a) 一般人のセットに含まれるプロセス4が、リーダープロセス6の障害を検知します。プロセス4は、新しい選出を開始するために、候補者のセットに含まれる残りのプロセスのすべてに通信します
- b) 複数の候補者プロセスが4に応答して、それぞれが到着き続き動作中であることを通知します
- c) 4が、新しいリーダーが2であることをすべてのプロセスに通知します

次に候補となるプロセスが正常に動作中である限に、結出的に選出間が増설されます。

## 招待アルゴリズム

招待アルゴリズムは、プロセス間でランクの高さを設おうとするのではなく、他のプロセスを招待（invite）してグループに参加させることを可能にします。このアルゴリズムでは、グループごとにリーダーが存在するので、**定義上、複数のリーダーが付存**されます。

各プロセスの開始時には、そのプロセスのグループのリーダーになります。このとき、グループにおけるメンバーはそのプロセスだけです。グループリーダーは、そのグループに属していないノードに通信し、そのグループに参加するように招待します。招待を受けたプロセスそ自身もリーダーである場合には、2つのグループはマージされます。それ以外の場合には、通信を受けたプロセスが応答してそのグループリーダーのIDを伝えるので、2つのグループリーダーで通信できて確認できます、少ない手順でグループをマージできます。

図10-4は、招待アルゴリズムの実行手順を示しています。

- a) 4つのプロセスが閘始され、それぞれが1つのメンバーで構成されるグループのリーダーになります。1が、そのグループに参加するように2を招待し、3が、そのグループに参加するように4を招待します
- b) 2がプロセス1のグループに参加し、4がプロセス3のグループに参加します。最初のグループのリーダーである1が、もう1つのグループのリーダーである3に通知します。そのグループの残りのメンバー、この場合には4は、新しいグループリーダーについての通知を受けます
- c) 2つのグループがマージされ、1が避定後のグループのリーダーになります

グループはマージされるので、グループのマージを提案したプロセスが新しいリーダーになる可能性があります。グループをマージする際には、大きいほうのグループのリーダーが新しいグループのリーダーになるようにします。こうすれば、リーダーの変更について通知する必要があるのは、小さいほうのグループに属していたプロセスの次になります。

すでに採用した他のアルゴリズムと同様に、このアルゴリズムでも、プロセスの複数のグループに分割され、複数のリーダーが選出されることが許容されます。招待アルゴリズムは、プロセスグループの作成およびそれらのマージを可能にします。その際に、選出を最初から開始する必要はなく、選出を実行するまでに必要なメッセージの数を削減できます。

## リングアルゴリズム

リングアルゴリズム [CHANG79] では、システム内のすべてのノードがリング（輪）を形成し、リンクが隣り合っている次のノードの存在を認めて、先の後続のノードと後続のノードを認識します。プロセスは、リーダーの障害を検出すると新しい選出を開始します。選出メッセージは、リングを介して転送されます、つまり、各プロセスはその後続のノード、つまりリング内でもっとも近くにある次のノードに通信します。このノードが動作を停止している場合、プロセスはそのアクセスいノードに連絡しようとします。選出メッセージがいずれかの化のプロセスの状態について、意図的に誤ったメッセージを送信するかがあります、結果的に、いずれかが応答するまでこれを繰り返します。

ノードはそれぞれの兄弟ノードにコンタクトし、リングをたどりながら、正常に動作している関候補のノードを送されます。それそれのノードには、その自身のIDをパスに追加して通信されます。そして、それを次のノードに送します。

アルゴリズムが実行すると、リングを完全に一周ヘとこになります。選出を開始したノードまでメッセージが戻って来ると、正常に動作しているセット中の、ランクがもっとも高いノードがリーダーとして選出されます。図10-5に、上述のようにリングをたどる例を示します。

- a) 前のリーダー6で障害が発生しました。各プロセスは、それぞれの観点から見たリンクのビューを保持しています
- b) 3が選出ラウンドを開始して、リンクをたどり始めます。各ステップでそれまでの経路でたどったノードのセットが拡張されます。5は6に到達できません。したがって、それをスキップし、直後に進みます
- c) 5はランクがもっとも高いノードだったので、3はメッセージの別のラウンドを開始して、新しいリーダーに関する情報を配信します

このアルゴリズムの画種の中には、有効なノードのセットの代わりに、ランクがもっとも高いIDを1つだけ取集して領域を節約するものがあります。max関数は結果を交換可能なので、現在の最大値を知っていれば十分です。選出を開始したノードにアルゴリズムが戻って来ると、最後に認識されていたもっとも高いIDが新規リンクを介して引き続き伝播されます。

リング は2つ以上の分位に分割され、可能性としてはそれぞれの部分が選出されきるので、このアプローチにも安全性の特性はありません。

これまで見てきたように、リーダーを持つシステムが正しく機能するには、現在のリーダーの状態が常に創作しているか否かを知る必要があります。プロセスの親織的な動作を識別し、失行なユーザーのアクセス可能なられば、その構言を果たせなくなります。リーダーのクラッシュを検出するには、障害検出アルゴリズムを使用できます（9章）。

## まとめ

リーダー選出は、分散システムにおいて重要なテーマです。それは、指定されたリーダーを使用することで、通常のオーバーヘッドを削減し、アルゴリズムの作棠を改善することが可能になるからです。選出ラウンドにはコストがかかるようによいって越したことがありませんが、単純に行われるわけではないので、システム全体の性能に対して代の影響はありません。単一のリーダーはポトルネックになる可能性がありますが、多くの場合、これはデータを分割し、分割した部分ごとのリーダーを使用することで解決されます。

残念なことですが、この章で検討したアルゴリズムは、すべてでスプリットブレインの問題を引き起こす可能性があります。つまり、おれぞれの存在を認識していない2つのリーダーが、独立した中国たネットワークに選出されることを防げません。スプリットブレインを防止するには、クラスタをページョンに分割し、システムが正常に動作していてアクセス可能なられば、最殖を果たせなくなります。

Multi-PaxosやRaftを含む多くの合意アルゴリズムでは、リーダーに依存して調整を行います。しかし、リーダー選出は合意と同じことです。リーダーを選出するには、その存在に関して合意に達する必要があります。リーダー選出と障害検出を組み合わせてレプリカを介して選出が結実されるようにすると、安全で信頼性のある結実を使用して、他のどのような事柄についても合意に達することが可能です [ABRAHAM13]。

リーダーの属性が変更されても、プロセスにはそれが伝わらないことがあるので、リーダーに関するプロセスローカルな情報がまだ有効であるかどうかが問題になります。この問題に対処するには、リーダー選出と障害検出を組み合わせて証拠を提示する必要があります。たとえば、安定したリーダー選出の場合アルゴリズムでは、単一の安定したリーダーの選出ラウンドとタイムアウトに基づく障害検出を使用して、リーダーがクラッシュしたりアクセス不可能になったりしない限り、その地位を維持できることを保証しています [AGUILERA01]。

リーダーは、上位にあっても正しく使用し使わないまま場合にも、リーダーに関する属性（現在のリーダーが障害を発生した場合には、新しいリーダーが必要になること）を保証する手段であり、プロセスからすれば、リーダーが本当に障害を発生したのかどうかを知るために、階層的で長い時間をかけるべきではありません。**安全性**の欠如と複数のリーダーを許容することは、パフォーマンスの最速化です。アルゴリズムは、レプリケーションのフェーズを進めることができ、**安全性**は、競合を検出して解決することで保証されます。

合意と、合意の文脈におけるリーダー選出については、14章で詳細に議論します。
