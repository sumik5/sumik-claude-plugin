# NoSQL・特殊用途データベースモデル

> NoSQLおよび特殊用途データベースモデルの詳細リファレンス

---

## Document-oriented Database

### 概要

Document-oriented Database（ドキュメント指向データベース、またはDocument Store）は、ドキュメント指向の情報（半構造化データ）を格納・取得・管理するために設計されたデータベースシステムです。NoSQLデータベースの主要カテゴリの1つであり、XML DatabasesはDocument-oriented Databaseのサブクラスとして位置づけられます。

### データ構造

**ドキュメントの概念**:
- ドキュメントはプログラミングオブジェクトの概念に相当
- 標準スキーマへの準拠は不要（スキーマレス）
- 同一ストア内で異なるドキュメント構造を許容

**サポートするエンコーディング**:
- JSON
- BSON
- XML
- YAML
- 独自バイナリ形式

**例（JSON形式ドキュメント）**:
```json
{
  "FirstName": "Bob",
  "Address": "5 Oak St.",
  "Hobby": "sailing"
}
```

**例（XML形式ドキュメント）**:
```xml
<contact>
  <firstname>Bob</firstname>
  <lastname>Smith</lastname>
  <phone type="Cell">(123) 555-0178</phone>
  <address>
    <type>Home</type>
    <street1>123 Back St.</street1>
    <city>Boys</city>
    <state>AR</state>
  </address>
</contact>
```

### Key-Value Storeとの違い

| 特性 | Key-Value Store | Document-oriented Database |
|------|----------------|---------------------------|
| データの扱い | データは不透明（ブラックボックス） | 内部構造を理解してメタデータ抽出 |
| 検索機能 | キーベースのルックアップのみ | コンテンツベースのクエリが可能 |
| メタデータ理解 | なし | フィールドの意味を理解（例: 電話番号 vs 郵便番号） |

Document-oriented Databaseは、ドキュメント内の構造を利用してメタデータを分類し、例えば「555を含む電話番号」を検索する際に郵便番号55555を除外するなど、より高度な検索が可能です。

### CRUD操作

Document-oriented Databaseは以下の基本操作をサポートします：

- **Create（作成/挿入）**: 新規ドキュメントの追加
- **Retrieval（取得/クエリ/検索/読み取り）**: ドキュメントの検索
- **Update（更新/編集）**: 既存ドキュメントの変更
- **Deletion（削除）**: ドキュメントの削除

**アドレス指定**:
- ドキュメントは一意のキー（ID、URI、パス）で識別
- キーによる高速検索のためインデックスを保持
- キーを使った単純なルックアップに加え、コンテンツベースのクエリが可能

### ドキュメントの編成方法

**Collections（コレクション）**:
- ドキュメントのグループ
- 実装により、1つのコレクションにのみ属するか、複数のコレクションに属するかが異なる

**Tags and Metadata（タグとメタデータ）**:
- ドキュメントコンテンツ外の追加データ
- 検索や分類に利用

**Directory Hierarchies（ディレクトリ階層）**:
- パスやURIに基づくツリー構造
- 論理的または物理的な編成

### リレーショナルDBとの比較

| 特性 | リレーショナルDB | Document-oriented Database |
|------|-----------------|---------------------------|
| スキーマ | 事前定義必須、すべてのレコードが同一フィールド | スキーマレス、各ドキュメントが異なる構造可能 |
| データ分散 | 正規化により複数テーブルに分散 | 1つのオブジェクトの全データを1ドキュメントに集約 |
| データ取得 | 外部キーで結合、複数テーブルを再構成 | 単一エントリで完全なオブジェクトを取得 |
| スキーマ変更 | 全レコードに影響 | 新規ドキュメントから追加可能、既存に影響なし |
| オブジェクト-リレーショナルインピーダンスミスマッチ | 存在する | 解消される |

**リレーショナルモデルの例（住所録）**:
- `CONTACT` テーブル: `FIRST_NAME`, `LAST_NAME`, `IMAGE`
- `PHONE_NUMBER` テーブル: `COUNTRY_CODE`, `AREA_CODE`, `PHONE_NUMBER`, `TYPE`, `CONTACT_ID`（外部キー）
- データ取得時に外部キーで結合して再構成

**Document-orientedモデルの例（住所録）**:
- 連絡先の名前、画像、すべての連絡先情報を単一ドキュメントに格納
- キーでアクセスすれば、追加の結合操作なしで全情報を取得

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| スキーマが頻繁に変化するアプリ | ⭐⭐⭐ | スキーマレス設計で柔軟に対応可能 |
| オブジェクト指向アプリケーション | ⭐⭐⭐ | オブジェクト-リレーショナルインピーダンスミスマッチを解消 |
| 階層的・ネストしたデータ | ⭐⭐⭐ | ドキュメント構造が自然にマッピング |
| コンテンツ管理システム | ⭐⭐⭐ | ドキュメント単位の管理が容易 |
| カタログ・商品情報 | ⭐⭐⭐ | 商品ごとに異なる属性を柔軟に格納 |
| 複雑なリレーション・トランザクション | ⭐ | リレーショナルDBの方が適切 |
| 複数ドキュメントにまたがる集計 | ⭐⭐ | リレーショナルDBの方が効率的 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| スキーマレスで開発が柔軟・高速 | 複雑な結合操作が苦手 |
| オブジェクト-リレーショナルインピーダンスミスマッチの解消 | トランザクション保証がリレーショナルDBより弱い場合がある |
| 水平スケーリングが容易 | データの一貫性管理が複雑 |
| 単一ドキュメントでの完全なデータ取得 | データ重複が発生しやすい |
| 階層的データの自然な表現 | 標準化されたクエリ言語が存在しない |

### 代表的な実装・製品

- **MongoDB**: 最も普及しているドキュメント指向DB、BSONフォーマット
- **Couchbase**: 分散型、高可用性、メモリファースト
- **Amazon DynamoDB**: フルマネージドNoSQL、キー-バリューとドキュメントをサポート
- **Elasticsearch**: 検索エンジンとしても機能、ドキュメントストアの定義を満たす
- **Azure Cosmos DB**: グローバル分散、マルチモデル対応

### 注意点

- **スキーマ設計の見直し**: スキーマレスとはいえ、ドキュメント構造の一貫性は重要。アプリケーションレベルでスキーマバリデーションを検討する
- **データ重複の管理**: 正規化しないため、同じ情報が複数ドキュメントに存在する場合がある。更新時の一貫性に注意
- **クエリパフォーマンス**: インデックス戦略が重要。適切なインデックスなしでは大規模データセットで性能劣化
- **トランザクション**: 複数ドキュメントにまたがるACIDトランザクションのサポートは実装により異なる。最近のMongoDBなどは対応

---

## XML Database

### 概要

XML Database（XMLデータベース）は、XMLフォーマットでデータを指定・格納できるデータ永続化ソフトウェアシステムです。Document-oriented Databaseのサブカテゴリであり、NoSQLデータベースの一種として位置づけられます。

### XMLをデータベースで使用する理由

- **既存の標準フォーマット**: 企業に既に大量のXMLデータが存在
- **データ交換**: XMLでのデータ公開・取得が必要な場合、リレーショナル形式との二重モデリングを回避
- **スパースデータ・深いネスト・混在コンテンツ**: XMLが最適
- **可読性**: XMLは人間が読める、リレーショナルテーブルは専門知識が必要
- **メタデータ**: XMLフォーマットで提供されることが多い
- **セマンティックWebデータ**: RDF/XMLとして利用可能
- **オブジェクト-リレーショナルインピーダンスミスマッチの解消**

### XML Enabled Database vs Native XML Database

**XML Enabled Database（XML対応データベース）**:
- リレーショナル構造内にXMLを格納
- 主に以下のアプローチを採用:
  - **CLOB（Character Large Object）にXMLを格納**
  - **スキーマに基づいてXMLを複数テーブルに分解（shredding）**
  - **ISO Standard 9075-14で定義されたネイティブXML型を使用**
- サポートRDBMS: IBM DB2（pureXML）、Microsoft SQL Server、Oracle Database、PostgreSQL
- **適用場面**: 大半のデータが非XMLの場合に最適

**Native XML Database（ネイティブXMLデータベース）**:
- XMLデータ専用に最適化された構造
- XMLノードとドキュメントが論理ストレージの基本単位
- 読み取り専用クエリと更新の両方で高いパフォーマンス
- カスタム最適化データ構造を使用
- **適用場面**: 大半のデータがXMLの場合に最適

### クエリ・変換言語

**XQuery**:
- W3C推奨の標準XMLクエリ言語
- 最新バージョン: XQuery 3.1
- XPathをサブ言語として含む
- XML自体がXQueryの有効なサブ構文
- Native XML DatabaseはXQueryの完全サポートを提供

**XPath**:
- XML文書内のノードを選択するための言語
- XQueryのサブセット

**XSLT**:
- ドキュメントまたはクエリ結果を変換
- 一部のXML Databaseでサポート

### 代表的な実装・製品

**Native XML Database**:
- **BaseX**: BSD、Java、XQuery 3.1対応、RESTful/WebDAV/XQJサポート
- **eXist**: GNU LGPL、Java、XQuery 3.1対応、RESTful/WebDAV/XQJサポート
- **MarkLogic Server**: 商用、C++、XQuery 3.0対応、RESTful/WebDAVサポート
- **Qizx**: 商用、Java、RESTfulサポート
- **Sedna**: Apache License 2.0、XQJサポート

**XML Enabled Database**:
- **IBM DB2（pureXML）**: ISO XML型サポート
- **Microsoft SQL Server**: ISO XML型サポート
- **Oracle Database**: ISO XML型サポート、Berkeley DB XML
- **PostgreSQL**: ISO XML型サポート

### サポートAPI

| 製品 | XQJ | XML:DB | RESTful | RESTXQ | WebDAV |
|------|-----|--------|---------|--------|--------|
| BaseX | Yes | Yes | Yes | Yes | Yes |
| eXist | Yes | Yes | Yes | Yes | Yes |
| MarkLogic Server | Yes | No | Yes | Yes | Yes |
| Qizx | No | No | Yes | No | No |
| Sedna | Yes | Yes | No | No | No |

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| ドキュメント管理システム | ⭐⭐⭐ | 混在コンテンツ（テキスト+マークアップ）の自然な表現 |
| コンテンツ公開システム | ⭐⭐⭐ | XMLベースのコンテンツ配信 |
| メタデータ管理 | ⭐⭐⭐ | XMLフォーマットのメタデータを直接格納 |
| セマンティックWeb | ⭐⭐⭐ | RDF/XMLの格納・検索 |
| レガシーシステム統合 | ⭐⭐⭐ | 既存XML標準フォーマットの活用 |
| 構造化トランザクションデータ | ⭐⭐ | リレーショナルDBの方が効率的 |
| 高速な集計・分析 | ⭐ | リレーショナルDBやOLAPの方が適切 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| XMLデータの直接格納・検索 | リレーショナルDBより複雑なクエリ構文 |
| 混在コンテンツの自然な表現 | パフォーマンスがリレーショナルDBに劣る場合がある |
| スキーマバリデーション（XSD） | 標準化が進んでいない部分がある |
| 階層構造の直接表現 | データ重複が発生しやすい |
| 既存XML資産の活用 | 学習コストが高い |

### 注意点

- **データ中心 vs ドキュメント中心**: XMLデータベースは「データ中心」（構造化データをXMLで表現）と「ドキュメント中心」（混在コンテンツ、マークアップ重視）の両方をサポート。用途により設計が異なる
- **パフォーマンスチューニング**: インデックス戦略が重要。XPathインデックス、フルテキストインデックスを適切に設定
- **XMLとJSONの選択**: 現代のアプリケーションではJSONの方が軽量で人気。XMLの利点（スキーマバリデーション、混在コンテンツ）が必要かを検討
- **ベンダーロックイン**: Native XML Databaseは標準化が不完全。移行が困難な場合がある

---

## Graph Database / Triplestore

### 概要

**Triplestore（トリプルストア、RDF Store）**は、トリプル（subject-predicate-object）の格納と取得に特化した専用データベースです。「Bob is 35」「Bob knows Fred」のように、主語-述語-目的語の3要素でデータを表現します。

### データ構造

**Triple（トリプル）**:
- **Subject（主語）**: データの主体
- **Predicate（述語）**: 関係性やプロパティ
- **Object（目的語）**: 値またはエンティティ

**例**:
- Subject: Bob
- Predicate: age
- Object: 35

**Quad Store（Named Graph）**:
- トリプルに「名前」を追加
- コンテキスト情報（データソース、タイムスタンプなど）を管理

### 実装アプローチ

**Native Triplestore**:
- ゼロから構築されたデータベースエンジン
- トリプル専用の最適化構造
- 長期的には高いパフォーマンスが期待される

**RDB上に構築されたTriplestore**:
- 既存のリレーショナルDBエンジン上に実装
- 初期開発コストが低い
- SQLからSPARQLへのマッピングは複雑で効率が劣る場合がある

**NoSQL Document-oriented上に構築**:
- MongoDBなどのNoSQLエンジンを利用
- 柔軟性が高いが、グラフトラバーサルの効率は課題

### SPARQL / RDF

**SPARQL**:
- トリプルストアの標準クエリ言語
- RDFデータの検索・操作

**RDF（Resource Description Framework）**:
- セマンティックWebの標準データモデル
- トリプル形式でリソースを記述

### 一般的なGraph Databaseとの違い

| 特性 | Triplestore | 一般的なGraph Database |
|------|-------------|------------------------|
| データモデル | トリプル（固定3要素） | ノード・エッジ・プロパティ（柔軟） |
| クエリ言語 | SPARQL | Cypher、Gremlinなど |
| 用途 | セマンティックWeb、オントロジー、ナレッジグラフ | ソーシャルネットワーク、推薦システム、不正検知 |
| Index-free Adjacency | 一般的にはない | 一部の実装で提供 |
| スキーマ | RDF Schema / OWL | 柔軟なプロパティグラフ |

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| ナレッジグラフ | ⭐⭐⭐ | 概念間の関係性を表現 |
| セマンティックWeb | ⭐⭐⭐ | RDF/SPARQLの標準サポート |
| オントロジー管理 | ⭐⭐⭐ | クラス階層・推論機能 |
| データ統合・リンクトデータ | ⭐⭐⭐ | 異なるデータソースのリンク |
| 推論エンジン | ⭐⭐⭐ | RDFSやOWLベースの推論 |
| ソーシャルネットワーク分析 | ⭐⭐ | 一般的なGraph DBの方が高速 |
| リアルタイム推薦 | ⭐⭐ | 一般的なGraph DBの方が適切 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| セマンティックWeb標準に準拠 | 一般的なGraph DBより学習コストが高い |
| RDF/SPARQLの互換性 | パフォーマンスが劣る場合がある |
| 推論機能のサポート | データモデルが固定的（トリプル） |
| データ統合が容易 | ツールエコシステムが限定的 |

### 代表的な実装・製品

**Native Triplestore**:
- **Blazegraph**: 高パフォーマンス、オープンソース
- **Stardog**: 商用、推論機能が強力
- **GraphDB（Ontotext）**: 商用、セマンティック推論に特化

**RDB上に構築**:
- **Virtuoso**: オープンソース、SQL/SPARQLハイブリッド
- **Oracle Spatial and Graph**: 商用、Oracleに統合

**NoSQL上に構築**:
- **AllegroGraph**: 商用、スケーラビリティ重視

### 注意点

- **一般的なGraph DBとの混同を避ける**: Triplestoreはセマンティック技術に特化。ソーシャルネットワークなどの用途にはNeo4j、Amazon Neptuneなどの一般的なGraph DBを検討
- **パフォーマンス**: 大規模データセットでのクエリ最適化が重要。SPARQLクエリの記述方法により性能が大きく変わる
- **推論のコスト**: OWL推論はクエリ時間を大幅に増加させる可能性がある。用途に応じて推論レベルを調整

---

## Temporal Database

### 概要

Temporal Database（時間データベース）は、時間インスタンスに関連するデータを格納するデータベースです。過去・現在・未来の時間情報を提供し、時間軸に沿ったデータの追跡を可能にします。Temporal Databaseは**Uni-temporal（単時間軸）**、**Bi-temporal（二時間軸）**、**Tri-temporal（三時間軸）**に分類されます。

### 時間軸の種類

**Valid Time（有効時間）**:
- 現実世界において事実が真である期間
- 過去・現在・未来のいずれも可能

**Transaction Time（トランザクション時間）**:
- データベースに記録された時刻
- 過去または現在のみ（未来は不可）

**Decision Time（決定時間）**:
- 事実についての決定が下された時刻
- 過去またはトランザクション時間まで（未来は不可）

### Uni-temporal / Bi-temporal / Tri-temporal

**Uni-temporal（単時間軸）**:
- Valid TimeまたはTransaction Timeのいずれか1つの軸を持つ
- 例: Valid Timeのみで「John Doeは1975年4月3日から1994年8月26日までSmalllvilleに住んでいた」

**Bi-temporal（二時間軸）**:
- Valid TimeとTransaction Time（またはDecision Time）の2つの軸を持つ
- 「現実世界での事実」と「データベースに記録された時系列」を両方追跡
- 例: 「John Doeは実際には1995年6月1日から2000年9月3日までBeachyに住んでいたが、データベースには2001年2月2日に記録された」

**Tri-temporal（三時間軸）**:
- Valid Time、Transaction Time、Decision Timeの3つの軸を持つ
- より複雑だが、意思決定履歴も含めた完全な追跡が可能
- 例: 副大統領の承認決定日とデータベース記録日が異なるケースを管理

### 主要機能

- **時間期間データ型**: 期間の終了がない（infinity / forever）表現を含む
- **Valid TimeとTransaction Time期間属性の定義**: Bitemporal Relationのサポート
- **システム管理のTransaction Time**: 自動記録
- **Temporal Primary Keys**: 重複しない期間制約
- **Temporal Constraints**: 重複しない一意性および参照整合性
- **自動的な時間期間の分割と結合**: 更新・削除時に期間を自動調整
- **Temporal Queries**: 現在・過去・未来の時点または期間にわたるクエリ
- **Allen's Interval Relations**: 時間区間を問い合わせる述語

### SQL:2011標準サポート

ISO/IEC 9075（SQL:2011）Part 2: SQL/Foundationには以下の定義が含まれます:

- **Application-time Period Tables（Valid Time Tables）**: 有効時間テーブル
- **System-versioned Tables（Transaction Time Tables）**: トランザクション時間テーブル
- **System-versioned Application-time Period Tables（Bitemporal Tables）**: 二時間軸テーブル

**特徴**:
- TSQL2提案とは異なり、隠しカラムを使用しない
- 区間用の新データ型ではなく、2つのdateまたはtimestampカラムを`PERIOD FOR`宣言でバインド
- (prefix) Statement Modifiersの代わりにTemporal Predicatesを使用

### Bitemporal Modeling

**概要**:
- 2つの異なる時間軸で履歴データを扱う技術
- 「実際にそうだった」（Valid Time）と「記録されていた」（Transaction Time）の組み合わせ
- 誤ったデータも破棄せず、後から修正履歴を追跡可能

**主な利点**:
- 完全な監査証跡の作成
- すべてのデータが不変（Immutable）
- 以下のクエリが可能:
  - 現在知っている最も正確なデータ
  - 任意の時点で知っていたデータ
  - 最も正確なデータがいつ・なぜ変更されたか

**実装**:
- 主にリレーショナルDBで実装
- SQL:2011標準で言語構文を提供（ただしベンダー固有ソリューションが多い）

### Schema Evolution（スキーマ進化）

**問題**:
- データベーススキーマ変更時に、既存データとソフトウェアの機能を保持する必要がある
- スキーマ変更は、データだけでなくクエリ・アプリケーションにも影響
- MediaWiki進化の分析では、各進化ステップが最大70%のクエリに影響

**Temporal Databaseでの課題**:
- 歴史的データの大量保持により、スキーマ進化の影響が増大
- Webシステムでは変更圧力が伝統的システムより39%〜500%以上強い
- スキーマバージョン間の複雑なマッピングが必要

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 監査ログ・コンプライアンス | ⭐⭐⭐ | 完全な変更履歴を不変で保持 |
| 金融報告 | ⭐⭐⭐ | 過去のレポートを「作成時」と「修正後」の両方で再現 |
| データバージョン管理 | ⭐⭐⭐ | 時点クエリで任意の時点のデータを復元 |
| 不正検知 | ⭐⭐⭐ | データ変更パターンの分析 |
| 規制対応（GDPR、SOXなど） | ⭐⭐⭐ | 法的要件に対応した履歴管理 |
| リアルタイム分析 | ⭐⭐ | 履歴追跡のオーバーヘッドがある |
| 単純なCRUD操作のみ | ⭐ | Temporal機能は不要でオーバーキル |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 完全な監査証跡 | ストレージコストが増大 |
| 時点クエリで過去の状態を再現 | クエリが複雑になる |
| データ不変性（削除は論理削除） | パフォーマンスオーバーヘッド |
| 誤りの修正履歴を保持 | スキーマ進化が困難 |
| コンプライアンス対応 | ベンダー固有実装が多い |

### 代表的な実装・製品

**リレーショナルDBMS**:
- **MariaDB**: version 10.3.4からSQL:2011標準「System-Versioned Tables」サポート
- **Oracle Database**: Oracle Workspace Manager機能で提供
- **PostgreSQL**: version 9.2からRange型でTemporal機能をサポート
- **Teradata**: version 13.10/14でTSQL2ベースのTemporal機能
- **IBM DB2**: version 10で「Time Travel Query」機能（SQL:2011ベース）
- **Microsoft SQL Server**: SQL Server 2016で「Temporal Tables」機能

**NoSQL / Graph Database**:
- **TerminusDB**: オープンソースGraph DB、バージョン管理、Time-travelクエリ、Diffing機能をネイティブサポート
- **SirixDB**: XML/JSONドキュメントをSliding Snapshotアルゴリズムで効率的にバイナリ格納
- **Crux**: Point-in-time Bitemporal Datalog クエリ、Kafka上に構築
- **RecallGraph**: ArangoDB上に構築、Unitemporal（Transaction Time）

### 注意点

- **ストレージ管理**: Temporal Databaseは履歴データを保持するため、ストレージが急増する。アーカイブ戦略が必要
- **クエリ設計**: Temporal クエリは通常のクエリより複雑。Allen's Interval Relationsなどの理解が必要
- **パフォーマンス**: 期間インデックス、期間パーティショニングを活用してパフォーマンスを最適化
- **Schema Evolution**: スキーマ変更がクエリに大きな影響を与える。計画的な移行戦略が必要
- **Bi-temporal vs Uni-temporal**: Bitemporalは強力だが複雑。要件に応じてUnitemporalで十分な場合もある

---

## Array DBMS

### 概要

Array Database Management Systems（Array DBMS、配列データベース管理システム）は、配列（ラスターデータ）に特化したデータベースサービスを提供します。配列とは、1次元・2次元・またはそれ以上の次元の規則的なグリッド上に位置する、均質なデータ項目（ピクセル、ボクセルなど）の集合です。センサーデータ、シミュレーションデータ、画像データ、統計データなどに使用され、単一オブジェクトがテラバイト〜ペタバイト規模になることも珍しくありません。

### データ構造

**配列の定義**:
- 配列 A は関数 A: X → V として定義
- **X（ドメイン）**: d次元の整数区間（d > 0）
- **V（レンジ）**: 空でない値の集合
- 各 (p, v) ∈ A は配列要素またはセル、記法として A[p] = v

**例**:
- XGAサイズ画像のドメイン: {0..767} × {0..1023}
- 8ビットグレースケールのレンジ: {0..255}
- RGB画像のレンジ: {0..255} × {0..255} × {0..255}

**次元の例**:
- **1次元**: 環境センサー時系列データ
- **2次元**: 衛星画像
- **3次元**: x/y/t画像時系列、x/y/z地球物理データ
- **4次元**: x/y/z/t気候・海洋データ

### 配列クエリ言語

Array DBMSは宣言的で安全な配列クエリ言語を提供します。以下はrasdaman代数の例です。

**marray演算子（配列生成）**:
```
marray index-range-specification
values cell-value-expression
```

- index-range-specificationで結果ドメインを定義
- cell-value-expressionで各セルの値を計算
- イテレーション順序を指定しない（宣言的）

**例: 配列Aの切り出し**:
```
marray p in [10:20,40:50]
values A[p]
```

省略記法:
```
A[10:20,40:50]
```

**例: 配列のスライス（次元削減）**:
```
A[*:*,*:*,100]
```
- `*`はワイルドカード（配列の現在の境界を使用）
- t=100の位置でx/yのすべてのデータを取得

**例: 各セルに対数を適用**:
```
marray p in domain(A)
values log( A[p] )
```

省略記法:
```
log( A )
```

**Induced Operations（誘導操作）**:
- セル型が提供する操作を配列レベルでも提供
- 算術演算、指数関数、三角関数、ブール演算などが直接使用可能

**condense演算子（集約）**:
```
condense condense-op
over index-range-specification
using cell-value-expression
```

**例: 配列Aのすべての値の合計**:
```
condense +
over p in sdom(A)
using A[p]
```

省略記法:
```
add_cells( A )
```

**例: 8ビットグレースケール画像Aのヒストグラム**:
```
marray bucket in [0:255]
values count_cells( A = bucket )
```

### 配列ストレージ

**Tiling / Chunking**:
- 配列をサブ配列（タイルまたはチャンク）に分割
- タイルがアクセスの単位となる
- 空間的近接性を維持してディスクアクセスを削減

**Regular Partitioning（Chunking）**:
- すべてのパーティションが同じサイズ（境界を除く）

**Tiling（一般化）**:
- 任意のサイズのパーティションをサポート

**圧縮**:
- タイル圧縮でストレージを大幅に削減可能
- 結果の転送にも有効（ネットワーク帯域がボトルネック）

### クエリ処理

**Tile Streaming**:
- タイルごとに処理するストリーミング戦略
- メインメモリをはるかに超える配列を処理可能
- タイル単位でロード・処理・破棄を繰り返す

**並列化**:
- 配列演算子の多くは並列評価に適している
- 各タイルを別々のノードまたはコアで処理

### SQL/MDA標準

**ISO 9075 Part 15: SQL/MDA（Multi-Dimensional Arrays）**:
- SQL標準で多次元配列をサポート
- まだ実装は限定的

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 地球観測・衛星画像 | ⭐⭐⭐ | 2D/3D/4D配列データの自然な表現 |
| 宇宙科学 | ⭐⭐⭐ | 大規模な多次元センサーデータ |
| 生命科学（ゲノム、脳画像） | ⭐⭐⭐ | バイオイメージング、シーケンスデータ |
| 気候・海洋シミュレーション | ⭐⭐⭐ | x/y/z/t時空間データ |
| OLAP（スパースデータ） | ⭐⭐⭐ | データキューブの効率的管理 |
| 地球物理学・石油探査 | ⭐⭐⭐ | 3D地震データ |
| ビジネス統計（密データ） | ⭐⭐ | OLAPの方が一般的 |
| トランザクションデータ | ⭐ | リレーショナルDBが適切 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 多次元配列の宣言的クエリ | 標準化が不完全（ISO SQL/MDAはまだ限定的） |
| スケーラブルなストレージ（タイリング） | 学習コストが高い |
| 並列処理に適した演算子 | ツールエコシステムが限定的 |
| 大規模配列の効率的処理 | 科学コミュニティの採用が遅い |
| サブセット取得の最適化 | スパースデータには不向き（OLAP cubeを検討） |

### 代表的な実装・製品

- **rasdaman**: n-D配列の完全クエリサポート、最も長い実装トラックレコード
- **Oracle GeoRaster**: 2Dラスターマップのチャンク化ストレージ、SQLインテグレーション限定的
- **PostGIS 2.0以降**: 2Dラスターサポート、宣言的ラスタークエリ機能
- **SciQL**: MonetDB DBMSに追加される配列クエリ言語
- **SciDB**: 配列データベースサポート、配列をテーブルと同等に扱う
- **TerraLib**: オープンソースGIS、時空間データ型サポート、ラスターサポート一部

### 注意点

- **密データ vs スパースデータ**: Array DBMSは密データ（衛星画像など、ほとんどのセルに意味のある情報）に最適。スパースデータ（OLAP cubeなど）にはOLAP技術の方が効率的
- **次元設計**: 配列の次元とチャンクサイズは、アクセスパターンに合わせて設計。誤った設計はパフォーマンスを大幅に低下させる
- **タイリング戦略**: アクセスパターンに応じて最適なタイルサイズを選択。例えば時系列アクセスが多い場合、時間軸方向に長いタイルを設計
- **圧縮の選択**: 圧縮率とクエリパフォーマンスのトレードオフを考慮。ロスレス vs ロッシー圧縮の選択も重要
- **標準化の限界**: SQL/MDA標準はまだ普及していない。ベンダー固有の機能に依存すると移行が困難

---

## まとめ

NoSQL・特殊用途データベースモデルは、それぞれ異なる問題領域に特化しています。以下の判断基準を参考に選択してください：

| モデル | 主な用途 | キーワード |
|--------|---------|-----------|
| **Document-oriented** | スキーマレスデータ、オブジェクト指向アプリ | JSON、スキーマレス、階層データ |
| **XML Database** | XMLデータ管理、コンテンツ管理、セマンティックWeb | XQuery、混在コンテンツ、RDF/XML |
| **Triplestore** | ナレッジグラフ、オントロジー、データ統合 | RDF、SPARQL、推論 |
| **Temporal Database** | 監査ログ、コンプライアンス、バージョン管理 | Bitemporal、Valid/Transaction Time |
| **Array DBMS** | 科学データ、衛星画像、シミュレーション | 多次元配列、ラスターデータ、タイリング |

**選択時の注意**:
- **要件の明確化**: 標準SQLで十分か、特殊用途モデルが必要かを見極める
- **スケーラビリティ**: データ量の増加を見越した設計
- **ツールエコシステム**: ドライバー、可視化ツール、管理ツールの充実度
- **標準化**: 標準的なクエリ言語・APIが存在するか
- **ベンダーロックイン**: 移行の難易度を考慮
