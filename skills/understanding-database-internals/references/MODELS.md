# 伝統的・基盤的データベースモデル

データベース設計において、どのモデルを選択するかは、データ特性、ユースケース、パフォーマンス要件によって決まります。このドキュメントでは、歴史的に重要であり、今も特定用途で活用されるデータベースモデルを実践的な観点から解説します。

---

## Flat-file Database

### 概要

Flat-file Databaseは、データをフラットな構造（1レコード = 1行）で保存する最もシンプルなデータベース形式です。インデックスや関係性の明示的な構造を持たず、レコードは均一なフォーマットに従います。プレーンテキスト、バイナリファイル、CSV、JSON形式での実装が一般的です。

### データ構造

**固定幅フォーマット**:
- 各フィールドが固定長
- 値が短い場合は空白文字でパディング
- ロケーションオーバーヘッドが少ない

**デリミタ区切りフォーマット**:
- カンマ、タブなどの区切り文字を使用
- フィールド長可変
- デリミタ検索のオーバーヘッドあり
- データ圧縮効果がある（特に転送時）

**モダンな実装**:
- JSON、CSV形式のデータファイル
- NoSQLデータベースの一部（線形ストア）
- スプレッドシート形式

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 設定ファイル | ⭐⭐⭐⭐⭐ | `/etc/passwd`、`.env`ファイル等、小規模で単純な構造 |
| ログファイル | ⭐⭐⭐⭐ | 追記のみ、時系列データに適している |
| 一時データ保存 | ⭐⭐⭐⭐ | 軽量で実装が容易 |
| 住所録・小規模リスト | ⭐⭐⭐ | 数百件程度のデータなら十分 |
| トランザクション処理 | ⭐ | 同時書き込み、整合性管理に不向き |
| 複雑な検索 | ⭐ | インデックスがなく全件スキャン必須 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 実装が非常に簡単 | 関係性を明示的に表現できない |
| あらゆる環境で動作 | インデックスがなく検索が遅い |
| テキストエディタで編集可能 | データ整合性チェック機能なし |
| 軽量で配布しやすい | 大規模データには不向き |
| 標準ツール（`grep`、`awk`）で操作可能 | 同時書き込み制御なし |

### 代表的な実装・製品

- **Unix系OS**: `/etc/passwd`、`/etc/group`
- **初期PC時代**: FileMaker（初期版）、PC-File、dBase
- **現代**: CSV、JSON、YAML形式のデータファイル

### 注意点

- **デリミタ衝突**: データ内にデリミタ文字が含まれる場合、エスケープ処理が必要
- **データ型**: 型システムがないため、アプリケーション側で型変換が必要
- **スケーラビリティ**: 数千件を超えると検索パフォーマンスが急激に低下
- **整合性**: 外部キー制約などの機能がないため、アプリケーションロジックで管理

---

## Hierarchical Model

### 概要

Hierarchical Modelは、データをツリー構造（親子関係）で表現するモデルです。各子レコードは必ず1つの親レコードのみを持ち、親レコードは複数の子レコードを持つことができます（1対多関係）。IBMが1960年代に開発し、メインフレームDBMSで広く採用されました。

### データ構造

**ツリー構造の特徴**:
- ルートノードから始まる階層
- 各ノードは0個以上の子ノードを持つ
- 各ノード（ルート以外）は必ず1つの親ノードを持つ
- 兄弟ノード間の関係は表現できない

**制約**:
- **1対多のみサポート**: 多対多関係を直接表現できない
- **データ重複**: 多対多を表現する場合、データを複製する必要がある

### リレーショナルテーブルでの階層表現

**隣接リストモデル（Adjacency List Model）**:

```
EmpNo | Designation       | ReportsTo
------|-------------------|----------
10    | Director          | NULL
20    | Senior Manager    | 10
30    | Typist            | 20
40    | Programmer        | 20
```

- `ReportsTo`カラムが外部キー
- 自己参照テーブル構造
- リレーショナルモデルでも階層を表現可能

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 銀行取引システム | ⭐⭐⭐⭐⭐ | 口座→取引→明細といった明確な階層 |
| 通信システム | ⭐⭐⭐⭐⭐ | 高パフォーマンス・高可用性が必須 |
| ファイルシステム | ⭐⭐⭐⭐⭐ | ディレクトリ構造は自然なツリー |
| 組織図 | ⭐⭐⭐⭐ | 上司-部下の関係が明確 |
| 地理情報（国→都道府県→市区町村） | ⭐⭐⭐⭐ | 包含関係が明確 |
| 商品カテゴリ | ⭐⭐⭐ | 多対多が必要な場合は不向き |
| ソーシャルネットワーク | ⭐ | 友人関係など多対多が主体 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 高速なトラバース（親→子の取得） | 多対多関係を直接サポートしない |
| データ構造が直感的 | データ重複が発生しやすい |
| 銀行・通信系で実績豊富 | 柔軟性に欠ける |
| 高パフォーマンス | ルートから全探索が必要 |

### 代表的な実装・製品

- **IBM IMS (Information Management System)**: メインフレーム用DBMS
- **RDM Mobile**: 組み込みデバイス向け階層型DBMS
- **Windows Registry**: 設定情報の階層管理
- **ファイルシステム**: NTFS、ext4等

### 注意点

- **データ整合性**: 子レコードが孤立しないよう注意（削除時のカスケード制御）
- **リレーショナル化の潮流**: 1990年代以降、リレーショナルモデルに移行
- **XML復活**: 1990年代後半、XMLの登場で階層モデルが再注目

---

## Network Model (CODASYL)

### 概要

Network Modelは、階層モデルの制約（1対多のみ）を克服し、**多対多関係**を直接サポートするモデルです。CODASYL（Conference on Data Systems Languages）委員会が1969年に標準化し、1971年に大規模アップデートを実施。階層モデルとは異なり、レコードが複数の親・子を持つことができる一般化グラフ構造を持ちます。

### データ構造

**グラフ構造の特徴**:
- ノード（レコードタイプ）
- アーク（関係タイプ = CODASYL用語で"Set Types"）
- 循環（Cycles）を許可

**Bachmanダイアグラム**:
- Charles Bachmanが考案
- 矩形 = レコードタイプ
- 矢印 = 1対多関係

### 階層モデルとの違い

| 項目 | 階層モデル | ネットワークモデル |
|------|-----------|------------------|
| 親の数 | 1つのみ | 複数可能 |
| 子の数 | 複数可能 | 複数可能 |
| 関係性 | ツリー（1対多） | グラフ（多対多） |
| 循環 | 不可 | 可能 |

### 衰退の理由

1. **IBMの選択**: IBMがIMS（階層モデル）に固執し、ネットワークモデルを採用せず
2. **リレーショナルモデルの台頭**: 1980年代、Coddのリレーショナルモデルが優位に
3. **宣言的インターフェースの優位性**: SQLの高レベルな記述がナビゲーショナルインターフェースより生産的

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 製造業（部品表） | ⭐⭐⭐⭐ | 部品の多対多関係を自然に表現 |
| 大規模トランザクション（1970-80年代） | ⭐⭐⭐⭐ | 低レベルナビゲーションで高速 |
| エンタープライズ用途（現代） | ⭐⭐ | リレーショナルモデルが主流 |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 多対多関係を直接サポート | 操作が複雑（ナビゲーショナル） |
| 階層モデルより柔軟 | SQLのような宣言的言語がない |
| 高速なトラバース | スキーマ変更が困難 |

### 代表的な実装・製品

- **IDS (Integrated Data Store)**: Bachmanが開発
- **IDMS (Integrated Database Management System)**
- **Raima Database Manager**
- **Univac DMS-1100**
- **IMAGE (HP 3000)**
- **SIBAS Database (Norsk Data)**

### 注意点

- **歴史的遺産**: 現在は新規採用されることはほぼない
- **レガシーシステム**: 既存システムのメンテナンスでのみ遭遇
- **学術的価値**: グラフデータベースの概念的前身として重要

---

## Dimensional Model

### 概要

Dimensional Modelは、リレーショナルモデルを**データウェアハウス向けに特化**させたモデルです。OLAP（Online Analytical Processing）クエリで効率的にデータを集約・分析できるよう設計されています。中心にファクトテーブルを配置し、周囲にディメンションテーブルを配置する構造が特徴です。

### データ構造

**ファクトテーブル（Fact Table）**:
- 分析対象の数値データ（メジャー）を格納
- 例: 売上金額、販売数量、利益

**ディメンションテーブル（Dimension Table）**:
- ファクトのコンテキスト情報を提供
- 例: 日付、商品、顧客、店舗
- 通常、非正規化されている

**スキーマ構造**:
- **Star Schema**: ファクトテーブル中心、周囲にディメンション（非正規化）
- **Snowflake Schema**: ディメンションの階層を正規化し複数テーブルに分割

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| データウェアハウス | ⭐⭐⭐⭐⭐ | OLAPクエリに最適化 |
| BIツール（Tableau、Power BI） | ⭐⭐⭐⭐⭐ | 集約クエリが高速 |
| 売上分析 | ⭐⭐⭐⭐⭐ | 時間軸・商品軸でのドリルダウン |
| トランザクション処理 | ⭐ | OLTP用途には不向き |

### 長所・短所

| 長所 | 短所 |
|------|------|
| OLAP クエリが高速 | データ更新コストが高い |
| 直感的なクエリ記述 | ストレージ容量が増加（非正規化） |
| BIツールとの相性が良い | リアルタイム更新には不向き |
| ディメンション共有が可能 | トランザクション処理には不適 |

### 代表的な実装・製品

- **Star Schema / Snowflake Schema**: 物理実装パターン
- **Kimball Method**: Ralph Kimballが提唱するディメンショナルモデリング手法
- **OLAPキューブ**: Microsoft Analysis Services、IBM Cognos

### 注意点

- **データウェアハウス専用**: トランザクション処理には使わない
- **ETLプロセス**: ソースシステムからの定期的なデータ抽出・変換・ロード（ETL）が必須
- **スロー変化ディメンション（SCD）**: 時間とともに変化するディメンション（顧客住所変更等）の管理戦略が必要

---

## Entity-Attribute-Value (EAV)

### 概要

Entity-Attribute-Value（EAV）モデルは、**属性数が膨大だがスパース（大部分が空値）なデータ**を効率的に表現するモデルです。通常のリレーショナルテーブルでは数千のカラムが必要になる場合でも、EAVでは3カラム（Entity、Attribute、Value）で表現します。

### データ構造

**3カラム構造**:
- **Entity**: 記述対象（例: 患者ID、商品ID）
- **Attribute**: 属性名（例: 体温、血圧、商品カラー）
- **Value**: 属性値

**例: 患者の診察記録**

| Entity（患者イベント） | Attribute（属性） | Value（値） |
|----------------------|------------------|-----------|
| 患者XYZ, 1/5/98 9:30 | 体温（華氏） | 102 |
| 患者XYZ, 1/5/98 9:30 | 咳の有無 | True |
| 患者XYZ, 1/5/98 9:30 | 咳の種類 | 黄色い痰、血痕あり |
| 患者XYZ, 1/5/98 9:30 | 心拍数（bpm） | 98 |

### Row Modelingとの違い

**Row Modeling（標準的手法）**:
- 同質なファクトを記録（例: 商品販売明細）
- Valueの型が事前確定

**EAV**:
- 異質なファクトを混在（体温、咳、心拍数など）
- Valueの型が行ごとに異なる可能性

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 電子カルテ | ⭐⭐⭐⭐⭐ | 臨床所見の属性数が膨大かつスパース |
| ECサイト商品属性 | ⭐⭐⭐⭐ | 商品カテゴリごとに属性が大きく異なる |
| オントロジーモデリング | ⭐⭐⭐⭐ | クラス定義が頻繁に変更される |
| 通常のマスタテーブル | ⭐ | 属性が固定されている場合は不要 |

### EAV使用が必要な条件

以下のいずれかに該当する場合にEAVを検討:

1. **属性のデータ型が多様**: 数値、文字列、日付が混在
2. **カテゴリが多く、インスタンス数が少ない**: 数百のクラス、各クラスに数件のレコード
3. **属性の変動性（Attribute Volatility）**: 新しい属性が頻繁に追加される
4. **ハイブリッドクラス**: 一部の属性は全インスタンスに存在、残りはスパース

### 長所・短所

| 長所 | 短所 |
|------|------|
| スパースデータを効率的に格納 | クエリが複雑（ピボット操作必須） |
| 新規属性追加が容易（DDL不要） | パフォーマンスが低下しやすい |
| スキーマ変更なしで拡張可能 | データ型検証がDBMSで不可 |
| ストレージ効率が高い | メタデータ管理が必須 |

### EAV/CRフレームワーク

**EAV/CR（EAV with Classes and Relationships）**:
- オブジェクト指向概念をEAVに統合
- 複雑なサブストラクチャ（ネストした属性）をサポート
- メタデータから自動的にUI生成

**メタデータの役割**:
- 属性定義（データ型、範囲、正規表現）
- プレゼンテーション定義（UI要素の種類）
- バリデーションルール
- 属性間の依存関係

### クラウドベンダーのEAV実装

| サービス | データ型サポート | 特徴 |
|---------|---------------|------|
| **Amazon SimpleDB** | 文字列のみ | ソート時に数値をゼロパディング必須 |
| **Azure Table Storage** | byte[], bool, DateTime, double, Guid, int, long, string | 限定的な型サポート |
| **Google App Engine** | int, long, float, phone number, email, geocode, hyperlink | 最も豊富な型サポート、メタデータモデル定義可能 |

### 注意点

- **ピボット操作必須**: 分析ツール（Excel、統計パッケージ）に渡す前に列形式に変換
- **パフォーマンス**: インデックス戦略が重要（Entity、Attribute、Valueそれぞれにインデックス）
- **型別テーブル**: 大規模システムでは数値用、文字列用、BLOB用など型ごとにEAVテーブルを分離
- **メタデータ品質**: メタデータが不正確だとシステム全体が機能不全に

### 代替手段: XML/JSON

**PostgreSQL JSONB**（v9.4以降）:
- JSON構造をクエリ、インデックス、JOIN可能
- EAVより1000倍以上高速なケースも

**適用判断**:
- 属性数が数十程度 → XML/JSON
- 属性数が数百〜数千、ギガバイト級 → EAV

---

## Associative Model

### 概要

Associative Modelは、データとメタデータを**Items（項目）**と**Links（リンク）**の2構造のみで表現するモデルです。リレーショナルモデルのようにレコード単位で属性を束ねるのではなく、すべての関係性を明示的なリンクとして表現します。

### データ構造

**Items（項目）**:
- 固有識別子（サロゲート番号）
- 名前

**Links（リンク）**:
- 固有識別子
- Source（主語）
- Verb（述語）
- Target（目的語）

**トリプル表現**:
- すべてのファクトを「主語-述語-目的語」の形式で表現
- 例: `Flight BA1234 arrived at London Heathrow`

### 例: 航空便の到着情報

**ファクト**: "Flight BA1234 arrived at London Heathrow on 12-Dec-05 at 10:25 am"

**Items テーブル**:

| Identifier | Name |
|------------|------|
| 77 | Flight BA1234 |
| 08 | London Heathrow |
| 32 | 12-Dec-05 |
| 48 | 10:25am |
| 12 | arrived at |
| 67 | on |
| 09 | at |

**Links テーブル**:

| Identifier | Source | Verb | Target |
|------------|--------|------|--------|
| 74 | 77 | 12 | 08 |
| 03 | 74 | 67 | 32 |
| 64 | 03 | 09 | 48 |

**リンクの読み方**:
- Link 74: Flight BA1234 arrived at London Heathrow
- Link 03: (Link 74) on 12-Dec-05
- Link 64: (Link 03) at 10:25 am

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| セマンティックWeb | ⭐⭐⭐⭐⭐ | RDFトリプルと互換性 |
| ナレッジグラフ | ⭐⭐⭐⭐ | 関係性の明示的表現 |
| 複雑な関係性モデリング | ⭐⭐⭐⭐ | 柔軟な関係性表現 |
| トランザクション処理 | ⭐⭐ | 標準的なOLTPには不向き |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 関係性が明示的 | クエリが複雑 |
| RDFと互換性 | パフォーマンスオーバーヘッド |
| スキーマ変更不要 | 実装が限定的 |
| メタデータとデータの統一表現 | 学習コストが高い |

### RDFとの関連

**RDF（Resource Description Framework）**:
- W3C標準のセマンティックWeb技術
- Associative Modelと同様に「Subject-Predicate-Object」トリプル構造
- Associative Modelの実装の一つと見なせる

### 注意点

- **理論的モデル**: 実用的な実装は限定的
- **学術的価値**: グラフデータベースやセマンティックWebの概念的基礎

---

## Semantic Data Model

### 概要

Semantic Data Model（SDM）は、アプリケーション環境の**意味（Semantics）**を従来のデータベースモデルよりも豊富に捉えることを目指す高レベルなモデリング形式です。概念的データモデルとして、データベース設計プロセスの初期段階で使用されます。

### データ構造

**モデリングプリミティブ**:
- **エンティティの種類**: アプリケーション環境に存在する実体
- **分類とグルーピング**: エンティティのカテゴリ化
- **構造的相互接続**: エンティティ間の関係

**派生情報のサポート**:
- 同じ情報を複数の視点で表現可能
- 多様なユーザーニーズに対応

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| 概念設計フェーズ | ⭐⭐⭐⭐⭐ | 物理実装前の意味的整理 |
| データリソース計画 | ⭐⭐⭐⭐⭐ | エンタープライズレベルのデータ戦略 |
| ドキュメント作成 | ⭐⭐⭐⭐ | データベースの仕様書・設計書 |
| 物理実装 | ⭐ | 概念モデルであり実装モデルではない |

### IDEF1X

**IDEF1X（Integration Definition for Information Modeling）**:
- 米国防総省が開発した標準モデリング手法
- Semantic Data Modelの具体的実装
- エンティティ関連図（ERD）の標準化された記法

### 長所・短所

| 長所 | 短所 |
|------|------|
| 意味を明確に表現 | 実装への変換が必要 |
| ステークホルダー間の共通理解 | 学習コストが高い |
| 設計品質の向上 | ツールサポートが限定的 |
| ドキュメントとして価値が高い | 概念モデルと物理モデルのギャップ |

### 注意点

- **概念モデル**: 直接データベース実装には使わない
- **設計フェーズ**: 要件定義〜論理設計で使用
- **変換**: 物理設計時にリレーショナルモデル等に変換

---

## Multidimensional Databases

### 概要

Multidimensional Databasesは、データを**多次元キューブ構造**で表現するモデルです。リレーショナルモデルの変種として、データと関係性を多次元空間で整理し、OLAP（Online Analytical Processing）アプリケーションで高速な集約クエリを実現します。

### データ構造

**キューブ構造**:
- **次元（Dimension）**: 軸（例: 時間、商品、地域）
- **セル（Cell）**: 各次元の要素の交点に集約データを格納
- **メジャー（Measure）**: セルに格納される数値（例: 売上高、数量）

**例: 3次元キューブ**:
- X軸: 商品カテゴリ
- Y軸: 地域
- Z軸: 時間
- セル値: 売上金額

### OLAPとの関係

**OLAP操作**:
- **スライス（Slice）**: 1次元を固定して2次元表示
- **ダイス（Dice）**: 複数次元を絞り込み
- **ドリルダウン（Drill-down）**: 詳細レベルに掘り下げ
- **ロールアップ（Roll-up）**: 集約レベルに上昇

### 適用場面

| ユースケース | 適合度 | 理由 |
|-------------|-------|------|
| ビジネスインテリジェンス | ⭐⭐⭐⭐⭐ | 多角的なデータ分析 |
| 売上分析 | ⭐⭐⭐⭐⭐ | 時間・商品・地域での切り口 |
| 財務報告 | ⭐⭐⭐⭐ | 部門・期間での集約 |
| リアルタイム更新 | ⭐⭐ | 集約データの再計算コスト |
| トランザクション処理 | ⭐ | OLTP用途には不向き |

### 長所・短所

| 長所 | 短所 |
|------|------|
| 複雑な分析クエリが高速 | データ更新コストが高い |
| 直感的なデータ切り口 | ストレージ容量が増加 |
| ビジネスユーザーに理解しやすい | 次元数が増えるとスパースになる |
| 事前集約でパフォーマンス向上 | リアルタイム性に欠ける |

### 代表的な実装・製品

- **Microsoft Analysis Services (SSAS)**
- **IBM Cognos TM1**
- **Oracle Essbase**
- **SAP BW/4HANA**

### 注意点

- **キューブ爆発**: 次元数が増えるとセル数が指数的に増加
- **更新頻度**: 通常は日次・週次でのバッチ更新
- **Dimensional Modelとの関係**: Multidimensional Databasesは物理実装、Dimensional Modelは論理設計

---

## モデル選択ガイド

実際のプロジェクトでは、以下の表を参考にモデルを選択してください：

| データ特性 | 推奨モデル |
|-----------|----------|
| 小規模・シンプル・単一目的 | **Flat-file** |
| 明確な親子関係・階層構造 | **Hierarchical** |
| 多対多関係が主体（レガシー） | **Network**（現在は非推奨） |
| OLAP・データウェアハウス | **Dimensional** / **Multidimensional** |
| 属性数膨大・スパース | **EAV** / JSON/XML |
| セマンティックWeb・ナレッジグラフ | **Associative** / RDF |
| 概念設計・要件定義 | **Semantic Data Model** |

---

## まとめ

- **Flat-file**: 設定ファイル、ログ、小規模リストに最適
- **Hierarchical**: 銀行・通信・ファイルシステムで現役
- **Network**: 歴史的意義、現在は非推奨
- **Dimensional**: データウェアハウス・OLAP専用
- **EAV**: 電子カルテ、EC商品属性など、スパースデータに有効
- **Associative**: セマンティックWeb、RDFとの親和性
- **Semantic Data Model**: 概念設計・ドキュメント用途
- **Multidimensional**: OLAP・BIツール向けキューブ構造

これらのモデルは、現代のリレーショナル・NoSQLデータベースの基礎概念として今も活用されています。適切なモデル選択により、システムのパフォーマンス、保守性、拡張性が大きく向上します。
