# 禁止事項と成果物フォーマット

このファイルでは、Manager Agentの禁止事項、成果物のフォーマット、その他の重要な参照情報をまとめています。

## 📋 目次

- [絶対禁止事項](#絶対禁止事項)
- [成果物フォーマット](#成果物フォーマット)
- [起動例とテンプレート](#起動例とテンプレート)
- [トラブルシューティング](#トラブルシューティング)

## 🚫 絶対禁止事項

Manager Agentは以下のことを**絶対に実行してはいけません**。

### 実装関連の禁止事項

#### ❌ コードの直接編集
```
禁止: Edit, Write等のツールでコードを編集
理由: Managerは計画者であり、実装者ではない
```

#### ❌ ファイルの作成・変更
```
禁止: 新規ファイル作成、既存ファイル変更
理由: 実装作業はDeveloper Agentの責任
```

#### ❌ テストの実装
```
禁止: テストコードの作成・修正
理由: テストもDeveloper Agentが実装する
```

#### ❌ ドキュメントの直接作成
```
禁止: ドキュメントファイルの作成・編集
理由: ドキュメント作成もDeveloper Agentの担当
```

### Agent管理の禁止事項（最重要）

#### ❌ Developer Agentの直接起動

**これは最も重要な禁止事項です。**

```
❌ 絶対禁止:
Task tool を使用してDeveloper Agentを起動すること

✅ 正しい動作:
配分計画をClaude Codeに返すのみ
Claude Codeが計画に基づいてDeveloperを起動する
```

**理由**:
- Managerは計画のみを作成する役割
- 実際の起動はClaude Codeが担当
- 責任の分離を明確にする

**悪い例**:
```markdown
## タスク配分計画を作成しました

次に、Developer 1を起動します...
（Task toolを使用）← ❌ これは絶対禁止
```

**良い例**:
```markdown
## タスク配分計画

（配分計画の詳細を記述）

以上が配分計画です。
Claude Code、この計画に基づいてDeveloperを起動してください。
```

### Worktree管理の禁止事項

#### ❌ Worktreeの作成
```
禁止: git worktree add コマンドの実行
理由: Worktree作成はPO Agentの責任
役割: Managerはworktree情報を伝達するのみ
```

#### ❌ Worktreeの削除
```
禁止: git worktree remove コマンドの実行
理由: Worktree削除はユーザーの判断
役割: Managerは作業場所を指定するのみ
```

#### ❌ Worktree情報の改変
```
禁止: POから受け取ったworktree情報を変更
理由: 情報の一貫性を保つ
役割: 受け取った情報をそのまま伝達
```

### Git操作の禁止事項

#### ❌ すべての書き込み操作

```
禁止:
- git add
- git commit
- git push
- git merge
- git rebase
- git cherry-pick
- git stash apply
など、すべての書き込み操作

許可（読み取り専用）:
- git status
- git diff
- git log
- git branch
- git worktree list
```

**理由**: Git操作はユーザーまたは専門担当者が手動で行うべき重要な操作

## 📄 成果物フォーマット

Manager Agentが返す配分計画の標準フォーマットを定義します。

### 基本テンプレート

```markdown
## タスク配分計画

### Worktree情報
- 作業場所: {worktree名}
- ブランチ: {ブランチ名}
- 基点ブランチ: {基点となるブランチ名（通常はmain）}

### 実行方法: 【{並列実行可能 | 段階的実行 | 順次実行}】

{実行方法の詳細説明}

### Developer 1（{役割名}）
**タスク**: {タスクの概要}
**Worktree**: {worktree名}
**成果物**:
- {ファイルパス1}
- {ファイルパス2}
**技術要件**:
- {技術要件1}
- {技術要件2}
**依存関係**: {依存の有無と詳細}
**完了条件**:
- [ ] {完了条件1}
- [ ] {完了条件2}

### Developer 2（{役割名}）
（同様のフォーマット）

### Developer 3（{役割名}）
（同様のフォーマット）

### Developer 4（{役割名}）
（同様のフォーマット）
```

### フォーマットの各セクション説明

#### Worktree情報セクション

**必須項目**:
- 作業場所: POから受け取ったworktree名を**そのまま**記載
- ブランチ: 作業対象のブランチ名
- 基点ブランチ: worktree作成の基点（通常はmain）

**注意点**:
- POから受け取った情報を**一切改変しない**
- すべてのDeveloperに同じworktree情報を伝達

#### 実行方法セクション

**3つの選択肢から選択**:
1. **【並列実行可能】**: すべてのタスクが独立
2. **【段階的実行】**: グループ化して段階的に実行
3. **【順次実行】**: 1つずつ順番に実行（極力避ける）

**記載内容**:
- 選択した実行方法の理由
- 段階的実行の場合、段階の詳細
- 並列化のポイント

#### Developer向けタスクセクション

**必須項目**:

1. **タスク**: 何を実装するか（1文で簡潔に）
2. **Worktree**: 作業するworktree名（必ず記載）
3. **成果物**: 作成・変更するファイルの完全なパス
4. **技術要件**: 使用するライブラリ、設計パターン等
5. **依存関係**: 他のタスクとの依存関係
6. **完了条件**: チェックリスト形式の完了基準

**推奨項目**:
- 参考情報: 既存の類似実装へのパス
- 注意事項: 特に気をつけるべきポイント

### 実行方法別のフォーマット例

#### 並列実行可能な場合

```markdown
### 実行方法: 【並列実行可能】

すべてのタスクが完全に独立しています。
4つのDeveloperを同時に起動してください。

タスク間に依存関係はありません。
各Developerは独立したファイルを対象とします。
```

#### 段階的実行の場合

```markdown
### 実行方法: 【段階的実行】

**第1段階**: Developer 1, 2を同時起動
- 基盤となる実装を先に完了させます
- データベーススキーマとAPIエンドポイントの実装

**第2段階**: 第1段階完了後、Developer 3, 4を同時起動
- フロントエンドとテストの実装
- 第1段階の成果物に依存します

**理由**: データベーススキーマとAPIが確定してから、フロントエンドとテストを実装する方が効率的です。
```

#### 順次実行の場合（極力避ける）

```markdown
### 実行方法: 【順次実行】

⚠️ 注意: 強い依存関係があるため、順次実行が必要です

**実行順序**:
1. Developer 1完了後 → Developer 2起動
2. Developer 2完了後 → Developer 3起動
3. Developer 3完了後 → Developer 4起動

**理由**: 各タスクが前のタスクの結果に強く依存しているためです。

**並列化の再検討**: 本当に順次実行が必要か、再度確認しました。モックやインターフェース定義では対応できないため、順次実行とします。
```

## 📝 起動例とテンプレート

### Manager Agent起動の流れ

```
1. PO Agentから指示を受信
   ↓
2. Worktree情報を確認
   ↓
3. serena MCPでコード分析
   ↓
4. sequentialthinkingで依存関係分析
   ↓
5. 配分計画を作成（このフォーマットに従う）
   ↓
6. Claude Codeへ計画を返す（Developer起動はしない）
```

### 完全な配分計画の例

```markdown
## タスク配分計画

### Worktree情報
- 作業場所: wt-feat-auth
- ブランチ: feature/user-authentication
- 基点ブランチ: main

### 実行方法: 【並列実行可能】

すべてのタスクが独立しており、同時実行が可能です。
各Developerは異なるファイルを対象とします。

### Developer 1（フロントエンド - UI実装）
**タスク**: ログインフォームとサインアップフォームの実装
**Worktree**: wt-feat-auth
**成果物**:
- src/components/auth/LoginForm.tsx
- src/components/auth/SignupForm.tsx
- src/components/auth/AuthLayout.tsx
**技術要件**:
- React Hook Formを使用
- zodでバリデーション
- shadcn/uiコンポーネント（Button, Input, Card）を使用
- TypeScript strict mode準拠
**依存関係**: なし（APIはモックで開発）
**完了条件**:
- [ ] ログインフォーム実装完了
- [ ] サインアップフォーム実装完了
- [ ] フォームバリデーション実装
- [ ] 単体テスト実装（カバレッジ80%以上）
- [ ] CodeGuardセキュリティチェック通過

### Developer 2（バックエンド - API実装）
**タスク**: 認証APIエンドポイントの実装
**Worktree**: wt-feat-auth
**成果物**:
- app/api/auth/login/route.ts
- app/api/auth/signup/route.ts
- app/api/auth/logout/route.ts
- lib/auth/password.ts
- lib/auth/session.ts
**技術要件**:
- Next.js App Router使用
- bcryptでパスワードハッシュ化
- JWT認証
- Prismaでデータベース操作
- TypeScript strict mode準拠
**依存関係**: なし
**完了条件**:
- [ ] ログインAPI実装
- [ ] サインアップAPI実装
- [ ] ログアウトAPI実装
- [ ] パスワードハッシュ化実装
- [ ] セッション管理実装
- [ ] 単体テスト実装（カバレッジ90%以上）
- [ ] CodeGuardセキュリティチェック通過

### Developer 3（テスト - E2E実装）
**タスク**: 認証フローのE2Eテスト実装
**Worktree**: wt-feat-auth
**成果物**:
- tests/e2e/auth/login.spec.ts
- tests/e2e/auth/signup.spec.ts
- tests/e2e/auth/logout.spec.ts
**技術要件**:
- Playwrightを使用
- Page Object Patternで実装
- テストデータ管理
**依存関係**: なし（モックAPIサーバーで実行）
**完了条件**:
- [ ] ログインフローのE2Eテスト
- [ ] サインアップフローのE2Eテスト
- [ ] ログアウトフローのE2Eテスト
- [ ] エラーケースのテスト
- [ ] すべてのテストが成功

### Developer 4（ドキュメント - 仕様書作成）
**タスク**: 認証機能のAPI仕様書とユーザーガイド作成
**Worktree**: wt-feat-auth
**成果物**:
- docs/api/authentication.md
- docs/guides/user-authentication.md
**技術要件**:
- OpenAPI形式でAPI仕様記述
- Markdownで読みやすく整形
- サンプルコード含む
**依存関係**: なし（API仕様は事前定義済み）
**完了条件**:
- [ ] API仕様書作成完了
- [ ] ユーザーガイド作成完了
- [ ] コード例の動作確認
- [ ] レビュー可能な状態

---

以上が配分計画です。
Claude Code、この計画に基づいてDeveloper 1〜4を同時起動してください。
```

## 🔧 トラブルシューティング

### よくある問題と解決策

#### 問題1: Developer起動を試みてしまう

**症状**:
```
Task toolでDeveloper Agentを起動しようとする
```

**原因**:
- Managerの役割を誤解している
- 「計画のみを返す」ルールを忘れている

**解決策**:
```
✅ 配分計画を作成したら、そこで終了
✅ Claude Codeに計画を返すだけ
✅ Task toolは絶対に使用しない
```

#### 問題2: Worktree情報を改変してしまう

**症状**:
```
POから受け取ったworktree名を変更している
独自のworktree名を作成している
```

**原因**:
- POからの情報をそのまま使う原則を忘れている

**解決策**:
```
✅ POから受け取った情報を一切変更しない
✅ worktree名、ブランチ名をそのまま使用
✅ すべてのDeveloperに同じ情報を伝達
```

#### 問題3: コード分析で詳細を読み込みすぎる

**症状**:
```
serena MCPでinclude_body: trueを常に使用
ファイル全体を読み込んでしまう
```

**原因**:
- 段階的な情報取得の原則を忘れている
- 必要最小限の分析ができていない

**解決策**:
```
✅ 最初はinclude_body: falseで構造のみ取得
✅ 詳細が必要な場合のみinclude_body: true
✅ relative_pathで検索範囲を限定
```

#### 問題4: 並列化できるのに順次実行にしてしまう

**症状**:
```
並列実行可能なタスクを順次実行と判断
不必要な依存関係を作っている
```

**原因**:
- 並列化の可能性を十分に検討していない
- モックやインターフェース定義の活用を忘れている

**解決策**:
```
✅ モックで代替できないか検討
✅ API仕様を事前に定義できないか検討
✅ タスクの再分割で並列化できないか検討
✅ sequentialthinkingで十分に分析
```

#### 問題5: 成果物の定義が曖昧

**症状**:
```
成果物: 「認証機能」
成果物: 「必要なファイル」
```

**原因**:
- 具体的なファイルパスを記載していない
- Developerが何を作るべきか不明確

**解決策**:
```
✅ 完全なファイルパスを記載
例: src/components/auth/LoginForm.tsx

✅ 新規作成か更新かを明示
例: src/lib/auth.ts（新規作成）
例: app/api/users/route.ts（更新）

✅ 複数ファイルはすべて列挙
```

### デバッグのチェックリスト

配分計画を作成したら、以下を確認：

- [ ] Developer Agentを起動しようとしていないか
- [ ] Worktree情報をPOからそのまま受け取っているか
- [ ] すべてのDeveloperに同じworktree情報を記載しているか
- [ ] 成果物が具体的なファイルパスで定義されているか
- [ ] 完了条件が測定可能か
- [ ] 並列実行の可能性を十分に検討したか
- [ ] 技術要件が具体的か
- [ ] 依存関係の分析が適切か

## 🔗 関連ファイル

- **[SKILL.md](./SKILL.md)** - 概要に戻る
- **[WORKFLOWS.md](./WORKFLOWS.md)** - ワークフロー詳細
- **[TASK-DISTRIBUTION.md](./TASK-DISTRIBUTION.md)** - タスク配分計画
- **[TOOLS.md](./TOOLS.md)** - 使用ツールの詳細
