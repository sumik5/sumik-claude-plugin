# タスク配分計画と実行方法判断

このファイルでは、Manager Agentによるタスク配分計画の作成方法と、実行方法の判断基準を詳しく説明します。

## 📋 目次

- [実行方法の3つのパターン](#実行方法の3つのパターン)
- [判断基準](#判断基準)
- [並列実行可能な場合](#並列実行可能な場合)
- [段階的実行が必要な場合](#段階的実行が必要な場合)
- [順次実行が必要な場合](#順次実行が必要な場合)
- [配分計画の実例](#配分計画の実例)

## 🎯 実行方法の3つのパターン

### 1. 【並列実行可能】（最優先）

**定義**: すべてのタスクが完全に独立しており、同時実行が可能

**条件**:
- タスク間にデータ依存がない
- 共有リソースへの競合がない
- 実行順序が結果に影響しない

**メリット**:
- ⚡ 最速の完了時間
- 🔄 効率的なリソース活用
- 📊 最大のスループット

**Developer起動方法**:
```
dev1, dev2, dev3, dev4を1つのメッセージで同時起動
```

### 2. 【段階的実行】（推奨）

**定義**: タスクをグループ化し、グループ内は並列、グループ間は順次実行

**条件**:
- 一部のタスクに依存関係がある
- 段階的に完了する必要がある
- グループ内では並列化可能

**メリット**:
- ⚡ 並列性を活かせる
- 📊 依存関係を管理できる
- 🔄 段階的な進捗確認

**Developer起動方法**:
```
第1段階: dev1, dev2を1つのメッセージで同時起動
第1段階完了後
第2段階: dev3, dev4を1つのメッセージで同時起動
```

### 3. 【順次実行】（極力避ける）

**定義**: タスクを1つずつ順番に実行

**条件**:
- タスク間に強い依存関係がある
- 前のタスクの結果が次のタスクの入力になる
- 並列化が技術的に不可能

**デメリット**:
- ⏱️ 完了時間が長い
- 💤 リソースの非効率的な使用
- 🔄 スループットが低い

**Developer起動方法**:
```
dev1完了後 → dev2起動
dev2完了後 → dev3起動
dev3完了後 → dev4起動
```

**⚠️ 注意**: できる限り並列化または段階的実行に変更できないか検討してください

## 🔍 判断基準

### 判断フローチャート

```
タスク分析開始
    ↓
すべてのタスクが独立？
    ├─ Yes → 【並列実行可能】
    └─ No → 一部のタスクに依存関係あり
        ↓
        グループ化可能？
        ├─ Yes → 【段階的実行】
        └─ No → すべてに強い依存
            ↓
            並列化の再検討
            ├─ 可能 → タスクを再設計して【段階的実行】
            └─ 不可能 → 【順次実行】（最終手段）
```

### 依存関係の分析

#### データ依存

**例**: バックエンドAPIの実装がフロントエンドの前提条件

```
✅ 並列化可能なケース:
- フロントエンド: モックデータで開発
- バックエンド: API仕様に基づいて開発
→ 仕様が明確なら並列実行可能

❌ 順次実行が必要なケース:
- フロントエンド: バックエンドの実際のレスポンスが必要
→ バックエンド完了後にフロントエンド開始
```

#### リソース依存

**例**: データベーススキーマの変更

```
🔄 段階的実行が適切:
第1段階: データベーススキーマ変更（dev1）
第2段階: スキーマに依存する機能開発（dev2, dev3, dev4）
→ スキーマ変更完了後、並列で機能開発
```

#### 論理依存

**例**: 設計ドキュメントがコード実装の前提

```
✅ 段階的実行に変更可能:
第1段階: 設計ドキュメント作成（dev1）+ 環境構築（dev2）
第2段階: 実装（dev3, dev4）
→ 無関係なタスクを第1段階に含めて並列化
```

## ✅ 並列実行可能な場合

### 特徴

- すべてのタスクが独立
- 相互に影響しない
- 同時実行で問題ない

### 配分計画の例

```markdown
## タスク配分計画

### Worktree情報
- 作業場所: wt-feat-auth
- ブランチ: feature/user-auth

### 実行方法: 【並列実行可能】

### Developer 1（フロントエンド）
**タスク**: ログインフォームの実装
**Worktree**: wt-feat-auth
**成果物**:
- src/components/LoginForm.tsx
- src/components/LoginForm.test.tsx
**依存関係**: なし

### Developer 2（バックエンド）
**タスク**: 認証APIの実装
**Worktree**: wt-feat-auth
**成果物**:
- app/api/auth/route.ts
- app/api/auth/route.test.ts
**依存関係**: なし

### Developer 3（テスト）
**タスク**: E2Eテストの実装
**Worktree**: wt-feat-auth
**成果物**:
- tests/e2e/login.spec.ts
**依存関係**: なし（モックAPIを使用）

### Developer 4（ドキュメント）
**タスク**: API仕様書の作成
**Worktree**: wt-feat-auth
**成果物**:
- docs/api/auth.md
**依存関係**: なし
```

### 判断のポイント

✅ **並列実行可能と判断できる条件**:
- [ ] 各タスクが独立したファイルを対象としている
- [ ] 共有リソースへのアクセスがない
- [ ] タスク間でデータのやり取りが不要
- [ ] モックやスタブで代替可能
- [ ] 実行順序が結果に影響しない

## 🔄 段階的実行が必要な場合

### 特徴

- 一部のタスクに依存関係がある
- グループ化して段階的に実行
- 各段階内では並列実行

### 配分計画の例

```markdown
## タスク配分計画

### Worktree情報
- 作業場所: wt-feat-payment
- ブランチ: feature/payment-integration

### 実行方法: 【段階的実行】

**第1段階**: 基本実装（Developer 1, 2を同時起動）

### Developer 1（バックエンド - 決済API）
**タスク**: 決済APIの基本実装
**Worktree**: wt-feat-payment
**成果物**:
- app/api/payment/route.ts
- lib/payment/stripe.ts
**依存関係**: なし

### Developer 2（データベース）
**タスク**: 決済履歴テーブルの作成
**Worktree**: wt-feat-payment
**成果物**:
- prisma/schema.prisma（更新）
- prisma/migrations/xxx_add_payment_history.sql
**依存関係**: なし

---

**第2段階**: 第1段階完了後、統合実装（Developer 3, 4を同時起動）

### Developer 3（フロントエンド）
**タスク**: 決済フォームの実装
**Worktree**: wt-feat-payment
**成果物**:
- src/components/PaymentForm.tsx
**依存関係**: Developer 1の決済API実装に依存

### Developer 4（テスト）
**タスク**: 決済フローのE2Eテスト
**Worktree**: wt-feat-payment
**成果物**:
- tests/e2e/payment.spec.ts
**依存関係**: Developer 1, 2の実装に依存
```

### 段階分けの基準

**第1段階に含めるタスク**:
- 基盤となる実装
- 他のタスクの前提条件
- 独立して実行可能なタスク

**第2段階以降に含めるタスク**:
- 第1段階の成果物を使用するタスク
- 統合が必要なタスク
- テストやドキュメント

### 判断のポイント

✅ **段階的実行が適切な条件**:
- [ ] タスクを依存関係でグループ化できる
- [ ] 各段階内で並列実行可能
- [ ] 段階間の待ち時間が許容範囲
- [ ] 段階数が2〜3程度（多すぎない）

## ⏭️ 順次実行が必要な場合

### 特徴（極力避ける）

- タスク間に強い依存関係
- 前のタスクの完了が必須
- 並列化が困難

### 配分計画の例

```markdown
## タスク配分計画

### Worktree情報
- 作業場所: wt-refactor-db
- ブランチ: refactor/database-migration

### 実行方法: 【順次実行】

⚠️ 注意: 強い依存関係があるため順次実行が必要です

### Developer 1（データベーススキーマ変更）
**タスク**: スキーマの大規模リファクタリング
**Worktree**: wt-refactor-db
**成果物**:
- prisma/schema.prisma（全面変更）
- prisma/migrations/xxx_major_refactor.sql
**依存関係**: なし
**完了条件**: マイグレーション実行完了

↓ Developer 1完了後、Developer 2起動

### Developer 2（ORM層の更新）
**タスク**: Prismaクライアントの型定義更新
**Worktree**: wt-refactor-db
**成果物**:
- lib/db/client.ts（更新）
**依存関係**: Developer 1のスキーマ変更に依存
**完了条件**: 型エラーがすべて解決

↓ Developer 2完了後、Developer 3起動

### Developer 3（アプリケーション層の修正）
**タスク**: スキーマ変更に伴うコード修正
**Worktree**: wt-refactor-db
**成果物**:
- app/（複数ファイル更新）
**依存関係**: Developer 2の型定義更新に依存
**完了条件**: ビルドエラーがすべて解決

↓ Developer 3完了後、Developer 4起動

### Developer 4（テスト修正）
**タスク**: テストコードの更新
**Worktree**: wt-refactor-db
**成果物**:
- tests/（複数ファイル更新）
**依存関係**: Developer 3のコード修正に依存
**完了条件**: すべてのテストが成功
```

### 順次実行を避ける工夫

順次実行が必要に見えても、以下の工夫で並列化できる場合があります：

#### 1. インターフェース定義の事前共有

```
❌ 順次実行:
1. バックエンドAPI実装
2. フロントエンド実装（APIレスポンス待ち）

✅ 並列実行に変更:
0. API仕様書を事前に作成（OpenAPI/Swagger）
1. バックエンド: 仕様に基づいて実装
2. フロントエンド: 仕様に基づいてモックで開発
→ 並列実行可能
```

#### 2. モック・スタブの活用

```
❌ 順次実行:
1. データベース変更
2. アプリケーション実装（DB変更待ち）

✅ 並列実行に変更:
1. データベース変更: dev1
2. アプリケーション実装: dev2（モックDBで開発）
→ 並列実行可能、統合は後で実施
```

#### 3. タスクの再分割

```
❌ 順次実行:
1. 巨大な機能A実装
2. 機能Aに依存する機能B実装

✅ 段階的実行に変更:
第1段階:
  - 機能Aのコア部分: dev1
  - 機能Bの独立部分: dev2
第2段階:
  - 機能Aと機能Bの統合: dev3, dev4
→ 段階的実行で並列性を確保
```

## 📊 配分計画の実例

### 実例1: Webアプリケーション新機能（並列実行）

```markdown
## タスク配分計画: ダッシュボード機能追加

### Worktree情報
- 作業場所: wt-feat-dashboard
- ブランチ: feature/analytics-dashboard

### 実行方法: 【並列実行可能】

### Developer 1（フロントエンド - UI）
**タスク**: ダッシュボードUIコンポーネントの実装
**成果物**:
- src/components/Dashboard.tsx
- src/components/charts/LineChart.tsx
- src/components/charts/BarChart.tsx
**技術要件**: shadcn/ui, recharts使用

### Developer 2（バックエンド - API）
**タスク**: アナリティクスデータ取得APIの実装
**成果物**:
- app/api/analytics/route.ts
- lib/analytics/calculator.ts
**技術要件**: Next.js App Router, Prisma使用

### Developer 3（テスト - E2E）
**タスク**: ダッシュボード機能のE2Eテスト
**成果物**:
- tests/e2e/dashboard.spec.ts
**技術要件**: Playwright使用、モックAPIで実行

### Developer 4（ドキュメント）
**タスク**: ダッシュボード機能のドキュメント作成
**成果物**:
- docs/features/dashboard.md
- docs/api/analytics.md
**技術要件**: 仕様に基づいて記述
```

### 実例2: マイクロサービス統合（段階的実行）

```markdown
## タスク配分計画: 外部決済サービス統合

### Worktree情報
- 作業場所: wt-feat-payment-service
- ブランチ: feature/stripe-integration

### 実行方法: 【段階的実行】

**第1段階**: 基盤実装（Developer 1, 2を同時起動）

### Developer 1（バックエンド - 決済ロジック）
**タスク**: Stripe API統合ロジックの実装
**成果物**:
- lib/payment/stripe-client.ts
- lib/payment/webhook-handler.ts

### Developer 2（インフラ - 環境構築）
**タスク**: Stripe環境設定とシークレット管理
**成果物**:
- .env.example（更新）
- docs/setup/stripe-setup.md

---

**第2段階**: アプリケーション統合（Developer 3, 4を同時起動）

### Developer 3（フロントエンド - UI）
**タスク**: 決済フォームとチェックアウトフローの実装
**成果物**:
- src/components/CheckoutForm.tsx
**依存関係**: Developer 1の決済ロジックに依存

### Developer 4（テスト - 統合テスト）
**タスク**: 決済フローの統合テスト
**成果物**:
- tests/integration/payment.test.ts
**依存関係**: Developer 1の実装に依存
```

### 実例3: レガシーシステムリファクタリング（段階的実行）

```markdown
## タスク配分計画: 認証システムのモダナイゼーション

### Worktree情報
- 作業場所: wt-refactor-auth
- ブランチ: refactor/modernize-auth

### 実行方法: 【段階的実行】

**第1段階**: 新認証システムの実装（Developer 1, 2を同時起動）

### Developer 1（バックエンド - 新認証ロジック）
**タスク**: NextAuth.js v5への移行
**成果物**:
- auth.ts（新規）
- app/api/auth/[...nextauth]/route.ts

### Developer 2（データベース - スキーマ更新）
**タスク**: NextAuth用テーブルの作成
**成果物**:
- prisma/schema.prisma（更新）
- prisma/migrations/xxx_nextauth_tables.sql

---

**第2段階**: アプリケーション統合（Developer 3, 4を同時起動）

### Developer 3（フロントエンド - UI更新）
**タスク**: 新認証フローに対応したUI更新
**成果物**:
- src/components/auth/（複数ファイル更新）
**依存関係**: Developer 1の新認証ロジックに依存

### Developer 4（テスト - 回帰テスト）
**タスク**: 認証関連の回帰テスト実装
**成果物**:
- tests/e2e/auth.spec.ts（全面更新）
**依存関係**: Developer 1, 3の実装に依存
```

## 🔑 配分計画作成のポイント

### 並列化を最大化する

1. **依存関係を最小化**
   - インターフェース定義を事前に共有
   - モック・スタブを活用
   - 独立性の高いタスク設計

2. **グループ化で段階を減らす**
   - 無関係なタスクは同じ段階に
   - 段階数は2〜3が理想
   - 各段階の粒度を揃える

3. **順次実行を避ける工夫**
   - タスクの再分割を検討
   - 仕様の事前確定
   - 技術的な代替案を探す

### 明確な成果物定義

1. **具体的なファイルパス**
   - 曖昧な表現を避ける
   - ファイル名を明記
   - 新規/更新を明示

2. **測定可能な完了条件**
   - テストカバレッジ
   - CodeGuardチェック
   - ビルド成功

3. **技術要件の明示**
   - 使用するライブラリ
   - 設計パターン
   - パフォーマンス基準

## 🔗 関連ファイル

- **[SKILL.md](./SKILL.md)** - 概要に戻る
- **[WORKFLOWS.md](./WORKFLOWS.md)** - ワークフロー詳細
- **[TOOLS.md](./TOOLS.md)** - 使用ツールの詳細
- **[REFERENCE.md](./REFERENCE.md)** - 禁止事項と成果物フォーマット
